<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>香辣猪蹄儿</title>
  <subtitle>认认真真写代码，&lt;br/&gt;开开心心吃猪蹄。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yvshuo.github.io/"/>
  <updated>2017-03-25T10:07:20.000Z</updated>
  <id>http://yvshuo.github.io/</id>
  
  <author>
    <name>yvshuo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Promises</title>
    <link href="http://yvshuo.github.io/2017/03/25/2017-03-25-es6-4/"/>
    <id>http://yvshuo.github.io/2017/03/25/2017-03-25-es6-4/</id>
    <published>2017-03-25T08:49:49.000Z</published>
    <updated>2017-03-25T10:07:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>Promises are a library for asynchronous programming.<br>类似于jQuery里的<code>Deferred</code>对象，Promises提供了异步编程的解决方案，一个简单的例子：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeout</span>(<span class="params">duration = <span class="number">0</span></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</div><div class="line">        setTimeout(resolve, duration);</div><div class="line">    &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> p = timeout(<span class="number">1000</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">return</span> timeout(<span class="number">2000</span>);</div><div class="line">&#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"hmm"</span>);</div><div class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.all([timeout(<span class="number">100</span>), timeout(<span class="number">200</span>)]);</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>这种调用方式比起传统的回调函数的方式看起来舒服不止一百倍。<br><a id="more"></a></p>
<h2 id="1、Promise对象的三种状态"><a href="#1、Promise对象的三种状态" class="headerlink" title="1、Promise对象的三种状态"></a>1、Promise对象的三种状态</h2><ul>
<li>Pending 进行中</li>
<li>Resolve 已完成</li>
<li>reject 已失败<br>类比于回调函数中的写法,resolve类似于success的回调，reject类似于fail的回调，Promise对象状态的变化就两种，一种从<code>Pending</code>进入<code>Resolve</code>,一种从<code>Pending</code>进入<code>Reject</code>。<br><code>Promise.prototype.then()</code>提供了两个回调的参数，<code>then(resolve, reject)</code>，但是更好的一种写法是在<code>Promise.prototype.catch()</code>中来写失败的回调，这样可以让程序读起来更舒服。<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> someAsyncThing = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    <span class="comment">// 下面一行会报错，因为x没有声明</span></div><div class="line">    resolve(x + <span class="number">2</span>);</div><div class="line">  &#125;);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">someAsyncThing()</div><div class="line">.catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'oh no'</span>, error);</div><div class="line">&#125;)</div><div class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'carry on'</span>);</div><div class="line">&#125;);</div><div class="line"><span class="comment">// oh no [ReferenceError: x is not defined]</span></div><div class="line"><span class="comment">// carry on</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p><code>Promise.prototype.catch()</code>返回的仍然是一个<code>Promise</code>对象，后面可以接着调用<code>then</code>方法。</p>
<h2 id="2、Promise对象的几个方法"><a href="#2、Promise对象的几个方法" class="headerlink" title="2、Promise对象的几个方法"></a>2、Promise对象的几个方法</h2><h3 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve"></a>Promise.resolve</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="built_in">Promise</span>.resolve(<span class="string">'foo'</span>)</div><div class="line"><span class="comment">// 等价于</span></div><div class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve(<span class="string">'foo'</span>))</div></pre></td></tr></table></figure>
<p>返回一个resolved的Promise对象。</p>
<h3 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject"></a>Promise.reject</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> p = <span class="built_in">Promise</span>.reject(<span class="string">'出错了'</span>);</div><div class="line"><span class="comment">// 等同于</span></div><div class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> reject(<span class="string">'出错了'</span>))</div><div class="line"></div><div class="line">p.then(<span class="literal">null</span>, <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(s)</div><div class="line">&#125;);</div><div class="line"><span class="comment">// 出错了</span></div></pre></td></tr></table></figure>
<p>返回一个rejected的Promise对象。</p>
<h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h3><p>类似于<code>Array.every()</code>方法，所有参数都返回<code>resolved</code>的<code>Promise</code>对象后，<code>Promise.all()</code>才会进入<code>rejected</code>状态，否则进入<code>rejected</code>状态。<br>需要注意的几点:</p>
<ul>
<li>参数不是<code>Promise</code>对象时，会首先调用<code>Promise.resolve()</code>方法转换成<code>Promise</code>对象</li>
<li>全部参数都返回<code>resolved</code>的<code>Promise</code>对象后，这些返回的对象会组成一个数组作为<code>Promise.all()</code>的返回值</li>
<li>有一个参数返回<code>rejected</code>对象后，第一个返回的<code>rejected</code>的<code>Promise</code>对象会作为<code>Promise.al()</code>的返回值</li>
</ul>
<h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h3><p>和<code>Promise.all()</code>相对，这个方法类似于<code>Array.some()</code>方法，有一个参数的状态改变后，<code>Promise.race()</code>对象的状态就会改变。<br><code>race</code>这个方法名也很有意思，所有参数比赛，然后最先改变状态的那个参数返回的<code>Promise</code>对象就会作为<code>Promise.race()</code>的返回值。<br>这个方法比较有用的一个使用方法就是设定异步请求的最大延时。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.race([</div><div class="line">  fetch(<span class="string">'/resource-that-may-take-a-while'</span>),</div><div class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'request timeout'</span>)), <span class="number">5000</span>)</div><div class="line">  &#125;)</div><div class="line">]);</div><div class="line">p.then(<span class="function"><span class="params">response</span> =&gt;</span> <span class="built_in">console</span>.log(response));</div><div class="line">p.catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.log(error));</div></pre></td></tr></table></figure></p>
<p>上面的函数就为<code>fetch</code>方法设定了5秒的延时。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Promises are a library for asynchronous programming.&lt;br&gt;类似于jQuery里的&lt;code&gt;Deferred&lt;/code&gt;对象，Promises提供了异步编程的解决方案，一个简单的例子：&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;timeout&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;duration = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Promise&lt;/span&gt;(&lt;span class=&quot;function&quot;&gt;(&lt;span class=&quot;params&quot;&gt;resolve, reject&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        setTimeout(resolve, duration);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; p = timeout(&lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt;).then(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; timeout(&lt;span class=&quot;number&quot;&gt;2000&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;).then(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Error&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;hmm&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;).catch(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;err&lt;/span&gt; =&amp;gt;&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Promise&lt;/span&gt;.all([timeout(&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;), timeout(&lt;span class=&quot;number&quot;&gt;200&lt;/span&gt;)]);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这种调用方式比起传统的回调函数的方式看起来舒服不止一百倍。&lt;br&gt;
    
    </summary>
    
    
      <category term="温故而知新" scheme="http://yvshuo.github.io/tags/%E6%B8%A9%E6%95%85%E8%80%8C%E7%9F%A5%E6%96%B0/"/>
    
      <category term="ES6" scheme="http://yvshuo.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>Modules</title>
    <link href="http://yvshuo.github.io/2017/03/25/2017-03-25-es6-3/"/>
    <id>http://yvshuo.github.io/2017/03/25/2017-03-25-es6-3/</id>
    <published>2017-03-25T07:57:37.000Z</published>
    <updated>2017-03-25T08:48:56.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、ES6模块化-vs-CommonJS"><a href="#1、ES6模块化-vs-CommonJS" class="headerlink" title="1、ES6模块化 vs. CommonJS"></a>1、ES6模块化 vs. CommonJS</h2><p>ES6在语言层面上提供了模块化的支持，相较与<code>CommonJS</code>和<code>AMD</code>的模块化解决方案，ES6的模块化提供的是编译时的模块化支持，而<code>CommonJS</code>和<code>AMD</code>都是运行时的模块化。<br>ES6的模块方案提供的是对模块的引用，而<code>CommonJS</code>提供的则是一个拷贝。</p>
<h4 id="CommonJS方式"><a href="#CommonJS方式" class="headerlink" title="CommonJS方式"></a>CommonJS方式</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">// lib.js</span></div><div class="line"><span class="keyword">var</span> counter = <span class="number">3</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">incCounter</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  counter++;</div><div class="line">&#125;</div><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  <span class="attr">counter</span>: counter,</div><div class="line">  <span class="attr">incCounter</span>: incCounter,</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// main.js</span></div><div class="line"><span class="keyword">var</span> mod = <span class="built_in">require</span>(<span class="string">'./lib'</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(mod.counter);  <span class="comment">// 3</span></div><div class="line">mod.incCounter();</div><div class="line"><span class="built_in">console</span>.log(mod.counter); <span class="comment">// 3</span></div></pre></td></tr></table></figure>
<p><code>lib.js</code>模块加载以后，它的内部变化就影响不到输出的<code>mod.counter</code>了。这是因为<code>mod.counter</code>是一个原始类型的值，会被缓存。除非写成一个函数，才能得到内部变动后的值。<br><a id="more"></a><br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">// lib.js</span></div><div class="line"><span class="keyword">var</span> counter = <span class="number">3</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">incCounter</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  counter++;</div><div class="line">&#125;</div><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  get counter() &#123;</div><div class="line">    <span class="keyword">return</span> counter</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">incCounter</span>: incCounter,</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>这种情况下就可以得到内部变动后的值。</p>
<h4 id="ES6模块"><a href="#ES6模块" class="headerlink" title="ES6模块"></a>ES6模块</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">// lib.js</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">let</span> counter = <span class="number">3</span>;</div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">incCounter</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  counter++;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// main.js</span></div><div class="line"><span class="keyword">import</span> &#123; counter, incCounter &#125; <span class="keyword">from</span> <span class="string">'./lib'</span>;</div><div class="line"><span class="built_in">console</span>.log(counter); <span class="comment">// 3</span></div><div class="line">incCounter();</div><div class="line"><span class="built_in">console</span>.log(counter); <span class="comment">// 4</span></div></pre></td></tr></table></figure>
<p>ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。</p>
<h2 id="2、常见的ES6模块引用方式"><a href="#2、常见的ES6模块引用方式" class="headerlink" title="2、常见的ES6模块引用方式"></a>2、常见的ES6模块引用方式</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">// lib/math.js</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">x, y</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> x + y;</div><div class="line">&#125;</div><div class="line"><span class="keyword">export</span> <span class="keyword">var</span> pi = <span class="number">3.141593</span>;</div></pre></td></tr></table></figure>
<p>下面是通过<code>import * as ... from ...</code>来引用<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">// app.js</span></div><div class="line"><span class="keyword">import</span> * <span class="keyword">as</span> math <span class="keyword">from</span> <span class="string">"lib/math"</span>;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"2π = "</span> + math.sum(math.pi, math.pi));</div></pre></td></tr></table></figure></p>
<p>另一种就是类似于解构赋值的引用方式<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">// otherApp.js</span></div><div class="line"><span class="keyword">import</span> &#123;sum, pi&#125; <span class="keyword">from</span> <span class="string">"lib/math"</span>;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"2π = "</span> + sum(pi, pi));</div></pre></td></tr></table></figure></p>
<h2 id="3、export-default-和-export"><a href="#3、export-default-和-export" class="headerlink" title="3、export default 和 export *"></a>3、export default 和 export *</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">// lib/mathplusplus.js</span></div><div class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">"lib/math"</span>;</div><div class="line"><span class="keyword">export</span> <span class="keyword">var</span> e = <span class="number">2.71828182846</span>;</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.exp(x);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>两种引用方式有点区别<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">// app.js</span></div><div class="line"><span class="keyword">import</span> exp, &#123;pi, e&#125; <span class="keyword">from</span> <span class="string">"lib/mathplusplus"</span>;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"e^π = "</span> + exp(pi));</div></pre></td></tr></table></figure></p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><blockquote>
<p>1、<a href="https://babeljs.io/learn-es2015/" target="_blank" rel="external">Learn ES2015</a><br>2、<a href="http://es6.ruanyifeng.com/#docs/module-loader" target="_blank" rel="external">Module 的加载实现</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1、ES6模块化-vs-CommonJS&quot;&gt;&lt;a href=&quot;#1、ES6模块化-vs-CommonJS&quot; class=&quot;headerlink&quot; title=&quot;1、ES6模块化 vs. CommonJS&quot;&gt;&lt;/a&gt;1、ES6模块化 vs. CommonJS&lt;/h2&gt;&lt;p&gt;ES6在语言层面上提供了模块化的支持，相较与&lt;code&gt;CommonJS&lt;/code&gt;和&lt;code&gt;AMD&lt;/code&gt;的模块化解决方案，ES6的模块化提供的是编译时的模块化支持，而&lt;code&gt;CommonJS&lt;/code&gt;和&lt;code&gt;AMD&lt;/code&gt;都是运行时的模块化。&lt;br&gt;ES6的模块方案提供的是对模块的引用，而&lt;code&gt;CommonJS&lt;/code&gt;提供的则是一个拷贝。&lt;/p&gt;
&lt;h4 id=&quot;CommonJS方式&quot;&gt;&lt;a href=&quot;#CommonJS方式&quot; class=&quot;headerlink&quot; title=&quot;CommonJS方式&quot;&gt;&lt;/a&gt;CommonJS方式&lt;/h4&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// lib.js&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; counter = &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;incCounter&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  counter++;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;module&lt;/span&gt;.exports = &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;attr&quot;&gt;counter&lt;/span&gt;: counter,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;attr&quot;&gt;incCounter&lt;/span&gt;: incCounter,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// main.js&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; mod = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;./lib&#39;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(mod.counter);  &lt;span class=&quot;comment&quot;&gt;// 3&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;mod.incCounter();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(mod.counter); &lt;span class=&quot;comment&quot;&gt;// 3&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;lib.js&lt;/code&gt;模块加载以后，它的内部变化就影响不到输出的&lt;code&gt;mod.counter&lt;/code&gt;了。这是因为&lt;code&gt;mod.counter&lt;/code&gt;是一个原始类型的值，会被缓存。除非写成一个函数，才能得到内部变动后的值。&lt;br&gt;
    
    </summary>
    
    
      <category term="温故而知新" scheme="http://yvshuo.github.io/tags/%E6%B8%A9%E6%95%85%E8%80%8C%E7%9F%A5%E6%96%B0/"/>
    
      <category term="ES6" scheme="http://yvshuo.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>Default + Rest + Spread</title>
    <link href="http://yvshuo.github.io/2017/03/19/2017-03-19-es6-2/"/>
    <id>http://yvshuo.github.io/2017/03/19/2017-03-19-es6-2/</id>
    <published>2017-03-19T04:57:56.000Z</published>
    <updated>2017-03-19T05:15:42.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y=<span class="number">12</span></span>) </span>&#123;</div><div class="line">  <span class="comment">// y is 12 if not passed (or passed as undefined)</span></div><div class="line">  <span class="keyword">return</span> x + y;</div><div class="line">&#125;</div><div class="line">f(<span class="number">3</span>) == <span class="number">15</span></div></pre></td></tr></table></figure>
<p>给参数设置默认值。<br><br><br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, ...y</span>) </span>&#123;</div><div class="line">  <span class="comment">// y is an Array</span></div><div class="line">  <span class="keyword">return</span> x * y.length;</div><div class="line">&#125;</div><div class="line">f(<span class="number">3</span>, <span class="string">"hello"</span>, <span class="literal">true</span>) == <span class="number">6</span></div></pre></td></tr></table></figure></p>
<p>ES6的Rest参数，类似于java里的接收不定个数的参数。Rest参数可以替代以前的<code>arguments</code>的用法，需要注意的一点就是Rest参数只能在函数参数列表的最后一个。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">// error!</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">...x, y</span>) </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面这个例子中的Rest参数就会报错。<br><br><br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y, z</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> x + y + z;</div><div class="line">&#125;</div><div class="line"><span class="comment">// Pass each elem of array as argument</span></div><div class="line">f(...[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]) == <span class="number">6</span></div></pre></td></tr></table></figure></p>
<p>展开数组，极其好用的一个功能。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> arr1 = [<span class="string">'a'</span>, <span class="string">'b'</span>];</div><div class="line">  <span class="keyword">const</span> arr2 = [<span class="string">'c'</span>];</div><div class="line">  <span class="keyword">const</span> arr3 = [<span class="string">'d'</span>, <span class="string">'e'</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>]];</div><div class="line">  <span class="keyword">return</span> [...arr1, ...arr2, ...arr3];</div><div class="line">&#125;</div><div class="line"><span class="comment">// return [ "a", "b", "c", "d", "e", [ "a", "b" ] ]</span></div></pre></td></tr></table></figure></p>
<p>展开数组只能展开一级。</p>
<blockquote>
<p>参考文章：<a href="https://babeljs.io/learn-es2015/" target="_blank" rel="external">Learn ES2015</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;functio
    
    </summary>
    
    
      <category term="温故而知新" scheme="http://yvshuo.github.io/tags/%E6%B8%A9%E6%95%85%E8%80%8C%E7%9F%A5%E6%96%B0/"/>
    
      <category term="ES6" scheme="http://yvshuo.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>Arrows and Lexical This</title>
    <link href="http://yvshuo.github.io/2017/03/19/2017-03-19-es6-1/"/>
    <id>http://yvshuo.github.io/2017/03/19/2017-03-19-es6-1/</id>
    <published>2017-03-19T03:34:22.000Z</published>
    <updated>2017-03-19T05:15:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>Arrows are a <code>function</code> shorthand using the =&gt; syntax.<br><strong>Unlike <code>functions</code>, arrows share the same lexical <code>this</code> as their surrounding code.</strong><br><strong>If an arrow is inside another function, it shares the <code>arguments</code> variable of its parent function.</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Expression bodies</span></div><div class="line"><span class="keyword">var</span> odds = evens.map(<span class="function"><span class="params">v</span> =&gt;</span> v + <span class="number">1</span>);</div><div class="line"><span class="keyword">var</span> nums = evens.map(<span class="function">(<span class="params">v, i</span>) =&gt;</span> v + i);</div><div class="line"></div><div class="line"><span class="comment">// Statement bodies</span></div><div class="line">nums.forEach(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</div><div class="line">  <span class="keyword">if</span> (v % <span class="number">5</span> === <span class="number">0</span>)</div><div class="line">    fives.push(v);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>上面的代码一种是箭头函数的表达式形式，一种是语句的形式。表达式形式return表达式的值。语句形式可以执行语句，不带返回值，也可以带返回值，这点和<code>function</code>是一样的。<br><br></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Lexical this</span></div><div class="line"><span class="keyword">var</span> bob = &#123;</div><div class="line">  <span class="attr">_name</span>: <span class="string">"Bob"</span>,</div><div class="line">  <span class="attr">_friends</span>: [],</div><div class="line">  printFriends() &#123;</div><div class="line">    <span class="keyword">this</span>._friends.forEach(<span class="function"><span class="params">f</span> =&gt;</span> <span class="comment">// a</span></div><div class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>._name + <span class="string">" knows "</span> + f)); <span class="comment">// b</span></div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>箭头函数的<code>this</code>和它周围的代码的<code>this</code>指向同一个地方，上面代码中<code>注释a</code>这一行的<code>this</code>和<code>注释b</code>这一行的<code>this</code>就都指向<code>bob</code>变量。<br>在实际使用中，我们需要根据自己不同的需要使用<code>function</code>或者是箭头函数。<br><br></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Lexical arguments</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> example = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">let</span> numbers = [];</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> number <span class="keyword">of</span> <span class="built_in">arguments</span>) &#123;</div><div class="line">      numbers.push(number * number);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> numbers;</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> example();</div><div class="line">&#125;</div><div class="line"></div><div class="line">square(<span class="number">2</span>, <span class="number">4</span>, <span class="number">7.5</span>, <span class="number">8</span>, <span class="number">11.5</span>, <span class="number">21</span>); <span class="comment">// returns: [4, 16, 56.25, 64, 132.25, 441]</span></div></pre></td></tr></table></figure>
<p>箭头函数和它的父函数共享一个<code>arguments</code>变量。</p>
<blockquote>
<p>参考文章：<a href="https://babeljs.io/learn-es2015/" target="_blank" rel="external">Learn ES2015</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Arrows are a &lt;code&gt;function&lt;/code&gt; shorthand using the =&amp;gt; syntax.&lt;br&gt;&lt;strong&gt;Unlike &lt;code&gt;functions&lt;/code&gt;, arrows share the same lexi
    
    </summary>
    
    
      <category term="温故而知新" scheme="http://yvshuo.github.io/tags/%E6%B8%A9%E6%95%85%E8%80%8C%E7%9F%A5%E6%96%B0/"/>
    
      <category term="ES6" scheme="http://yvshuo.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>阿里巴巴java开发手册解读9-其他编程规约</title>
    <link href="http://yvshuo.github.io/2017/02/23/2017-02-23-javarule-9/"/>
    <id>http://yvshuo.github.io/2017/02/23/2017-02-23-javarule-9/</id>
    <published>2017-02-23T14:23:22.000Z</published>
    <updated>2017-03-16T14:01:02.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-【强制】在使用正则表达式时-利用好其预编译功能-可以有效加快正则匹配速度。"><a href="#1-【强制】在使用正则表达式时-利用好其预编译功能-可以有效加快正则匹配速度。" class="headerlink" title="1. 【强制】在使用正则表达式时,利用好其预编译功能,可以有效加快正则匹配速度。"></a>1. 【强制】在使用正则表达式时,利用好其预编译功能,可以有效加快正则匹配速度。</h3><p>说明:不要在方法体内定义:<code>Pattern pattern = Pattern.compile(规则);</code></p>
<h3 id="2-【强制】velocity-调用-POJO-类的属性时-建议直接使用属性名取值即可-模板引擎会自动按规范调用-POJO-的-getXxx-如果是-boolean-基本数据类型变量-boolean-命名不需要加-is-前缀-会自动调用-isXxx-方法。"><a href="#2-【强制】velocity-调用-POJO-类的属性时-建议直接使用属性名取值即可-模板引擎会自动按规范调用-POJO-的-getXxx-如果是-boolean-基本数据类型变量-boolean-命名不需要加-is-前缀-会自动调用-isXxx-方法。" class="headerlink" title="2. 【强制】velocity 调用 POJO 类的属性时,建议直接使用属性名取值即可,模板引擎会自动按规范调用 POJO 的 getXxx(),如果是 boolean 基本数据类型变量(boolean 命名不需要加 is 前缀),会自动调用 isXxx()方法。"></a>2. 【强制】velocity 调用 POJO 类的属性时,建议直接使用属性名取值即可,模板引擎会自动按规范调用 POJO 的 getXxx(),如果是 boolean 基本数据类型变量(boolean 命名不需要加 is 前缀),会自动调用 isXxx()方法。</h3><p>说明:注意如果是 Boolean 包装类对象,优先调用 getXxx()的方法。</p>
<h3 id="3-【强制】后台输送给页面的变量必须加-var-——中间的感叹号。"><a href="#3-【强制】后台输送给页面的变量必须加-var-——中间的感叹号。" class="headerlink" title="3. 【强制】后台输送给页面的变量必须加$!{var}——中间的感叹号。"></a>3. 【强制】后台输送给页面的变量必须加$!{var}——中间的感叹号。</h3><p>说明:如果 var=null 或者不存在,那么${var}会直接显示在页面上。</p>
<h3 id="4-【强制】注意-Math-random-这个方法返回是-double-类型-注意取值的范围-0≤x-lt-1-能够取到零值-注意除零异常-如果想获取整数类型的随机数-不要将-x-放大-10-的若干倍然后取整-直接使用-Random-对象的-nextInt-或者-nextLong-方法。"><a href="#4-【强制】注意-Math-random-这个方法返回是-double-类型-注意取值的范围-0≤x-lt-1-能够取到零值-注意除零异常-如果想获取整数类型的随机数-不要将-x-放大-10-的若干倍然后取整-直接使用-Random-对象的-nextInt-或者-nextLong-方法。" class="headerlink" title="4. 【强制】注意 Math.random() 这个方法返回是 double 类型,注意取值的范围 0≤x&lt;1(能够取到零值,注意除零异常),如果想获取整数类型的随机数,不要将 x 放大 10 的若干倍然后取整,直接使用 Random 对象的 nextInt 或者 nextLong 方法。"></a>4. 【强制】注意 Math.random() 这个方法返回是 double 类型,注意取值的范围 0≤x&lt;1(能够取到零值,注意除零异常),如果想获取整数类型的随机数,不要将 x 放大 10 的若干倍然后取整,直接使用 Random 对象的 nextInt 或者 nextLong 方法。</h3><h3 id="5-【强制】获取当前毫秒数-System-currentTimeMillis-而不是-new-Date-getTime"><a href="#5-【强制】获取当前毫秒数-System-currentTimeMillis-而不是-new-Date-getTime" class="headerlink" title="5. 【强制】获取当前毫秒数 System.currentTimeMillis(); 而不是 new Date().getTime();"></a>5. 【强制】获取当前毫秒数 System.currentTimeMillis(); 而不是 new Date().getTime();</h3><p>说明:如果想获取更加精确的纳秒级时间值,用 System.nanoTime()。在 JDK8 中,针对统计 时间等场景,推荐使用 Instant 类。</p>
<h3 id="6-【推荐】尽量不要在-vm-中加入变量声明、逻辑运算符-更不要在-vm-模板中加入任何复杂的逻辑。"><a href="#6-【推荐】尽量不要在-vm-中加入变量声明、逻辑运算符-更不要在-vm-模板中加入任何复杂的逻辑。" class="headerlink" title="6. 【推荐】尽量不要在 vm 中加入变量声明、逻辑运算符,更不要在 vm 模板中加入任何复杂的逻辑。"></a>6. 【推荐】尽量不要在 vm 中加入变量声明、逻辑运算符,更不要在 vm 模板中加入任何复杂的逻辑。</h3><h3 id="7-【推荐】任何数据结构的构造或初始化-都应指定大小-避免数据结构无限增长吃光内存。"><a href="#7-【推荐】任何数据结构的构造或初始化-都应指定大小-避免数据结构无限增长吃光内存。" class="headerlink" title="7. 【推荐】任何数据结构的构造或初始化,都应指定大小,避免数据结构无限增长吃光内存。"></a>7. 【推荐】任何数据结构的构造或初始化,都应指定大小,避免数据结构无限增长吃光内存。</h3><h3 id="8-【推荐】对于“明确停止使用的代码和配置”-如方法、变量、类、配置文件、动态配置属性等要坚决从程序中清理出去-避免造成过多垃圾。"><a href="#8-【推荐】对于“明确停止使用的代码和配置”-如方法、变量、类、配置文件、动态配置属性等要坚决从程序中清理出去-避免造成过多垃圾。" class="headerlink" title="8. 【推荐】对于“明确停止使用的代码和配置”,如方法、变量、类、配置文件、动态配置属性等要坚决从程序中清理出去,避免造成过多垃圾。"></a>8. 【推荐】对于“明确停止使用的代码和配置”,如方法、变量、类、配置文件、动态配置属性等要坚决从程序中清理出去,避免造成过多垃圾。</h3><blockquote>
<p><strong>后记：</strong><br>仔细的读了这个java手册好几遍，对于规范java编程确实有很好的指导意义。作为一名只是略懂java的前端狗，还有很多地方不懂。除了编程规约外的其他几个规约待后续学习后再填坑。这个系列解读也会随着自己java学习的不断深入持续更新。干巴得</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-【强制】在使用正则表达式时-利用好其预编译功能-可以有效加快正则匹配速度。&quot;&gt;&lt;a href=&quot;#1-【强制】在使用正则表达式时-利用好其预编译功能-可以有效加快正则匹配速度。&quot; class=&quot;headerlink&quot; title=&quot;1. 【强制】在使用正则表达
    
    </summary>
    
    
      <category term="java" scheme="http://yvshuo.github.io/tags/java/"/>
    
      <category term="java文档" scheme="http://yvshuo.github.io/tags/java%E6%96%87%E6%A1%A3/"/>
    
  </entry>
  
  <entry>
    <title>阿里巴巴java开发手册解读8-注释规约</title>
    <link href="http://yvshuo.github.io/2017/02/23/2017-02-23-javarule-8/"/>
    <id>http://yvshuo.github.io/2017/02/23/2017-02-23-javarule-8/</id>
    <published>2017-02-23T13:13:50.000Z</published>
    <updated>2017-03-16T13:52:15.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-【强制】类、类属性、类方法的注释必须使用-Javadoc-规范-使用-内容-格式-不得使用-xxx-方式。"><a href="#1-【强制】类、类属性、类方法的注释必须使用-Javadoc-规范-使用-内容-格式-不得使用-xxx-方式。" class="headerlink" title="1. 【强制】类、类属性、类方法的注释必须使用 Javadoc 规范,使用/*内容/格式,不得使用 //xxx 方式。"></a>1. 【强制】类、类属性、类方法的注释必须使用 Javadoc 规范,使用/<em>*内容</em>/格式,不得使用 //xxx 方式。</h3><p>说明:在 IDE 编辑窗口中,Javadoc 方式会提示相关注释,生成 Javadoc 可以正确输出相应注释;<br>在 IDE 中,工程调用方法时,不进入方法即可悬浮提示方法、参数、返回值的意义,提高阅读效率。</p>
<h3 id="2-【强制】所有的抽象方法-包括接口中的方法-必须要用-Javadoc-注释、除了返回值、参数、异常说明外-还必须指出该方法做什么事情-实现什么功能。"><a href="#2-【强制】所有的抽象方法-包括接口中的方法-必须要用-Javadoc-注释、除了返回值、参数、异常说明外-还必须指出该方法做什么事情-实现什么功能。" class="headerlink" title="2. 【强制】所有的抽象方法(包括接口中的方法)必须要用 Javadoc 注释、除了返回值、参数、异常说明外,还必须指出该方法做什么事情,实现什么功能。"></a>2. 【强制】所有的抽象方法(包括接口中的方法)必须要用 Javadoc 注释、除了返回值、参数、异常说明外,还必须指出该方法做什么事情,实现什么功能。</h3><p>说明:对子类的实现要求,或者调用注意事项,请一并说明。</p>
<h3 id="3-【强制】所有的类都必须添加创建者信息。"><a href="#3-【强制】所有的类都必须添加创建者信息。" class="headerlink" title="3. 【强制】所有的类都必须添加创建者信息。"></a>3. 【强制】所有的类都必须添加创建者信息。</h3><h3 id="4-【强制】方法内部单行注释-在被注释语句上方另起一行-使用-注释。方法内部多行注释使用-注释-注意与代码对齐。"><a href="#4-【强制】方法内部单行注释-在被注释语句上方另起一行-使用-注释。方法内部多行注释使用-注释-注意与代码对齐。" class="headerlink" title="4. 【强制】方法内部单行注释,在被注释语句上方另起一行,使用//注释。方法内部多行注释使用/ /注释,注意与代码对齐。"></a>4. 【强制】方法内部单行注释,在被注释语句上方另起一行,使用//注释。方法内部多行注释使用/<em> </em>/注释,注意与代码对齐。</h3><h3 id="5-【强制】所有的枚举类型字段必须要有注释-说明每个数据项的用途。"><a href="#5-【强制】所有的枚举类型字段必须要有注释-说明每个数据项的用途。" class="headerlink" title="5. 【强制】所有的枚举类型字段必须要有注释,说明每个数据项的用途。"></a>5. 【强制】所有的枚举类型字段必须要有注释,说明每个数据项的用途。</h3><h3 id="6-【推荐】与其“半吊子”英文来注释-不如用中文注释把问题说清楚。专有名词与关键字保持英文原文即可。"><a href="#6-【推荐】与其“半吊子”英文来注释-不如用中文注释把问题说清楚。专有名词与关键字保持英文原文即可。" class="headerlink" title="6. 【推荐】与其“半吊子”英文来注释,不如用中文注释把问题说清楚。专有名词与关键字保持英文原文即可。"></a>6. 【推荐】与其“半吊子”英文来注释,不如用中文注释把问题说清楚。专有名词与关键字保持英文原文即可。</h3><p><code>反例</code>:“TCP 连接超时”解释成“传输控制协议连接超时”,理解反而费脑筋。<br><a id="more"></a></p>
<h3 id="7-【推荐】代码修改的同时-注释也要进行相应的修改-尤其是参数、返回值、异常、核心逻辑-等的修改。"><a href="#7-【推荐】代码修改的同时-注释也要进行相应的修改-尤其是参数、返回值、异常、核心逻辑-等的修改。" class="headerlink" title="7. 【推荐】代码修改的同时,注释也要进行相应的修改,尤其是参数、返回值、异常、核心逻辑 等的修改。"></a>7. 【推荐】代码修改的同时,注释也要进行相应的修改,尤其是参数、返回值、异常、核心逻辑 等的修改。</h3><p>说明:代码与注释更新不同步,就像路网与导航软件更新不同步一样,如果导航软件严重滞后, 就失去了导航的意义。</p>
<h3 id="8-【参考】注释掉的代码尽量要配合说明-而不是简单的注释掉。"><a href="#8-【参考】注释掉的代码尽量要配合说明-而不是简单的注释掉。" class="headerlink" title="8. 【参考】注释掉的代码尽量要配合说明,而不是简单的注释掉。"></a>8. 【参考】注释掉的代码尽量要配合说明,而不是简单的注释掉。</h3><p>说明:代码被注释掉有两种可能性:<br><strong>1)后续会恢复此段代码逻辑。</strong><br><strong>2)永久不用。</strong><br>前者如果没有备注信息,难以知晓注释动机。后者建议直接删掉(代码仓库保存了历史代码)。</p>
<h3 id="9-【参考】对于注释的要求"><a href="#9-【参考】对于注释的要求" class="headerlink" title="9. 【参考】对于注释的要求:"></a>9. 【参考】对于注释的要求:</h3><p><strong>1)能够准确反应设计思想和代码逻辑;</strong><br><strong>2)能够描述业务含义,使别的程序员能够迅速了解到代码背后的信息。完全没有注释的大段代码对于阅读者形同天书,注释是给自己看的,即使隔很长时间,也能清晰理解当时的思路;注释也是给继任者看的,使其能够快速接替自己的工作。</strong></p>
<h3 id="10-【参考】好的命名、代码结构是自解释的-注释力求精简准确、表达到位。"><a href="#10-【参考】好的命名、代码结构是自解释的-注释力求精简准确、表达到位。" class="headerlink" title="10. 【参考】好的命名、代码结构是自解释的,注释力求精简准确、表达到位。"></a>10. 【参考】好的命名、代码结构是自解释的,注释力求精简准确、表达到位。</h3><p>避免出现注释的一个极端:过多过滥的注释,代码的逻辑一旦修改,修改注释是相当大的负担。<br><code>反例</code>:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// put elephant into fridge</span></div><div class="line">put(elephant, fridge);</div></pre></td></tr></table></figure></p>
<p>方法名 put,加上两个有意义的变量名 elephant 和 fridge,已经说明了这是在干什么,语义清晰的代码不需要额外的注释。</p>
<h3 id="11-【参考】特殊注释标记-请注明标记人与标记时间。"><a href="#11-【参考】特殊注释标记-请注明标记人与标记时间。" class="headerlink" title="11. 【参考】特殊注释标记,请注明标记人与标记时间。"></a>11. 【参考】特殊注释标记,请注明标记人与标记时间。</h3><p>注意及时处理这些标记,通过标记扫描, 经常清理此类标记。线上故障有时候就是来源于这些标记处的代码。<br><strong>1) 待办事宜(TODO):( 标记人,标记时间,[预计处理时间]) 表示需要实现,但目前还未实现的功能。这实际上是一个 Javadoc 的标签,目前的 Javadoc 还没有实现,但已经被广泛使用。只能应用于类,接口和方法(因为它是一个 Javadoc 标签)。</strong><br><strong>2) 错误,不能工作(FIXME):(标记人,标记时间,[预计处理时间])在注释中用 FIXME 标记某代码是错误的,而且不能工作,需要及时纠正的情况。</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-【强制】类、类属性、类方法的注释必须使用-Javadoc-规范-使用-内容-格式-不得使用-xxx-方式。&quot;&gt;&lt;a href=&quot;#1-【强制】类、类属性、类方法的注释必须使用-Javadoc-规范-使用-内容-格式-不得使用-xxx-方式。&quot; class=&quot;headerlink&quot; title=&quot;1. 【强制】类、类属性、类方法的注释必须使用 Javadoc 规范,使用/*内容/格式,不得使用 //xxx 方式。&quot;&gt;&lt;/a&gt;1. 【强制】类、类属性、类方法的注释必须使用 Javadoc 规范,使用/&lt;em&gt;*内容&lt;/em&gt;/格式,不得使用 //xxx 方式。&lt;/h3&gt;&lt;p&gt;说明:在 IDE 编辑窗口中,Javadoc 方式会提示相关注释,生成 Javadoc 可以正确输出相应注释;&lt;br&gt;在 IDE 中,工程调用方法时,不进入方法即可悬浮提示方法、参数、返回值的意义,提高阅读效率。&lt;/p&gt;
&lt;h3 id=&quot;2-【强制】所有的抽象方法-包括接口中的方法-必须要用-Javadoc-注释、除了返回值、参数、异常说明外-还必须指出该方法做什么事情-实现什么功能。&quot;&gt;&lt;a href=&quot;#2-【强制】所有的抽象方法-包括接口中的方法-必须要用-Javadoc-注释、除了返回值、参数、异常说明外-还必须指出该方法做什么事情-实现什么功能。&quot; class=&quot;headerlink&quot; title=&quot;2. 【强制】所有的抽象方法(包括接口中的方法)必须要用 Javadoc 注释、除了返回值、参数、异常说明外,还必须指出该方法做什么事情,实现什么功能。&quot;&gt;&lt;/a&gt;2. 【强制】所有的抽象方法(包括接口中的方法)必须要用 Javadoc 注释、除了返回值、参数、异常说明外,还必须指出该方法做什么事情,实现什么功能。&lt;/h3&gt;&lt;p&gt;说明:对子类的实现要求,或者调用注意事项,请一并说明。&lt;/p&gt;
&lt;h3 id=&quot;3-【强制】所有的类都必须添加创建者信息。&quot;&gt;&lt;a href=&quot;#3-【强制】所有的类都必须添加创建者信息。&quot; class=&quot;headerlink&quot; title=&quot;3. 【强制】所有的类都必须添加创建者信息。&quot;&gt;&lt;/a&gt;3. 【强制】所有的类都必须添加创建者信息。&lt;/h3&gt;&lt;h3 id=&quot;4-【强制】方法内部单行注释-在被注释语句上方另起一行-使用-注释。方法内部多行注释使用-注释-注意与代码对齐。&quot;&gt;&lt;a href=&quot;#4-【强制】方法内部单行注释-在被注释语句上方另起一行-使用-注释。方法内部多行注释使用-注释-注意与代码对齐。&quot; class=&quot;headerlink&quot; title=&quot;4. 【强制】方法内部单行注释,在被注释语句上方另起一行,使用//注释。方法内部多行注释使用/ /注释,注意与代码对齐。&quot;&gt;&lt;/a&gt;4. 【强制】方法内部单行注释,在被注释语句上方另起一行,使用//注释。方法内部多行注释使用/&lt;em&gt; &lt;/em&gt;/注释,注意与代码对齐。&lt;/h3&gt;&lt;h3 id=&quot;5-【强制】所有的枚举类型字段必须要有注释-说明每个数据项的用途。&quot;&gt;&lt;a href=&quot;#5-【强制】所有的枚举类型字段必须要有注释-说明每个数据项的用途。&quot; class=&quot;headerlink&quot; title=&quot;5. 【强制】所有的枚举类型字段必须要有注释,说明每个数据项的用途。&quot;&gt;&lt;/a&gt;5. 【强制】所有的枚举类型字段必须要有注释,说明每个数据项的用途。&lt;/h3&gt;&lt;h3 id=&quot;6-【推荐】与其“半吊子”英文来注释-不如用中文注释把问题说清楚。专有名词与关键字保持英文原文即可。&quot;&gt;&lt;a href=&quot;#6-【推荐】与其“半吊子”英文来注释-不如用中文注释把问题说清楚。专有名词与关键字保持英文原文即可。&quot; class=&quot;headerlink&quot; title=&quot;6. 【推荐】与其“半吊子”英文来注释,不如用中文注释把问题说清楚。专有名词与关键字保持英文原文即可。&quot;&gt;&lt;/a&gt;6. 【推荐】与其“半吊子”英文来注释,不如用中文注释把问题说清楚。专有名词与关键字保持英文原文即可。&lt;/h3&gt;&lt;p&gt;&lt;code&gt;反例&lt;/code&gt;:“TCP 连接超时”解释成“传输控制协议连接超时”,理解反而费脑筋。&lt;br&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://yvshuo.github.io/tags/java/"/>
    
      <category term="java文档" scheme="http://yvshuo.github.io/tags/java%E6%96%87%E6%A1%A3/"/>
    
  </entry>
  
  <entry>
    <title>阿里巴巴java开发手册解读7-控制语句</title>
    <link href="http://yvshuo.github.io/2017/02/22/2017-02-22-javarule-7/"/>
    <id>http://yvshuo.github.io/2017/02/22/2017-02-22-javarule-7/</id>
    <published>2017-02-22T11:53:20.000Z</published>
    <updated>2017-03-16T13:42:44.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-【强制】在一个-switch-块内-每个-case-要么通过-break-return-等来终止-要么注释说明程序将继续执行到哪一个-case-为止"><a href="#1-【强制】在一个-switch-块内-每个-case-要么通过-break-return-等来终止-要么注释说明程序将继续执行到哪一个-case-为止" class="headerlink" title="1. 【强制】在一个 switch 块内,每个 case 要么通过 break/return 等来终止,要么注释说明程序将继续执行到哪一个 case 为止;"></a>1. 【强制】在一个 switch 块内,每个 case 要么通过 break/return 等来终止,要么注释说明程序将继续执行到哪一个 case 为止;</h3><p>在一个 switch 块内,都必须包含一个 default 语句并且放在最后,即使它什么代码也没有。</p>
<h3 id="2-【强制】在-if-else-for-while-do-语句中必须使用大括号-即使只有一行代码-避免使用下面的形式"><a href="#2-【强制】在-if-else-for-while-do-语句中必须使用大括号-即使只有一行代码-避免使用下面的形式" class="headerlink" title="2. 【强制】在 if/else/for/while/do 语句中必须使用大括号,即使只有一行代码,避免使用下面的形式:"></a>2. 【强制】在 if/else/for/while/do 语句中必须使用大括号,即使只有一行代码,避免使用下面的形式:</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">if</span> (condition) statements;</div></pre></td></tr></table></figure>
<h3 id="3-【推荐】推荐尽量少用-else"><a href="#3-【推荐】推荐尽量少用-else" class="headerlink" title="3. 【推荐】推荐尽量少用 else"></a>3. 【推荐】推荐尽量少用 else</h3><p>if-else 的方式可以改写成:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">if</span>(condition)&#123;</div><div class="line">    ...</div><div class="line">    <span class="keyword">return</span> obj; </div><div class="line">&#125;</div><div class="line"><span class="comment">// 接着写 else 的业务逻辑代码;</span></div></pre></td></tr></table></figure></p>
<p>说明:如果非得使用if()…else if()…else…方式表达逻辑,【强制】请勿超过3层,超过请使用状态设计模式。<br><code>正例</code>:逻辑上超过 3 层的 if-else 代码可以使用卫语句,或者状态模式来实现。<br><a id="more"></a></p>
<h3 id="4-【推荐】除常用方法-如-getXxx-isXxx-等外-不要在条件判断中执行其它复杂的语句-将复杂逻辑判断的结果赋值给一个有意义的布尔变量名-以提高可读性。"><a href="#4-【推荐】除常用方法-如-getXxx-isXxx-等外-不要在条件判断中执行其它复杂的语句-将复杂逻辑判断的结果赋值给一个有意义的布尔变量名-以提高可读性。" class="headerlink" title="4. 【推荐】除常用方法(如 getXxx/isXxx)等外,不要在条件判断中执行其它复杂的语句,将复杂逻辑判断的结果赋值给一个有意义的布尔变量名,以提高可读性。"></a>4. 【推荐】除常用方法(如 getXxx/isXxx)等外,不要在条件判断中执行其它复杂的语句,将复杂逻辑判断的结果赋值给一个有意义的布尔变量名,以提高可读性。</h3><p>说明:很多 if 语句内的逻辑相当复杂,阅读者需要分析条件表达式的最终结果,才能明确什么样的条件执行什么样的语句,那么,如果阅读者分析逻辑表达式错误呢?<br><code>正例</code>:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//伪代码如下</span></div><div class="line"><span class="keyword">boolean</span> existed = (file.open(fileName, <span class="string">"w"</span>) != <span class="keyword">null</span>) &amp;&amp; (...) || (...); </div><div class="line"><span class="keyword">if</span> (existed) &#123;</div><div class="line">    ... </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>反例</code>:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">if</span> ((file.open(fileName, <span class="string">"w"</span>) != <span class="keyword">null</span>) &amp;&amp; (...) || (...)) &#123; </div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="5-【推荐】循环体中的语句要考量性能"><a href="#5-【推荐】循环体中的语句要考量性能" class="headerlink" title="5. 【推荐】循环体中的语句要考量性能"></a>5. 【推荐】循环体中的语句要考量性能</h3><p>以下操作尽量移至循环体外处理,如定义对象、变量、获取数据库连接,进行不必要的 try-catch 操作(这个 try-catch 是否可以移至循环体外)。</p>
<h3 id="6-【推荐】接口入参保护-这种场景常见的是用于做批量操作的接口。"><a href="#6-【推荐】接口入参保护-这种场景常见的是用于做批量操作的接口。" class="headerlink" title="6. 【推荐】接口入参保护,这种场景常见的是用于做批量操作的接口。"></a>6. 【推荐】接口入参保护,这种场景常见的是用于做批量操作的接口。</h3><h3 id="7-【参考】方法中需要进行参数校验的场景"><a href="#7-【参考】方法中需要进行参数校验的场景" class="headerlink" title="7. 【参考】方法中需要进行参数校验的场景:"></a>7. 【参考】方法中需要进行参数校验的场景:</h3><p><strong>1) 调用频次低的方法。</strong><br><strong>2) 执行时间开销很大的方法,参数校验时间几乎可以忽略不计,但如果因为参数错误导致中间执行回退,或者错误,那得不偿失。</strong><br><strong>3) 需要极高稳定性和可用性的方法。</strong><br><strong>4) 对外提供的开放接口,不管是RPC/API/HTTP接口。</strong><br><strong>5) 敏感权限入口。</strong></p>
<h3 id="8-【参考】方法中不需要参数校验的场景"><a href="#8-【参考】方法中不需要参数校验的场景" class="headerlink" title="8. 【参考】方法中不需要参数校验的场景:"></a>8. 【参考】方法中不需要参数校验的场景:</h3><p><strong>1) 极有可能被循环调用的方法,不建议对参数进行校验。但在方法说明里必须注明外部参数检查。</strong><br><strong>2) 底层的方法调用频度都比较高,一般不校验。毕竟是像纯净水过滤的最后一道,参数错误不太可能到底层才会暴露问题。一般 DAO 层与 Service 层都在同一个应用中,部署在同一台服务器中,所以 DAO 的参数校验,可以省略。</strong><br><strong>3) 被声明成private只会被自己代码所调用的方法,如果能够确定调用方法的代码传入参数已经做过检查或者肯定不会有问题,此时可以不校验参数。</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-【强制】在一个-switch-块内-每个-case-要么通过-break-return-等来终止-要么注释说明程序将继续执行到哪一个-case-为止&quot;&gt;&lt;a href=&quot;#1-【强制】在一个-switch-块内-每个-case-要么通过-break-return-等来终止-要么注释说明程序将继续执行到哪一个-case-为止&quot; class=&quot;headerlink&quot; title=&quot;1. 【强制】在一个 switch 块内,每个 case 要么通过 break/return 等来终止,要么注释说明程序将继续执行到哪一个 case 为止;&quot;&gt;&lt;/a&gt;1. 【强制】在一个 switch 块内,每个 case 要么通过 break/return 等来终止,要么注释说明程序将继续执行到哪一个 case 为止;&lt;/h3&gt;&lt;p&gt;在一个 switch 块内,都必须包含一个 default 语句并且放在最后,即使它什么代码也没有。&lt;/p&gt;
&lt;h3 id=&quot;2-【强制】在-if-else-for-while-do-语句中必须使用大括号-即使只有一行代码-避免使用下面的形式&quot;&gt;&lt;a href=&quot;#2-【强制】在-if-else-for-while-do-语句中必须使用大括号-即使只有一行代码-避免使用下面的形式&quot; class=&quot;headerlink&quot; title=&quot;2. 【强制】在 if/else/for/while/do 语句中必须使用大括号,即使只有一行代码,避免使用下面的形式:&quot;&gt;&lt;/a&gt;2. 【强制】在 if/else/for/while/do 语句中必须使用大括号,即使只有一行代码,避免使用下面的形式:&lt;/h3&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (condition) statements;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;3-【推荐】推荐尽量少用-else&quot;&gt;&lt;a href=&quot;#3-【推荐】推荐尽量少用-else&quot; class=&quot;headerlink&quot; title=&quot;3. 【推荐】推荐尽量少用 else&quot;&gt;&lt;/a&gt;3. 【推荐】推荐尽量少用 else&lt;/h3&gt;&lt;p&gt;if-else 的方式可以改写成:&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(condition)&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    ...&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; obj; &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 接着写 else 的业务逻辑代码;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;说明:如果非得使用if()…else if()…else…方式表达逻辑,【强制】请勿超过3层,超过请使用状态设计模式。&lt;br&gt;&lt;code&gt;正例&lt;/code&gt;:逻辑上超过 3 层的 if-else 代码可以使用卫语句,或者状态模式来实现。&lt;br&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://yvshuo.github.io/tags/java/"/>
    
      <category term="java文档" scheme="http://yvshuo.github.io/tags/java%E6%96%87%E6%A1%A3/"/>
    
  </entry>
  
  <entry>
    <title>阿里巴巴java开发手册解读6-并发处理</title>
    <link href="http://yvshuo.github.io/2017/02/18/2017-02-18-javarule-6/"/>
    <id>http://yvshuo.github.io/2017/02/18/2017-02-18-javarule-6/</id>
    <published>2017-02-18T08:33:10.000Z</published>
    <updated>2017-03-16T13:33:31.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-【强制】获取单例对象需要保证线程安全-其中的方法也要保证线程安全。"><a href="#1-【强制】获取单例对象需要保证线程安全-其中的方法也要保证线程安全。" class="headerlink" title="1. 【强制】获取单例对象需要保证线程安全,其中的方法也要保证线程安全。"></a>1. 【强制】获取单例对象需要保证线程安全,其中的方法也要保证线程安全。</h3><p>说明:资源驱动类、工具类、单例工厂类都需要注意。</p>
<h3 id="2-【强制】创建线程或线程池时请指定有意义的线程名称-方便出错时回溯。"><a href="#2-【强制】创建线程或线程池时请指定有意义的线程名称-方便出错时回溯。" class="headerlink" title="2. 【强制】创建线程或线程池时请指定有意义的线程名称,方便出错时回溯。"></a>2. 【强制】创建线程或线程池时请指定有意义的线程名称,方便出错时回溯。</h3><p><code>正例</code>:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimerTaskThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TimerTaskThread</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">super</span>.setName(<span class="string">"TimerTaskThread"</span>); </div><div class="line">    ... </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<h3 id="3-【强制】线程资源必须通过线程池提供-不允许在应用中自行显式创建线程。"><a href="#3-【强制】线程资源必须通过线程池提供-不允许在应用中自行显式创建线程。" class="headerlink" title="3. 【强制】线程资源必须通过线程池提供,不允许在应用中自行显式创建线程。"></a>3. 【强制】线程资源必须通过线程池提供,不允许在应用中自行显式创建线程。</h3><p>说明:使用线程池的好处是减少在创建和销毁线程上所花的时间以及系统资源的开销,解决资源不足的问题。如果不使用线程池,有可能造成系统创建大量同类线程而导致消耗完内存或者 “过度切换”的问题。</p>
<h3 id="4-【强制】线程池不允许使用-Executors-去创建-而是通过-ThreadPoolExecutor-的方式-这样-的处理方式让写的同学更加明确线程池的运行规则-规避资源耗尽的风险。"><a href="#4-【强制】线程池不允许使用-Executors-去创建-而是通过-ThreadPoolExecutor-的方式-这样-的处理方式让写的同学更加明确线程池的运行规则-规避资源耗尽的风险。" class="headerlink" title="4. 【强制】线程池不允许使用 Executors 去创建,而是通过 ThreadPoolExecutor 的方式,这样 的处理方式让写的同学更加明确线程池的运行规则,规避资源耗尽的风险。"></a>4. 【强制】线程池不允许使用 Executors 去创建,而是通过 ThreadPoolExecutor 的方式,这样 的处理方式让写的同学更加明确线程池的运行规则,规避资源耗尽的风险。</h3><p>说明:Executors 返回的线程池对象的弊端如下:<br><strong>1)FixedThreadPool 和 SingleThreadPool:</strong><br>允许的请求队列长度为 Integer.MAX_VALUE,可能会堆积大量的请求,从而导致 OOM。<br><strong>2)CachedThreadPool 和 ScheduledThreadPool:</strong><br>允许的创建线程数量为 Integer.MAX_VALUE,可能会创建大量的线程,从而导致 OOM。</p>
<h3 id="5-【强制】SimpleDateFormat-是线程不安全的类-一般不要定义为static变量-如果定义为static-必须加锁-或者使用-DateUtils-工具类。"><a href="#5-【强制】SimpleDateFormat-是线程不安全的类-一般不要定义为static变量-如果定义为static-必须加锁-或者使用-DateUtils-工具类。" class="headerlink" title="5.【强制】SimpleDateFormat 是线程不安全的类,一般不要定义为static变量,如果定义为static,必须加锁,或者使用 DateUtils 工具类。"></a>5.【强制】SimpleDateFormat 是线程不安全的类,一般不要定义为static变量,如果定义为static,必须加锁,或者使用 DateUtils 工具类。</h3><p><code>正例</code>:注意线程安全,使用 DateUtils。<br>亦推荐如下处理:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;DateFormat&gt; df = <span class="keyword">new</span> ThreadLocal&lt;DateFormat&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> DateFormat <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>说明:如果是 JDK8 的应用,可以使用 Instant 代替 Date,LocalDateTime 代替 Calendar, DateTimeFormatter 代替 Simpledateformatter,官方给出的解释:simple beautiful strong immutable thread-safe。</p>
<h3 id="6-【强制】高并发时-同步调用应该去考量锁的性能损耗。"><a href="#6-【强制】高并发时-同步调用应该去考量锁的性能损耗。" class="headerlink" title="6. 【强制】高并发时,同步调用应该去考量锁的性能损耗。"></a>6. 【强制】高并发时,同步调用应该去考量锁的性能损耗。</h3><p>能用无锁数据结构,就不要用锁;<br>能锁区块,就不要锁整个方法体;<br>能用对象锁,就不要用类锁。</p>
<h3 id="7-【强制】对多个资源、数据库表、对象同时加锁时-需要保持一致的加锁顺序-否则可能会造成死锁。"><a href="#7-【强制】对多个资源、数据库表、对象同时加锁时-需要保持一致的加锁顺序-否则可能会造成死锁。" class="headerlink" title="7. 【强制】对多个资源、数据库表、对象同时加锁时,需要保持一致的加锁顺序,否则可能会造成死锁。"></a>7. 【强制】对多个资源、数据库表、对象同时加锁时,需要保持一致的加锁顺序,否则可能会造成死锁。</h3><p>说明:线程一需要对表 A、B、C 依次全部加锁后才可以进行更新操作,那么线程二的加锁顺序也必须是 A、B、C,否则可能出现死锁。</p>
<h3 id="8-【强制】并发修改同一记录时-避免更新丢失-要么在应用层加锁-要么在缓存加锁-要么在数据库层使用乐观锁-使用-version-作为更新依据。"><a href="#8-【强制】并发修改同一记录时-避免更新丢失-要么在应用层加锁-要么在缓存加锁-要么在数据库层使用乐观锁-使用-version-作为更新依据。" class="headerlink" title="8. 【强制】并发修改同一记录时,避免更新丢失,要么在应用层加锁,要么在缓存加锁,要么在数据库层使用乐观锁,使用 version 作为更新依据。"></a>8. 【强制】并发修改同一记录时,避免更新丢失,要么在应用层加锁,要么在缓存加锁,要么在数据库层使用乐观锁,使用 version 作为更新依据。</h3><p>说明:如果每次访问冲突概率小于 20%,推荐使用乐观锁,否则使用悲观锁。乐观锁的重试次数不得小于 3 次。</p>
<h3 id="9-【强制】多线程并行处理定时任务时-Timer-运行多个-TimeTask-时-只要其中之一没有捕获抛出的异常-其它任务便会自动终止运行-使用-ScheduledExecutorService-则没有这个问题。"><a href="#9-【强制】多线程并行处理定时任务时-Timer-运行多个-TimeTask-时-只要其中之一没有捕获抛出的异常-其它任务便会自动终止运行-使用-ScheduledExecutorService-则没有这个问题。" class="headerlink" title="9. 【强制】多线程并行处理定时任务时,Timer 运行多个 TimeTask 时,只要其中之一没有捕获抛出的异常,其它任务便会自动终止运行,使用 ScheduledExecutorService 则没有这个问题。"></a>9. 【强制】多线程并行处理定时任务时,Timer 运行多个 TimeTask 时,只要其中之一没有捕获抛出的异常,其它任务便会自动终止运行,使用 ScheduledExecutorService 则没有这个问题。</h3><h3 id="10-【推荐】使用-CountDownLatch-进行异步转同步操作-每个线程退出前必须调用-countDown方法-线程执行代码注意-catch-异常-确保-countDown-方法可以执行-避免主线程无法执行-至-countDown-方法-直到超时才返回结果。-说明-注意-子线程抛出异常堆栈-不能在主线程-try-catch-到。"><a href="#10-【推荐】使用-CountDownLatch-进行异步转同步操作-每个线程退出前必须调用-countDown方法-线程执行代码注意-catch-异常-确保-countDown-方法可以执行-避免主线程无法执行-至-countDown-方法-直到超时才返回结果。-说明-注意-子线程抛出异常堆栈-不能在主线程-try-catch-到。" class="headerlink" title="10. 【推荐】使用 CountDownLatch 进行异步转同步操作,每个线程退出前必须调用 countDown方法,线程执行代码注意 catch 异常,确保 countDown 方法可以执行,避免主线程无法执行 至 countDown 方法,直到超时才返回结果。 说明:注意,子线程抛出异常堆栈,不能在主线程 try-catch 到。"></a>10. 【推荐】使用 CountDownLatch 进行异步转同步操作,每个线程退出前必须调用 countDown方法,线程执行代码注意 catch 异常,确保 countDown 方法可以执行,避免主线程无法执行 至 countDown 方法,直到超时才返回结果。 说明:注意,子线程抛出异常堆栈,不能在主线程 try-catch 到。</h3><h3 id="11-【推荐】避免-Random-实例被多线程使用-虽然共享该实例是线程安全的-但会因竞争同一-seed-导致的性能下降。"><a href="#11-【推荐】避免-Random-实例被多线程使用-虽然共享该实例是线程安全的-但会因竞争同一-seed-导致的性能下降。" class="headerlink" title="11. 【推荐】避免 Random 实例被多线程使用,虽然共享该实例是线程安全的,但会因竞争同一 seed 导致的性能下降。"></a>11. 【推荐】避免 Random 实例被多线程使用,虽然共享该实例是线程安全的,但会因竞争同一 seed 导致的性能下降。</h3><p>说明:Random 实例包括 java.util.Random 的实例或者 Math.random()实例。<br><code>正例</code>:在 JDK7 之后,可以直接使用 API ThreadLocalRandom,在 JDK7 之前,可以做到每个 线程一个实例。</p>
<h3 id="12-【推荐】通过双重检查锁-double-checked-locking-在并发场景-实现延迟初始化的优化问题隐患-可参考-The-“Double-Checked-Locking-is-Broken”-Declaration-推荐问题解决方案中较为简单一种-适用于-JDK5-及以上版本-将目标属性声明为-volatile-型。"><a href="#12-【推荐】通过双重检查锁-double-checked-locking-在并发场景-实现延迟初始化的优化问题隐患-可参考-The-“Double-Checked-Locking-is-Broken”-Declaration-推荐问题解决方案中较为简单一种-适用于-JDK5-及以上版本-将目标属性声明为-volatile-型。" class="headerlink" title="12.【推荐】通过双重检查锁(double-checked locking)(在并发场景)实现延迟初始化的优化问题隐患(可参考 The “Double-Checked Locking is Broken” Declaration),推荐问题解决方案中较为简单一种(适用于 JDK5 及以上版本),将目标属性声明为 volatile 型。"></a>12.【推荐】通过双重检查锁(double-checked locking)(在并发场景)实现延迟初始化的优化问题隐患(可参考 The “Double-Checked Locking is Broken” Declaration),推荐问题解决方案中较为简单一种(适用于 JDK5 及以上版本),将目标属性声明为 volatile 型。</h3><p><code>反例</code>:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> Helper helper = <span class="keyword">null</span>;</div><div class="line">	<span class="function"><span class="keyword">public</span> Helper <span class="title">getHelper</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (helper == <span class="keyword">null</span>)</div><div class="line">			<span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">				<span class="keyword">if</span> (helper == <span class="keyword">null</span>)</div><div class="line">					helper = <span class="keyword">new</span> Helper();</div><div class="line">			&#125;</div><div class="line">		<span class="keyword">return</span> helper;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// other functions and members...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="13-【参考】volatile-解决多线程内存不可见问题。"><a href="#13-【参考】volatile-解决多线程内存不可见问题。" class="headerlink" title="13. 【参考】volatile 解决多线程内存不可见问题。"></a>13. 【参考】volatile 解决多线程内存不可见问题。</h3><p>对于一写多读,是可以解决变量同步问题, 但是如果多写,同样无法解决线程安全问题。<br>如果是 count++操作,使用如下类实现:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">AtomicInteger count = <span class="keyword">new</span> AtomicInteger(); </div><div class="line">count.addAndGet(<span class="number">1</span>);</div></pre></td></tr></table></figure></p>
<p>如果是 JDK8,推 荐使用 LongAdder 对象,比 AtomicLong 性能更好(减少乐观锁的重试次数)。</p>
<h3 id="14-【参考】HashMap-在容量不够进行-resize-时由于高并发可能出现死链-导致-CPU-飙升-在开发过程中注意规避此风险。"><a href="#14-【参考】HashMap-在容量不够进行-resize-时由于高并发可能出现死链-导致-CPU-飙升-在开发过程中注意规避此风险。" class="headerlink" title="14. 【参考】HashMap 在容量不够进行 resize 时由于高并发可能出现死链,导致 CPU 飙升,在开发过程中注意规避此风险。"></a>14. 【参考】HashMap 在容量不够进行 resize 时由于高并发可能出现死链,导致 CPU 飙升,在开发过程中注意规避此风险。</h3><h3 id="15-【参考】ThreadLocal-无法解决共享对象的更新问题-ThreadLocal-对象建议使用-static-修饰。"><a href="#15-【参考】ThreadLocal-无法解决共享对象的更新问题-ThreadLocal-对象建议使用-static-修饰。" class="headerlink" title="15. 【参考】ThreadLocal 无法解决共享对象的更新问题,ThreadLocal 对象建议使用 static 修饰。"></a>15. 【参考】ThreadLocal 无法解决共享对象的更新问题,ThreadLocal 对象建议使用 static 修饰。</h3><p>这个变量是针对一个线程内所有操作共有的,所以设置为静态变量,所有此类实例共享此静态变量 ,也就是说在类第一次被使用时装载,只分配一块存储空间,所有此类的对象(只要是这个线程内定义的)都可以操控这个变量。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-【强制】获取单例对象需要保证线程安全-其中的方法也要保证线程安全。&quot;&gt;&lt;a href=&quot;#1-【强制】获取单例对象需要保证线程安全-其中的方法也要保证线程安全。&quot; class=&quot;headerlink&quot; title=&quot;1. 【强制】获取单例对象需要保证线程安全,其中的方法也要保证线程安全。&quot;&gt;&lt;/a&gt;1. 【强制】获取单例对象需要保证线程安全,其中的方法也要保证线程安全。&lt;/h3&gt;&lt;p&gt;说明:资源驱动类、工具类、单例工厂类都需要注意。&lt;/p&gt;
&lt;h3 id=&quot;2-【强制】创建线程或线程池时请指定有意义的线程名称-方便出错时回溯。&quot;&gt;&lt;a href=&quot;#2-【强制】创建线程或线程池时请指定有意义的线程名称-方便出错时回溯。&quot; class=&quot;headerlink&quot; title=&quot;2. 【强制】创建线程或线程池时请指定有意义的线程名称,方便出错时回溯。&quot;&gt;&lt;/a&gt;2. 【强制】创建线程或线程池时请指定有意义的线程名称,方便出错时回溯。&lt;/h3&gt;&lt;p&gt;&lt;code&gt;正例&lt;/code&gt;:&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;TimerTaskThread&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Thread&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;TimerTaskThread&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt;.setName(&lt;span class=&quot;string&quot;&gt;&quot;TimerTaskThread&quot;&lt;/span&gt;); &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    ... &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://yvshuo.github.io/tags/java/"/>
    
      <category term="java文档" scheme="http://yvshuo.github.io/tags/java%E6%96%87%E6%A1%A3/"/>
    
  </entry>
  
  <entry>
    <title>阿里巴巴java开发手册解读5-集合处理</title>
    <link href="http://yvshuo.github.io/2017/02/17/2017-02-17-javarule-5/"/>
    <id>http://yvshuo.github.io/2017/02/17/2017-02-17-javarule-5/</id>
    <published>2017-02-17T11:43:16.000Z</published>
    <updated>2017-03-16T13:13:46.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-【强制】关于-hashCode-和-equals-的处理-遵循如下规则"><a href="#1-【强制】关于-hashCode-和-equals-的处理-遵循如下规则" class="headerlink" title="1. 【强制】关于 hashCode 和 equals 的处理,遵循如下规则:"></a>1. 【强制】关于 hashCode 和 equals 的处理,遵循如下规则:</h3><p><strong>1) 只要重写equals,就必须重写hashCode。</strong><br><strong>2) 因为Set存储的是不重复的对象,依据hashCode和equals进行判断,所以Set存储的对象必须重写这两个方法。</strong><br><strong>3) 如果自定义对象做为Map的键,那么必须重写hashCode和equals。</strong><br><code>正例</code>:String 重写了 hashCode 和 equals 方法,所以我们可以非常愉快地使用 String 对象 作为 key 来使用。</p>
<h3 id="2-【强制】ArrayList的subList结果不可强转成ArrayList"><a href="#2-【强制】ArrayList的subList结果不可强转成ArrayList" class="headerlink" title="2. 【强制】ArrayList的subList结果不可强转成ArrayList"></a>2. 【强制】ArrayList的subList结果不可强转成ArrayList</h3><p>否则会抛出ClassCastException 异常:java.util.RandomAccessSubList cannot be cast to java.util.ArrayList ;<br>说明:subList 返回的是 ArrayList 的内部类 SubList,并不是 ArrayList ,而是 ArrayList 的一个视图,对于SubList子列表的所有操作最终会反映到原列表上。</p>
<h3 id="3-【强制】在-subList-场景中-高度注意对原集合元素个数的修改"><a href="#3-【强制】在-subList-场景中-高度注意对原集合元素个数的修改" class="headerlink" title="3. 【强制】在 subList 场景中,高度注意对原集合元素个数的修改"></a>3. 【强制】在 subList 场景中,高度注意对原集合元素个数的修改</h3><p>该修改会导致子列表的遍历、增 加、删除均产生ConcurrentModificationException 异常。<br><a id="more"></a></p>
<h3 id="4-【强制】使用集合转数组的方法-必须使用集合的toArray-T-array-传入的是类型完全一样的数组-大小就是-list-size-。"><a href="#4-【强制】使用集合转数组的方法-必须使用集合的toArray-T-array-传入的是类型完全一样的数组-大小就是-list-size-。" class="headerlink" title="4. 【强制】使用集合转数组的方法,必须使用集合的toArray(T[] array),传入的是类型完全一样的数组,大小就是 list.size()。"></a>4. 【强制】使用集合转数组的方法,必须使用集合的toArray(T[] array),传入的是类型完全一样的数组,大小就是 list.size()。</h3><p><code>反例</code>:直接使用 toArray 无参方法存在问题,此方法返回值只能是 Object[]类,若强转其它 类型数组将出现 ClassCastException 错误。<br><code>正例</code>:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;(<span class="number">2</span>);</div><div class="line">list.add(<span class="string">"guan"</span>);</div><div class="line">list.add(<span class="string">"bao"</span>);</div><div class="line">String[] array = <span class="keyword">new</span> String[list.size()];</div><div class="line">array = list.toArray(array);</div></pre></td></tr></table></figure></p>
<p>说明:使用 toArray 带参方法,入参分配的数组空间不够大时,toArray 方法内部将重新分配内存空间,并返回新数组地址;<br>如果数组元素大于实际所需,下标为[ list.size() ]的数组元素将被置为 null,其它数组元素保持原值,因此最好将方法入参数组大小定义与集合元素个数一致。</p>
<h3 id="5-【强制】使用工具类-Arrays-asList-把数组转换成集合时-不能使用其修改集合相关的方法-它的-add-remove-clear-方法会抛出-UnsupportedOperationException-异常。"><a href="#5-【强制】使用工具类-Arrays-asList-把数组转换成集合时-不能使用其修改集合相关的方法-它的-add-remove-clear-方法会抛出-UnsupportedOperationException-异常。" class="headerlink" title="5. 【强制】使用工具类 Arrays.asList()把数组转换成集合时,不能使用其修改集合相关的方法,它的 add/remove/clear 方法会抛出 UnsupportedOperationException 异常。"></a>5. 【强制】使用工具类 Arrays.asList()把数组转换成集合时,不能使用其修改集合相关的方法,它的 add/remove/clear 方法会抛出 UnsupportedOperationException 异常。</h3><p>说明:asList 的返回对象是一个 Arrays 内部类,并没有实现集合的修改方法。Arrays.asList 体现的是适配器模式,只是转换接口,后台的数据仍是数组。<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">String[] str = <span class="keyword">new</span> String[] &#123; <span class="string">"a"</span>, <span class="string">"b"</span> &#125;;</div><div class="line">List list = Arrays.asList(str);</div></pre></td></tr></table></figure></p>
<p>第一种情况:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">list.add(<span class="string">"c"</span>); <span class="comment">//运行时异常。</span></div></pre></td></tr></table></figure></p>
<p>第二种情况:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">str[<span class="number">0</span>]= <span class="string">"gujin"</span>; <span class="comment">//list.get(0)也会随之修改。</span></div></pre></td></tr></table></figure></p>
<h3 id="6-【强制】泛型通配符-lt-extends-T-gt-来接收返回的数据-此写法的泛型集合不能使用add方法。"><a href="#6-【强制】泛型通配符-lt-extends-T-gt-来接收返回的数据-此写法的泛型集合不能使用add方法。" class="headerlink" title="6. 【强制】泛型通配符&lt;? extends T&gt;来接收返回的数据,此写法的泛型集合不能使用add方法。"></a>6. 【强制】泛型通配符&lt;? extends T&gt;来接收返回的数据,此写法的泛型集合不能使用add方法。</h3><p>说明:苹果装箱后返回一个&lt;? extends Fruits&gt;对象,此对象就不能往里加任何水果,包括苹果。</p>
<h3 id="7-【强制】不要在-foreach-循环里进行元素的-remove-add-操作。"><a href="#7-【强制】不要在-foreach-循环里进行元素的-remove-add-操作。" class="headerlink" title="7. 【强制】不要在 foreach 循环里进行元素的 remove/add 操作。"></a>7. 【强制】不要在 foreach 循环里进行元素的 remove/add 操作。</h3><p>remove 元素请使用 Iterator方式,如果并发操作,需要对 Iterator 对象加锁。<br><code>反例</code>:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">List&lt;String&gt; a = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">a.add(<span class="string">"1"</span>);</div><div class="line">a.add(<span class="string">"2"</span>);</div><div class="line"><span class="keyword">for</span> (String temp : a) &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="string">"1"</span>.equals(temp)) &#123;</div><div class="line">        a.remove(temp);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>说明:以上代码的执行结果肯定会出乎大家的意料,那么试一下把“1”换成“2”,会是同样的结果吗?<br><code>正例</code>:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Iterator&lt;String&gt; it = a.iterator();</div><div class="line"><span class="keyword">while</span> (it.hasNext()) &#123;</div><div class="line">    String temp = it.next();</div><div class="line">    <span class="keyword">if</span> (删除元素的条件) &#123;</div><div class="line">        it.remove();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="8-【强制】在-JDK7-版本以上-Comparator-要满足自反性-传递性-对称性-不然-Arrays-sort-Collections-sort-会报-IllegalArgumentException-异常。"><a href="#8-【强制】在-JDK7-版本以上-Comparator-要满足自反性-传递性-对称性-不然-Arrays-sort-Collections-sort-会报-IllegalArgumentException-异常。" class="headerlink" title="8. 【强制】在 JDK7 版本以上,Comparator 要满足自反性,传递性,对称性,不然 Arrays.sort, Collections.sort 会报 IllegalArgumentException 异常。"></a>8. 【强制】在 JDK7 版本以上,Comparator 要满足自反性,传递性,对称性,不然 Arrays.sort, Collections.sort 会报 IllegalArgumentException 异常。</h3><p>说明:<br><strong>1) 自反性:x,y的比较结果和y,x的比较结果相反。</strong><br><strong>2) 传递性:x&gt;y,y&gt;z,则x&gt;z。</strong><br><strong>3) 对称性:x=y,则x,z比较结果和y,z比较结果相同。</strong><br><code>反例</code>:下例中没有处理相等的情况,实际使用中可能会出现异常:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">new</span> Comparator&lt;Student&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Student o1, Student o2)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> o1.getId() &gt; o2.getId() ? <span class="number">1</span> : -<span class="number">1</span>; </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="9-【推荐】集合初始化时-尽量指定集合初始值大小。"><a href="#9-【推荐】集合初始化时-尽量指定集合初始值大小。" class="headerlink" title="9. 【推荐】集合初始化时,尽量指定集合初始值大小。"></a>9. 【推荐】集合初始化时,尽量指定集合初始值大小。</h3><p>说明:ArrayList尽量使用ArrayList(int initialCapacity) 初始化。</p>
<h3 id="10-【推荐】使用-entrySet-遍历-Map-类集合-KV-而不是-keySet-方式进行遍历。"><a href="#10-【推荐】使用-entrySet-遍历-Map-类集合-KV-而不是-keySet-方式进行遍历。" class="headerlink" title="10. 【推荐】使用 entrySet 遍历 Map 类集合 KV,而不是 keySet 方式进行遍历。"></a>10. 【推荐】使用 entrySet 遍历 Map 类集合 KV,而不是 keySet 方式进行遍历。</h3><p>说明:keySet 其实是遍历了 2 次,一次是转为 Iterator 对象,另一次是从 hashMap 中取出 key 所对应的 value。而 entrySet 只是遍历了一次就把 key 和 value 都放到了 entry 中,效 率更高。如果是 JDK8,使用 Map.foreach 方法。<br><code>正例</code>:<br>values()返回的是 V 值集合,是一个 list 集合对象;<br>keySet()返回的是 K 值集合,是 一个 Set 集合对象;<br>entrySet()返回的是 K-V 值组合集合。</p>
<h3 id="11-【推荐】高度注意-Map-类集合-K-V-能不能存储-null-值的情况-如下表格"><a href="#11-【推荐】高度注意-Map-类集合-K-V-能不能存储-null-值的情况-如下表格" class="headerlink" title="11. 【推荐】高度注意 Map 类集合 K/V 能不能存储 null 值的情况,如下表格:"></a>11. 【推荐】高度注意 Map 类集合 K/V 能不能存储 null 值的情况,如下表格:</h3><table>
<thead>
<tr>
<th style="text-align:center">集合类</th>
<th style="text-align:center">Key</th>
<th style="text-align:center">Value</th>
<th style="text-align:center">Super</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Hashtable</td>
<td style="text-align:center">不允许为 null</td>
<td style="text-align:center">不允许为 null</td>
<td style="text-align:center">Dictionary</td>
<td style="text-align:center">线程安全</td>
</tr>
<tr>
<td style="text-align:center">ConcurrentHashMap</td>
<td style="text-align:center">不允许为 null</td>
<td style="text-align:center">不允许为 null</td>
<td style="text-align:center">AbstractMap</td>
<td style="text-align:center">分段锁技术</td>
</tr>
<tr>
<td style="text-align:center">TreeMap</td>
<td style="text-align:center">不允许为 null</td>
<td style="text-align:center">允许为 null</td>
<td style="text-align:center">AbstractMap</td>
<td style="text-align:center">线程不安全</td>
</tr>
<tr>
<td style="text-align:center">HashMap</td>
<td style="text-align:center">允许为 null</td>
<td style="text-align:center">允许为 null</td>
<td style="text-align:center">AbstractMap</td>
<td style="text-align:center">线程不安全</td>
</tr>
</tbody>
</table>
<p><code>反例</code>: 由于 HashMap 的干扰,很多人认为 ConcurrentHashMap 是可以置入 null 值,注意存储 null 值时会抛出 NPE 异常。</p>
<h3 id="12-【参考】合理利用好集合的有序性-sort-和稳定性-order-避免集合的无序性-unsort-和-不稳定性-unorder-带来的负面影响。"><a href="#12-【参考】合理利用好集合的有序性-sort-和稳定性-order-避免集合的无序性-unsort-和-不稳定性-unorder-带来的负面影响。" class="headerlink" title="12. 【参考】合理利用好集合的有序性(sort)和稳定性(order),避免集合的无序性(unsort)和 不稳定性(unorder)带来的负面影响。"></a>12. 【参考】合理利用好集合的有序性(sort)和稳定性(order),避免集合的无序性(unsort)和 不稳定性(unorder)带来的负面影响。</h3><p>说明:稳定性指集合每次遍历的元素次序是一定的。有序性是指遍历的结果是按某种比较规则 依次排列的。<br>如:ArrayList 是 order/unsort;HashMap 是 unorder/unsort;TreeSet 是 order/sort。</p>
<h3 id="13-【参考】利用-Set-元素唯一的特性-可以快速对一个集合进行去重操作-避免使用-List-的-contains-方法进行遍历、对比、去重操作。"><a href="#13-【参考】利用-Set-元素唯一的特性-可以快速对一个集合进行去重操作-避免使用-List-的-contains-方法进行遍历、对比、去重操作。" class="headerlink" title="13. 【参考】利用 Set 元素唯一的特性,可以快速对一个集合进行去重操作,避免使用 List 的 contains 方法进行遍历、对比、去重操作。"></a>13. 【参考】利用 Set 元素唯一的特性,可以快速对一个集合进行去重操作,避免使用 List 的 contains 方法进行遍历、对比、去重操作。</h3>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-【强制】关于-hashCode-和-equals-的处理-遵循如下规则&quot;&gt;&lt;a href=&quot;#1-【强制】关于-hashCode-和-equals-的处理-遵循如下规则&quot; class=&quot;headerlink&quot; title=&quot;1. 【强制】关于 hashCode 和 equals 的处理,遵循如下规则:&quot;&gt;&lt;/a&gt;1. 【强制】关于 hashCode 和 equals 的处理,遵循如下规则:&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;1) 只要重写equals,就必须重写hashCode。&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;2) 因为Set存储的是不重复的对象,依据hashCode和equals进行判断,所以Set存储的对象必须重写这两个方法。&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;3) 如果自定义对象做为Map的键,那么必须重写hashCode和equals。&lt;/strong&gt;&lt;br&gt;&lt;code&gt;正例&lt;/code&gt;:String 重写了 hashCode 和 equals 方法,所以我们可以非常愉快地使用 String 对象 作为 key 来使用。&lt;/p&gt;
&lt;h3 id=&quot;2-【强制】ArrayList的subList结果不可强转成ArrayList&quot;&gt;&lt;a href=&quot;#2-【强制】ArrayList的subList结果不可强转成ArrayList&quot; class=&quot;headerlink&quot; title=&quot;2. 【强制】ArrayList的subList结果不可强转成ArrayList&quot;&gt;&lt;/a&gt;2. 【强制】ArrayList的subList结果不可强转成ArrayList&lt;/h3&gt;&lt;p&gt;否则会抛出ClassCastException 异常:java.util.RandomAccessSubList cannot be cast to java.util.ArrayList ;&lt;br&gt;说明:subList 返回的是 ArrayList 的内部类 SubList,并不是 ArrayList ,而是 ArrayList 的一个视图,对于SubList子列表的所有操作最终会反映到原列表上。&lt;/p&gt;
&lt;h3 id=&quot;3-【强制】在-subList-场景中-高度注意对原集合元素个数的修改&quot;&gt;&lt;a href=&quot;#3-【强制】在-subList-场景中-高度注意对原集合元素个数的修改&quot; class=&quot;headerlink&quot; title=&quot;3. 【强制】在 subList 场景中,高度注意对原集合元素个数的修改&quot;&gt;&lt;/a&gt;3. 【强制】在 subList 场景中,高度注意对原集合元素个数的修改&lt;/h3&gt;&lt;p&gt;该修改会导致子列表的遍历、增 加、删除均产生ConcurrentModificationException 异常。&lt;br&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://yvshuo.github.io/tags/java/"/>
    
      <category term="java文档" scheme="http://yvshuo.github.io/tags/java%E6%96%87%E6%A1%A3/"/>
    
  </entry>
  
  <entry>
    <title>阿里巴巴java开发手册解读4-OOP 规约</title>
    <link href="http://yvshuo.github.io/2017/02/13/2017-02-10-javarule-4/"/>
    <id>http://yvshuo.github.io/2017/02/13/2017-02-10-javarule-4/</id>
    <published>2017-02-13T10:43:16.000Z</published>
    <updated>2017-02-13T15:21:37.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-【强制】避免通过一个类的对象引用访问此类的静态变量或静态方法-无谓增加编译器解析成本-直接用类名来访问即可"><a href="#1-【强制】避免通过一个类的对象引用访问此类的静态变量或静态方法-无谓增加编译器解析成本-直接用类名来访问即可" class="headerlink" title="1. 【强制】避免通过一个类的对象引用访问此类的静态变量或静态方法,无谓增加编译器解析成本,直接用类名来访问即可"></a>1. 【强制】避免通过一个类的对象引用访问此类的静态变量或静态方法,无谓增加编译器解析成本,直接用类名来访问即可</h3><blockquote>
<p><strong>批注</strong>:<br><code>正例</code>:<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">Integer.parseInt(<span class="string">"1"</span>);</div></pre></td></tr></table></figure></p>
</blockquote>
<p><code>反例</code>:<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">Integer i = new Integer(0);</div><div class="line">i.parseInt(<span class="string">"1"</span>);</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<h3 id="2-【强制】所有的覆写方法-必须加-Override注解"><a href="#2-【强制】所有的覆写方法-必须加-Override注解" class="headerlink" title="2. 【强制】所有的覆写方法,必须加@Override注解"></a>2. 【强制】所有的覆写方法,必须加@Override注解</h3><p>反例:getObject()与 get0bject()的问题。一个是字母的 O,一个是数字的 0,加@Override 可以准确判断是否覆盖成功。另外,如果在抽象类中对方法签名进行修改,其实现类会马上编译报错。</p>
<blockquote>
<p><strong>批注</strong>:@Override会去检查是否和覆写类的名字相同</p>
</blockquote>
<h3 id="3-【强制】相同参数类型-相同业务含义-才可以使用-Java-的可变参数-避免使用-Object"><a href="#3-【强制】相同参数类型-相同业务含义-才可以使用-Java-的可变参数-避免使用-Object" class="headerlink" title="3. 【强制】相同参数类型,相同业务含义,才可以使用 Java 的可变参数,避免使用 Object"></a>3. 【强制】相同参数类型,相同业务含义,才可以使用 Java 的可变参数,避免使用 Object</h3><p>说明:可变参数必须放置在参数列表的最后。<strong>(提倡同学们尽量不用可变参数编程)</strong><br><code>正例</code>:public User getUsers(String type, Integer… ids)</p>
<h3 id="4-【强制】对外暴露的接口签名-原则上不允许修改方法签名-避免对接口调用方产生影响"><a href="#4-【强制】对外暴露的接口签名-原则上不允许修改方法签名-避免对接口调用方产生影响" class="headerlink" title="4. 【强制】对外暴露的接口签名,原则上不允许修改方法签名,避免对接口调用方产生影响"></a>4. 【强制】对外暴露的接口签名,原则上不允许修改方法签名,避免对接口调用方产生影响</h3><p>接口过时必须加@Deprecated 注解,并清晰地说明采用的新接口或者新服务是什么。</p>
<blockquote>
<p><strong>批注</strong>:接口重构中的一项基本原则</p>
</blockquote>
<h3 id="5-【强制】不能使用过时的类或方法"><a href="#5-【强制】不能使用过时的类或方法" class="headerlink" title="5. 【强制】不能使用过时的类或方法"></a>5. 【强制】不能使用过时的类或方法</h3><p>说明:java.net.URLDecoder 中的方法 decode(String encodeStr) 这个方法已经过时,应该使用双参数 decode(String source, String encode)。接口提供方既然明确是过时接口, 那么有义务同时提供新的接口;作为调用方来说,有义务去考证过时方法的新实现是什么。</p>
<h3 id="6-【强制】Object-的-equals-方法容易抛空指针异常-应使用常量或确定有值的对象来调用equals。"><a href="#6-【强制】Object-的-equals-方法容易抛空指针异常-应使用常量或确定有值的对象来调用equals。" class="headerlink" title="6. 【强制】Object 的 equals 方法容易抛空指针异常,应使用常量或确定有值的对象来调用equals。"></a>6. 【强制】Object 的 equals 方法容易抛空指针异常,应使用常量或确定有值的对象来调用equals。</h3><p><code>正例</code>: “test”.equals(object);<br><code>反例</code>: object.equals(“test”);<br>说明:推荐使用java.util.Objects#equals (JDK7引入的工具类)</p>
<blockquote>
<p><strong>批注</strong>:想起自己每次都是判断一下object是否实例化然后再使用反例- -捂脸</p>
</blockquote>
<h3 id="7-【强制】所有的相同类型的包装类对象之间值的比较-全部使用-equals-方法比较"><a href="#7-【强制】所有的相同类型的包装类对象之间值的比较-全部使用-equals-方法比较" class="headerlink" title="7. 【强制】所有的相同类型的包装类对象之间值的比较,全部使用 equals 方法比较"></a>7. 【强制】所有的相同类型的包装类对象之间值的比较,全部使用 equals 方法比较</h3><p>说明:对于Integer var=?在-128至127之间的赋值,Integer对象是在 IntegerCache.cache 产生,会复用已有对象,这个区间内的 Integer 值可以直接使用==进行 判断,但是这个区间之外的所有数据,都会在堆上产生,并不会复用已有对象,这是一个大坑, 推荐使用 equals 方法进行判断。</p>
<h3 id="8-【强制】关于基本数据类型与包装数据类型的使用标准如下"><a href="#8-【强制】关于基本数据类型与包装数据类型的使用标准如下" class="headerlink" title="8. 【强制】关于基本数据类型与包装数据类型的使用标准如下:"></a>8. 【强制】关于基本数据类型与包装数据类型的使用标准如下:</h3><p><strong>1) 所有的POJO类属性必须使用包装数据类型。</strong><br><strong>2) RPC方法的返回值和参数必须使用包装数据类型。</strong><br><strong>3) 所有的局部变量【推荐】使用基本数据类型。</strong><br>说明:POJO 类属性没有初值是提醒使用者在需要使用时,必须自己显式地进行赋值,任何NPE问题,或者入库检查,都由使用者来保证。<br><code>正例</code>:数据库的查询结果可能是 null,因为自动拆箱,用基本数据类型接收有 NPE 风险。<br><code>反例</code>:比如显示成交总额涨跌情况,即正负 x%,x 为基本数据类型,调用的 RPC 服务,调用不成功时,返回的是默认值,页面显示:0%,这是不合理的,应该显示成中划线-。所以包装 数据类型的 null 值,能够表示额外的信息,如:远程调用失败,异常退出。</p>
<blockquote>
<p><strong>批注</strong>:NPE是指空指针异常。在单位的java项目中经常遇到复杂的POJO类。这条准则就是将处理NPE的职责进行明确划分，将POJO类的检查交给使用者。</p>
</blockquote>
<h3 id="9-【强制】定义-DO-DTO-VO-等-POJO-类时-不要设定任何属性默认值"><a href="#9-【强制】定义-DO-DTO-VO-等-POJO-类时-不要设定任何属性默认值" class="headerlink" title="9. 【强制】定义 DO/DTO/VO 等 POJO 类时,不要设定任何属性默认值"></a>9. 【强制】定义 DO/DTO/VO 等 POJO 类时,不要设定任何属性默认值</h3><p><code>反例</code>:POJO类的gmtCreate默认值为new Date();但是这个属性在数据提取时并没有置入具体值,在更新其它字段时又附带更新了此字段,导致创建时间被修改成当前时间。</p>
<blockquote>
<p><strong>批注</strong>:不给POJO类设置属性默认值，避免出现奇奇怪怪的问题</p>
</blockquote>
<h3 id="10-【强制】序列化类新增属性时-请不要修改-serialVersionUID-字段-避免反序列失败"><a href="#10-【强制】序列化类新增属性时-请不要修改-serialVersionUID-字段-避免反序列失败" class="headerlink" title="10. 【强制】序列化类新增属性时,请不要修改 serialVersionUID 字段,避免反序列失败"></a>10. 【强制】序列化类新增属性时,请不要修改 serialVersionUID 字段,避免反序列失败</h3><p>如果完全不兼容升级,避免反序列化混乱,那么请修改 serialVersionUID 值。<br>说明:注意 serialVersionUID 不一致会抛出序列化运行时异常。</p>
<h3 id="11-【强制】构造方法里面禁止加入任何业务逻辑-如果有初始化逻辑-请放在-init-方法中"><a href="#11-【强制】构造方法里面禁止加入任何业务逻辑-如果有初始化逻辑-请放在-init-方法中" class="headerlink" title="11. 【强制】构造方法里面禁止加入任何业务逻辑,如果有初始化逻辑,请放在 init 方法中"></a>11. 【强制】构造方法里面禁止加入任何业务逻辑,如果有初始化逻辑,请放在 init 方法中</h3><h3 id="12-【强制】POJO-类必须写-toString-方法。使用-IDE-的中工具-source-gt-generate-toString-时-如果继承了另一个-POJO-类-注意在前面加一下-super-toString。"><a href="#12-【强制】POJO-类必须写-toString-方法。使用-IDE-的中工具-source-gt-generate-toString-时-如果继承了另一个-POJO-类-注意在前面加一下-super-toString。" class="headerlink" title="12. 【强制】POJO 类必须写 toString 方法。使用 IDE 的中工具:source&gt; generate toString 时,如果继承了另一个 POJO 类,注意在前面加一下 super.toString。"></a>12. 【强制】POJO 类必须写 toString 方法。使用 IDE 的中工具:source&gt; generate toString 时,如果继承了另一个 POJO 类,注意在前面加一下 super.toString。</h3><p>说明:在方法执行抛出异常时,可以直接调用 POJO 的 toString()方法打印其属性值,便于排查问题。</p>
<blockquote>
<p><strong>批注</strong>:这项应该是阿里巴巴的经验，这种方法更便于日志调错。重写toString方法后就不需要再断点看值了。</p>
</blockquote>
<h3 id="13-【推荐】使用索引访问用-String-的-split-方法得到的数组时-需做最后一个分隔符后有无内容的检查-否则会有抛-IndexOutOfBoundsException-的风险。"><a href="#13-【推荐】使用索引访问用-String-的-split-方法得到的数组时-需做最后一个分隔符后有无内容的检查-否则会有抛-IndexOutOfBoundsException-的风险。" class="headerlink" title="13. 【推荐】使用索引访问用 String 的 split 方法得到的数组时,需做最后一个分隔符后有无内容的检查,否则会有抛 IndexOutOfBoundsException 的风险。"></a>13. 【推荐】使用索引访问用 String 的 split 方法得到的数组时,需做最后一个分隔符后有无内容的检查,否则会有抛 IndexOutOfBoundsException 的风险。</h3><p>说明:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">String str = <span class="string">"a,b,c,,"</span>;</div><div class="line">String[] ary = str.split(<span class="string">","</span>); <span class="comment">//预期大于 3,结果是 3 System.out.println(ary.length);</span></div></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>批注</strong>:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">String str = <span class="string">"a,b,,c,,"</span>;</div><div class="line">String[] ary = str.split(<span class="string">","</span>); <span class="comment">//返回结果为4，只有最后一个分隔符需要做检查</span></div></pre></td></tr></table></figure></p>
</blockquote>
<p>在使用索引的时候，一般还是要判断一下length再访问</p>
<h3 id="14-【推荐】当一个类有多个构造方法-或者多个同名方法-这些方法应该按顺序放置在一起-便于阅读"><a href="#14-【推荐】当一个类有多个构造方法-或者多个同名方法-这些方法应该按顺序放置在一起-便于阅读" class="headerlink" title="14. 【推荐】当一个类有多个构造方法,或者多个同名方法,这些方法应该按顺序放置在一起, 便于阅读"></a>14. 【推荐】当一个类有多个构造方法,或者多个同名方法,这些方法应该按顺序放置在一起, 便于阅读</h3><h3 id="15-【推荐】-类内方法定义顺序依次是-公有方法或保护方法-gt-私有方法-gt-getter-setter方法"><a href="#15-【推荐】-类内方法定义顺序依次是-公有方法或保护方法-gt-私有方法-gt-getter-setter方法" class="headerlink" title="15.【推荐】 类内方法定义顺序依次是:公有方法或保护方法 &gt; 私有方法 &gt; getter/setter方法"></a>15.【推荐】 类内方法定义顺序依次是:公有方法或保护方法 &gt; 私有方法 &gt; getter/setter方法</h3><p>说明:公有方法是类的调用者和维护者最关心的方法,首屏展示最好;保护方法虽然只是子类 关心,也可能是“模板设计模式”下的核心方法;而私有方法外部一般不需要特别关心,是一个 黑盒实现;因为方法信息价值较低,所有 Service 和 DAO 的 getter/setter 方法放在类体最 后。</p>
<h3 id="16-【推荐】setter-方法中-参数名称与类成员变量名称一致-this-成员名-参数名。在getter-setter-方法中-尽量不要增加业务逻辑-增加排查问题的难度。"><a href="#16-【推荐】setter-方法中-参数名称与类成员变量名称一致-this-成员名-参数名。在getter-setter-方法中-尽量不要增加业务逻辑-增加排查问题的难度。" class="headerlink" title="16. 【推荐】setter 方法中,参数名称与类成员变量名称一致,this.成员名=参数名。在getter/setter 方法中,尽量不要增加业务逻辑,增加排查问题的难度。"></a>16. 【推荐】setter 方法中,参数名称与类成员变量名称一致,this.成员名=参数名。在getter/setter 方法中,尽量不要增加业务逻辑,增加排查问题的难度。</h3><p><code>反例</code>:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">getData</span><span class="params">()</span></span>&#123; </div><div class="line">    <span class="keyword">if</span>(<span class="keyword">true</span>) &#123;</div><div class="line">        <span class="keyword">return</span> data + <span class="number">100</span>; </div><div class="line">    &#125;<span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> data - <span class="number">100</span>; </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>批注</strong>:有些框架会默认去用get+set属性名去操作属性值，所以直接用eclipse的source-&gt;generate getter/setter吧</p>
</blockquote>
<h3 id="17-【推荐】循环体内-字符串的联接方式-使用-StringBuilder-的-append-方法进行扩展。"><a href="#17-【推荐】循环体内-字符串的联接方式-使用-StringBuilder-的-append-方法进行扩展。" class="headerlink" title="17. 【推荐】循环体内,字符串的联接方式,使用 StringBuilder 的 append 方法进行扩展。"></a>17. 【推荐】循环体内,字符串的联接方式,使用 StringBuilder 的 append 方法进行扩展。</h3><p><code>反例</code>:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">String str = <span class="string">"start"</span>; </div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++)&#123;</div><div class="line">    str = str + <span class="string">"hello"</span>; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>说明:反编译出的字节码文件显示每次循环都会 new 出一个 StringBuilder 对象,然后进行 append 操作,最后通过 toString 方法返回 String 对象,造成内存资源浪费。</p>
<blockquote>
<p><strong>批注</strong>:<br>使用下面的测试代码就可以只管看出两者的区别：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer();</div><div class="line">String str = <span class="keyword">new</span> String();</div><div class="line"><span class="keyword">long</span> startTime1=System.currentTimeMillis();</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</div><div class="line">    sb.append(<span class="string">"hello"</span>);</div><div class="line">&#125;</div><div class="line">sb.toString();</div><div class="line"><span class="keyword">long</span> endTime1=System.currentTimeMillis();</div><div class="line"><span class="keyword">long</span> startTime2=System.currentTimeMillis();</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</div><div class="line">    str = str + <span class="string">"hello"</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">long</span> endTime2=System.currentTimeMillis();</div><div class="line">System.out.println(<span class="string">"StringBuffer耗时:"</span>+(endTime1-startTime1)+<span class="string">"ms"</span>);</div><div class="line">System.out.println(<span class="string">"加号连接耗时:"</span>+(endTime2-startTime2)+<span class="string">"ms"</span>);</div></pre></td></tr></table></figure></p>
</blockquote>
<p>测试结果:<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">StringBuffer耗时:4ms</div><div class="line">加号连接耗时:205ms</div></pre></td></tr></table></figure></p>
<h3 id="18-【推荐】final-可提高程序响应效率-声明成-final-的情况"><a href="#18-【推荐】final-可提高程序响应效率-声明成-final-的情况" class="headerlink" title="18. 【推荐】final 可提高程序响应效率,声明成 final 的情况:"></a>18. 【推荐】final 可提高程序响应效率,声明成 final 的情况:</h3><p><strong>1) 不需要重新赋值的变量,包括类属性、局部变量。</strong><br><strong>2) 对象参数前加final,表示不允许修改引用的指向。</strong><br><strong>3) 类方法确定不允许被重写。</strong></p>
<h3 id="19-【推荐】慎用-Object-的-clone-方法来拷贝对象"><a href="#19-【推荐】慎用-Object-的-clone-方法来拷贝对象" class="headerlink" title="19. 【推荐】慎用 Object 的 clone 方法来拷贝对象"></a>19. 【推荐】慎用 Object 的 clone 方法来拷贝对象</h3><p>说明:对象的 clone 方法默认是浅拷贝,若想实现深拷贝需要重写 clone 方法实现属性对象的拷贝。</p>
<blockquote>
<p><strong>批注</strong>:浅拷贝是指拷贝对象时仅仅拷贝对象本身（包括对象中的基本变量），而不拷贝对象包含的引用指向的对象。深拷贝不仅拷贝对象本身，而且拷贝对象包含的引用指向的所有对象。举例来说更加清楚：对象A1中包含对B1的引用，B1中包含对C1的引用。浅拷贝A1得到A2，A2 中依然包含对B1的引用，B1中依然包含对C1的引用。深拷贝则是对浅拷贝的递归，深拷贝A1得到A2，A2中包含对B2（B1的copy）的引用，B2 中包含对C2（C1的copy）的引用。</p>
</blockquote>
<h3 id="20-【推荐】类成员与方法访问控制从严"><a href="#20-【推荐】类成员与方法访问控制从严" class="headerlink" title="20. 【推荐】类成员与方法访问控制从严:"></a>20. 【推荐】类成员与方法访问控制从严:</h3><p><strong>1) 如果不允许外部直接通过new来创建对象,那么构造方法必须是private。</strong><br><strong>2) 工具类不允许有public或default构造方法。</strong><br><strong>3) 类非static成员变量并且与子类共享,必须是protected。</strong><br><strong>4) 类非static成员变量并且仅在本类使用,必须是private。</strong><br><strong>5) 类static成员变量如果仅在本类使用,必须是private。</strong><br><strong>6) 若是static成员变量,必须考虑是否为final。</strong><br><strong>7) 类成员方法只供类内部调用,必须是private。</strong><br><strong>8) 类成员方法只对继承类公开,那么限制为protected。</strong><br>说明:任何类、方法、参数、变量,严控访问范围。过宽泛的访问范围,不利于模块解耦。<br>思考:如果是一个 private 的方法,想删除就删除,可是一个 public 的 Service 方法,或者一 个 public 的成员变量,删除一下,不得手心冒点汗吗?变量像自己的小孩,尽量在自己的视 线内,变量作用域太大,如果无限制的到处跑,那么你会担心的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-【强制】避免通过一个类的对象引用访问此类的静态变量或静态方法-无谓增加编译器解析成本-直接用类名来访问即可&quot;&gt;&lt;a href=&quot;#1-【强制】避免通过一个类的对象引用访问此类的静态变量或静态方法-无谓增加编译器解析成本-直接用类名来访问即可&quot; class=&quot;headerlink&quot; title=&quot;1. 【强制】避免通过一个类的对象引用访问此类的静态变量或静态方法,无谓增加编译器解析成本,直接用类名来访问即可&quot;&gt;&lt;/a&gt;1. 【强制】避免通过一个类的对象引用访问此类的静态变量或静态方法,无谓增加编译器解析成本,直接用类名来访问即可&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;批注&lt;/strong&gt;:&lt;br&gt;&lt;code&gt;正例&lt;/code&gt;:&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;Integer.parseInt(&lt;span class=&quot;string&quot;&gt;&quot;1&quot;&lt;/span&gt;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;反例&lt;/code&gt;:&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;Integer i = new Integer(0);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;i.parseInt(&lt;span class=&quot;string&quot;&gt;&quot;1&quot;&lt;/span&gt;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://yvshuo.github.io/tags/java/"/>
    
      <category term="java文档" scheme="http://yvshuo.github.io/tags/java%E6%96%87%E6%A1%A3/"/>
    
  </entry>
  
  <entry>
    <title>阿里巴巴java开发手册解读3-格式规约</title>
    <link href="http://yvshuo.github.io/2017/02/10/2017-02-10-javarule-3/"/>
    <id>http://yvshuo.github.io/2017/02/10/2017-02-10-javarule-3/</id>
    <published>2017-02-10T01:35:25.000Z</published>
    <updated>2017-02-10T10:02:24.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-【强制】大括号的使用约定"><a href="#1-【强制】大括号的使用约定" class="headerlink" title="1. 【强制】大括号的使用约定"></a>1. 【强制】大括号的使用约定</h3><p>如果是大括号内为空,则简洁地写成{}即可,不需要换行;如果 是非空代码块则:<br><strong>1) 左大括号前不换行</strong><br><strong>2) 左大括号后换行</strong></p>
<blockquote>
<p><strong>批注</strong>:<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="keyword">if</span> (a &lt; 0) &#123;</div><div class="line">    // <span class="keyword">do</span> something 1</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> (a &gt; 0) &#123;</div><div class="line">    // <span class="keyword">do</span> something 2</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</blockquote>
<p><strong>3) 右大括号前换行</strong><br><strong>4) 右大括号后还有else等代码则不换行;表示终止右大括号后必须换行</strong></p>
<blockquote>
<p><strong>批注</strong>:<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="keyword">if</span> (a &lt; 0) &#123;</div><div class="line">    // <span class="keyword">do</span> something 1</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    // <span class="keyword">do</span> something 2</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</blockquote>
<a id="more"></a>
<h3 id="2-【强制】-左括号和后一个字符之间不出现空格-同样-右括号和前一个字符之间也不出现空格"><a href="#2-【强制】-左括号和后一个字符之间不出现空格-同样-右括号和前一个字符之间也不出现空格" class="headerlink" title="2. 【强制】 左括号和后一个字符之间不出现空格;同样,右括号和前一个字符之间也不出现空格"></a>2. 【强制】 左括号和后一个字符之间不出现空格;同样,右括号和前一个字符之间也不出现空格</h3><p>详见第 5 条下方正例提示</p>
<h3 id="3-【强制】if-for-while-switch-do-等保留字与左右括号之间都必须加空格"><a href="#3-【强制】if-for-while-switch-do-等保留字与左右括号之间都必须加空格" class="headerlink" title="3. 【强制】if/for/while/switch/do 等保留字与左右括号之间都必须加空格"></a>3. 【强制】if/for/while/switch/do 等保留字与左右括号之间都必须加空格</h3><h3 id="4-【强制】任何运算符左右必须加一个空格"><a href="#4-【强制】任何运算符左右必须加一个空格" class="headerlink" title="4. 【强制】任何运算符左右必须加一个空格"></a>4. 【强制】任何运算符左右必须加一个空格</h3><p>说明:运算符包括赋值运算符=、逻辑运算符&amp;&amp;、加减乘除符号、三目运行符等。</p>
<h3 id="5-【强制】缩进采用-4-个空格-禁止使用-tab-字符"><a href="#5-【强制】缩进采用-4-个空格-禁止使用-tab-字符" class="headerlink" title="5. 【强制】缩进采用 4 个空格,禁止使用 tab 字符"></a>5. 【强制】缩进采用 4 个空格,禁止使用 tab 字符</h3><p>说明:如果使用 tab 缩进,必须设置 1 个 tab 为 4 个空格。IDEA 设置 tab 为 4 个空格时, 请勿勾选Use tab character;而在 eclipse 中,必须勾选insert spaces for tabs。<br><code>正例</code>: (涉及1-5点)<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</div><div class="line">    <span class="comment">// 缩进 4 个空格</span></div><div class="line">    String say = <span class="string">"hello"</span>;</div><div class="line">    <span class="comment">// 运算符的左右必须有一个空格</span></div><div class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;</div><div class="line">    <span class="comment">// 关键词 if 与括号之间必须有一个空格,括号内的 f 与左括号,0 与右括号不需要空格</span></div><div class="line">    <span class="keyword">if</span> (flag == <span class="number">0</span>) &#123;</div><div class="line">        System.out.println(say);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 左大括号前加空格且不换行;左大括号后换行</span></div><div class="line">    <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;</div><div class="line">        System.out.println(<span class="string">"world"</span>);</div><div class="line">    <span class="comment">// 右大括号前换行,右大括号后有 else,不用换行</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        System.out.println(<span class="string">"ok"</span>);</div><div class="line">    <span class="comment">// 在右大括号后直接结束,则必须换行</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>批注</strong>:<br>下图为eclipse中缩进的设置<br><img src="/assets/images/2017/02/10/1.png" alt="eclipse设置4个空格"></p>
</blockquote>
<h3 id="6-【强制】单行字符数限制不超过-120-个-超出需要换行-换行时遵循如下原则"><a href="#6-【强制】单行字符数限制不超过-120-个-超出需要换行-换行时遵循如下原则" class="headerlink" title="6. 【强制】单行字符数限制不超过 120 个,超出需要换行,换行时遵循如下原则:"></a>6. 【强制】单行字符数限制不超过 120 个,超出需要换行,换行时遵循如下原则:</h3><p><strong>1) 第二行相对第一行缩进 4 个空格,从第三行开始,不再继续缩进,参考示例</strong><br><strong>2) 运算符与下文一起换行</strong><br><strong>3) 方法调用的点符号与下文一起换行</strong><br><strong>4) 在多个参数超长,逗号后进行换行</strong><br><strong>5) 在括号前不要换行,见反例</strong><br><code>正例</code>:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer();</div><div class="line"><span class="comment">//超过 120 个字符的情况下,换行缩进 4 个空格,并且方法前的点符号一起换行 </span></div><div class="line">sb.append(<span class="string">"zi"</span>).append(<span class="string">"xin"</span>)...</div><div class="line">    .append(<span class="string">"huang"</span>)...</div><div class="line">    .append(<span class="string">"huang"</span>)...</div><div class="line">    .append(<span class="string">"huang"</span>);</div></pre></td></tr></table></figure></p>
<p><code>反例</code>:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer();</div><div class="line"><span class="comment">//超过 120 个字符的情况下,不要在括号前换行</span></div><div class="line">sb.append(<span class="string">"zi"</span>).append(<span class="string">"xin"</span>)...append</div><div class="line">    (<span class="string">"huang"</span>);</div><div class="line"><span class="comment">//参数很多的方法调用可能超过 120 个字符,不要在逗号前换行</span></div><div class="line">method(args1, args2, args3, ...</div><div class="line">    , argsX);</div></pre></td></tr></table></figure></p>
<h3 id="7-【强制】方法参数在定义和传入时-多个参数逗号后边必须加空格"><a href="#7-【强制】方法参数在定义和传入时-多个参数逗号后边必须加空格" class="headerlink" title="7. 【强制】方法参数在定义和传入时,多个参数逗号后边必须加空格"></a>7. 【强制】方法参数在定义和传入时,多个参数逗号后边必须加空格</h3><p><code>正例</code>:下例中实参的”a”,后边必须要有一个空格。<br>method(“a”, “b”, “c”);</p>
<h3 id="8-【强制】IDE的text-file-encoding设置为UTF-8-IDE中文件的换行符使用Unix格式-不要使用-windows-格式"><a href="#8-【强制】IDE的text-file-encoding设置为UTF-8-IDE中文件的换行符使用Unix格式-不要使用-windows-格式" class="headerlink" title="8. 【强制】IDE的text file encoding设置为UTF-8; IDE中文件的换行符使用Unix格式, 不要使用 windows 格式"></a>8. 【强制】IDE的text file encoding设置为UTF-8; IDE中文件的换行符使用Unix格式, 不要使用 windows 格式</h3><h3 id="9-【推荐】没有必要增加若干空格来使某一行的字符与上一行的相应字符对齐"><a href="#9-【推荐】没有必要增加若干空格来使某一行的字符与上一行的相应字符对齐" class="headerlink" title="9. 【推荐】没有必要增加若干空格来使某一行的字符与上一行的相应字符对齐"></a>9. 【推荐】没有必要增加若干空格来使某一行的字符与上一行的相应字符对齐</h3><p><code>正例</code>:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">int</span> a = <span class="number">3</span>;</div><div class="line"><span class="keyword">long</span> b = <span class="number">4L</span>;</div><div class="line"><span class="keyword">float</span> c = <span class="number">5F</span>;</div><div class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer();</div></pre></td></tr></table></figure></p>
<p>说明:增加 sb 这个变量,如果需要对齐,则给 a、b、c 都要增加几个空格,在变量比较多的 情况下,是一种累赘的事情。</p>
<h3 id="10-【推荐】方法体内的执行语句组、变量的定义语句组、不同的业务逻辑之间或者不同的语义之间插入一个空行。相同业务逻辑和语义之间不需要插入空行。"><a href="#10-【推荐】方法体内的执行语句组、变量的定义语句组、不同的业务逻辑之间或者不同的语义之间插入一个空行。相同业务逻辑和语义之间不需要插入空行。" class="headerlink" title="10. 【推荐】方法体内的执行语句组、变量的定义语句组、不同的业务逻辑之间或者不同的语义之间插入一个空行。相同业务逻辑和语义之间不需要插入空行。"></a>10. 【推荐】方法体内的执行语句组、变量的定义语句组、不同的业务逻辑之间或者不同的语义之间插入一个空行。相同业务逻辑和语义之间不需要插入空行。</h3><p>说明:没有必要插入多行空格进行隔开。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-【强制】大括号的使用约定&quot;&gt;&lt;a href=&quot;#1-【强制】大括号的使用约定&quot; class=&quot;headerlink&quot; title=&quot;1. 【强制】大括号的使用约定&quot;&gt;&lt;/a&gt;1. 【强制】大括号的使用约定&lt;/h3&gt;&lt;p&gt;如果是大括号内为空,则简洁地写成{}即可,不需要换行;如果 是非空代码块则:&lt;br&gt;&lt;strong&gt;1) 左大括号前不换行&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;2) 左大括号后换行&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;批注&lt;/strong&gt;:&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (a &amp;lt; 0) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    // &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; something 1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (a &amp;gt; 0) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    // &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; something 2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;3) 右大括号前换行&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;4) 右大括号后还有else等代码则不换行;表示终止右大括号后必须换行&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;批注&lt;/strong&gt;:&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (a &amp;lt; 0) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    // &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; something 1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    // &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; something 2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://yvshuo.github.io/tags/java/"/>
    
      <category term="java文档" scheme="http://yvshuo.github.io/tags/java%E6%96%87%E6%A1%A3/"/>
    
  </entry>
  
  <entry>
    <title>阿里巴巴java开发手册解读2-常量定义</title>
    <link href="http://yvshuo.github.io/2017/02/10/2017-02-10-javarule-2/"/>
    <id>http://yvshuo.github.io/2017/02/10/2017-02-10-javarule-2/</id>
    <published>2017-02-10T01:13:20.000Z</published>
    <updated>2017-02-10T01:46:11.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-【强制】不允许出现任何魔法值-即未经定义的常量-直接出现在代码中"><a href="#1-【强制】不允许出现任何魔法值-即未经定义的常量-直接出现在代码中" class="headerlink" title="1. 【强制】不允许出现任何魔法值(即未经定义的常量)直接出现在代码中"></a>1. 【强制】不允许出现任何魔法值(即未经定义的常量)直接出现在代码中</h3><p><code>反例</code>: String key=”Id#taobao_”+tradeId;<br>cache.put(key, value);</p>
<blockquote>
<p><strong>批注</strong>:<br>正确的做法应该是维护一个常量表或者在类起始位置定义常量<br><code>正解</code>：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String PREFIX_TRADEID = <span class="string">"Id#taobao_"</span>;</div><div class="line">String key=PREFIX_TRADEID+tradeId;</div><div class="line">cache.put(key, value);</div></pre></td></tr></table></figure></p>
</blockquote>
<a id="more"></a>
<h3 id="2-【强制】long-或者-Long-初始赋值时-必须使用大写的-L-不能是小写的-l-小写容易跟数字-1-混淆-造成误解。"><a href="#2-【强制】long-或者-Long-初始赋值时-必须使用大写的-L-不能是小写的-l-小写容易跟数字-1-混淆-造成误解。" class="headerlink" title="2. 【强制】long 或者 Long 初始赋值时,必须使用大写的 L,不能是小写的 l,小写容易跟数字 1 混淆,造成误解。"></a>2. 【强制】long 或者 Long 初始赋值时,必须使用大写的 L,不能是小写的 l,小写容易跟数字 1 混淆,造成误解。</h3><p>说明:Long a = 2l; 写的是数字的21,还是Long型的2?</p>
<blockquote>
<p><strong>批注</strong>:<br>0O0~你能看出我打的是什么嘛→_→</p>
</blockquote>
<h3 id="3-【推荐】不要使用一个常量类维护所有常量-应该按常量功能进行归类-分开维护"><a href="#3-【推荐】不要使用一个常量类维护所有常量-应该按常量功能进行归类-分开维护" class="headerlink" title="3. 【推荐】不要使用一个常量类维护所有常量,应该按常量功能进行归类,分开维护"></a>3. 【推荐】不要使用一个常量类维护所有常量,应该按常量功能进行归类,分开维护</h3><p>如:缓存 相关的常量放在类:CacheConsts 下;系统配置相关的常量放在类:ConfigConsts 下。 说明:大而全的常量类,非得使用查找功能才能定位到修改的常量,不利于理解和维护。</p>
<blockquote>
<p><strong>批注</strong>:<br>好的系统架构是自注释的，一眼就能看出哪里是干什么。</p>
</blockquote>
<h3 id="4-【推荐】常量的复用层次有五层-跨应用共享常量、应用内共享常量、子工程内共享常量、包内共享常量、类内共享常量"><a href="#4-【推荐】常量的复用层次有五层-跨应用共享常量、应用内共享常量、子工程内共享常量、包内共享常量、类内共享常量" class="headerlink" title="4. 【推荐】常量的复用层次有五层:跨应用共享常量、应用内共享常量、子工程内共享常量、包内共享常量、类内共享常量"></a>4. 【推荐】常量的复用层次有五层:跨应用共享常量、应用内共享常量、子工程内共享常量、包内共享常量、类内共享常量</h3><p><strong>1) 跨应用共享常量:放置在二方库中,通常是client.jar中的constant目录下。</strong><br><strong>2) 应用内共享常量:放置在一方库的modules中的constant目录下。</strong><br><code>反例</code>:易懂变量也要统一定义成应用内共享常量,两位攻城师在两个类中分别定义 了 表示“是”的变量:<br>类A中:public static final String YES = “yes”;<br>类B中:public static final String YES = “y”; A.YES.equals(B.YES),预期是 true,但实际返回为 false,导致产生线上问题。<br><strong>3) 子工程内部共享常量:即在当前子工程的constant目录下。</strong><br><strong>4) 包内共享常量:即在当前包下单独的constant目录下。</strong><br><strong>5) 类内共享常量:直接在类内部private static final定义。</strong></p>
<h3 id="5-【推荐】如果变量值仅在一个范围内变化用-Enum-类"><a href="#5-【推荐】如果变量值仅在一个范围内变化用-Enum-类" class="headerlink" title="5. 【推荐】如果变量值仅在一个范围内变化用 Enum 类"></a>5. 【推荐】如果变量值仅在一个范围内变化用 Enum 类</h3><p>如果还带有名称之外的延伸属性,必须 使用 Enum 类,下面正例中的数字就是延伸信息,表示星期几。<br>正例:public Enum{ MONDAY(1), TUESDAY(2), WEDNESDAY(3), THURSDAY(4), FRIDAY(5), SATURDAY(6), SUNDAY(7);}</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-【强制】不允许出现任何魔法值-即未经定义的常量-直接出现在代码中&quot;&gt;&lt;a href=&quot;#1-【强制】不允许出现任何魔法值-即未经定义的常量-直接出现在代码中&quot; class=&quot;headerlink&quot; title=&quot;1. 【强制】不允许出现任何魔法值(即未经定义的常量)直接出现在代码中&quot;&gt;&lt;/a&gt;1. 【强制】不允许出现任何魔法值(即未经定义的常量)直接出现在代码中&lt;/h3&gt;&lt;p&gt;&lt;code&gt;反例&lt;/code&gt;: String key=”Id#taobao_”+tradeId;&lt;br&gt;cache.put(key, value);&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;批注&lt;/strong&gt;:&lt;br&gt;正确的做法应该是维护一个常量表或者在类起始位置定义常量&lt;br&gt;&lt;code&gt;正解&lt;/code&gt;：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; String PREFIX_TRADEID = &lt;span class=&quot;string&quot;&gt;&quot;Id#taobao_&quot;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;String key=PREFIX_TRADEID+tradeId;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;cache.put(key, value);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://yvshuo.github.io/tags/java/"/>
    
      <category term="java文档" scheme="http://yvshuo.github.io/tags/java%E6%96%87%E6%A1%A3/"/>
    
  </entry>
  
  <entry>
    <title>阿里巴巴java开发手册解读1-命名规约</title>
    <link href="http://yvshuo.github.io/2017/02/09/2017-02-09-javarule-1/"/>
    <id>http://yvshuo.github.io/2017/02/09/2017-02-09-javarule-1/</id>
    <published>2017-02-09T14:43:47.000Z</published>
    <updated>2017-02-10T01:46:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天拜读了阿里巴巴刚发布的java开发手册，之前做项目时在一些细节的处理上总是不知道如何下手，看完这个手册，收获颇多。附手册全文。</p>
<blockquote>
<p><a href="/assets/pdf/alijava.pdf">阿里巴巴java开发手册</a></p>
</blockquote>
<p>下面是摘录加批注。注：引用标签内为批注，字面规则不附批注。</p>
<h3 id="1-【强制】-代码中的命名均不能以下划线或美元符号开始，也不能以下划线或美元符号结束"><a href="#1-【强制】-代码中的命名均不能以下划线或美元符号开始，也不能以下划线或美元符号结束" class="headerlink" title="1. 【强制】 代码中的命名均不能以下划线或美元符号开始，也不能以下划线或美元符号结束"></a>1. 【强制】 代码中的命名均不能以下划线或美元符号开始，也不能以下划线或美元符号结束</h3><p><code>反例</code>:<em>name / __name / $Object / name</em> / name$ / Object$</p>
<blockquote>
<p><strong>批注</strong>:<br>javascript表示不服！</p>
</blockquote>
<a id="more"></a>
<h3 id="2-【强制】-代码中的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式"><a href="#2-【强制】-代码中的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式" class="headerlink" title="2. 【强制】 代码中的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式"></a>2. 【强制】 代码中的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式</h3><p>说明：正确的英文拼写和语法可以让阅读者易于理解，避免歧义。注意，即使纯拼音命名方式<br>也要避免采用<br><code>反例</code>：DaZhePromotion [打折] / getPingfenByName() [评分] / int 某变量 = 3<br><code>正例</code>：alibaba / taobao / youku / hangzhou 等国际通用的名称，可视同英文。</p>
<blockquote>
<p><strong>批注</strong>:<br>用拼音命名的同学请举起手！你不是一个人！</p>
</blockquote>
<h3 id="3-【强制】类名使用-UpperCamelCase-风格，必须遵从驼峰形式"><a href="#3-【强制】类名使用-UpperCamelCase-风格，必须遵从驼峰形式" class="headerlink" title="3. 【强制】类名使用 UpperCamelCase 风格，必须遵从驼峰形式"></a>3. 【强制】类名使用 UpperCamelCase 风格，必须遵从驼峰形式</h3><p>以下情形例外：（领域模型的相关命名）DO / BO / DTO / VO 等<br><code>正例</code>：MarcoPolo / UserDO / XmlService / TcpUdpDeal / TaPromotion<br><code>反例</code>：macroPolo / UserDo / XMLService / TCPUDPDeal / TAPromotion</p>
<blockquote>
<p><strong>批注</strong>:<br>1） DO(data object) 数据对象<br>2） DAO(data access object) 数据访问对象<br>3） DTO(Data Transfer Object) 数据传输对象<br>4） VO(value object) 值对象<br>5） BO(business object) 业务对象<br>6） POJO 是 DO/DTO/BO/VO 的统称</p>
</blockquote>
<h3 id="4-【强制】方法名、参数名、成员变量、局部变量都统一使用-lowerCamelCase-风格，必须遵从"><a href="#4-【强制】方法名、参数名、成员变量、局部变量都统一使用-lowerCamelCase-风格，必须遵从" class="headerlink" title="4. 【强制】方法名、参数名、成员变量、局部变量都统一使用 lowerCamelCase 风格，必须遵从"></a>4. 【强制】方法名、参数名、成员变量、局部变量都统一使用 lowerCamelCase 风格，必须遵从</h3><p>驼峰形式<br><code>正例</code>： localValue / getHttpMessage() / inputUserId</p>
<h3 id="5-【强制】常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长"><a href="#5-【强制】常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长" class="headerlink" title="5. 【强制】常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长"></a>5. 【强制】常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长</h3><p><code>正例</code>： MAX_STOCK_COUNT<br><code>反例</code>： MAX_COUNT</p>
<h3 id="6-【强制】抽象类命名使用-Abstract-或-Base-开头；异常类命名使用-Exception-结尾；测试类命名以它要测试的类的名称开始，以-Test-结尾"><a href="#6-【强制】抽象类命名使用-Abstract-或-Base-开头；异常类命名使用-Exception-结尾；测试类命名以它要测试的类的名称开始，以-Test-结尾" class="headerlink" title="6. 【强制】抽象类命名使用 Abstract 或 Base 开头；异常类命名使用 Exception 结尾；测试类命名以它要测试的类的名称开始，以 Test 结尾"></a>6. 【强制】抽象类命名使用 Abstract 或 Base 开头；异常类命名使用 Exception 结尾；测试类命名以它要测试的类的名称开始，以 Test 结尾</h3><h3 id="7-【强制】中括号是数组类型的一部分"><a href="#7-【强制】中括号是数组类型的一部分" class="headerlink" title="7. 【强制】中括号是数组类型的一部分"></a>7. 【强制】中括号是数组类型的一部分</h3><p>数组定义如下：String[] args<br><code>反例</code>：请勿使用 String args[]的方式来定义</p>
<blockquote>
<p><strong>批注</strong>:<br>务必注意</p>
</blockquote>
<h3 id="8-【强制】POJO-类中布尔类型的变量，都不要加-is"><a href="#8-【强制】POJO-类中布尔类型的变量，都不要加-is" class="headerlink" title="8. 【强制】POJO 类中布尔类型的变量，都不要加 is"></a>8. 【强制】POJO 类中布尔类型的变量，都不要加 is</h3><p>否则部分框架解析会引起序列化错误<br><code>反例</code>：定义为基本数据类型 boolean isSuccess；的属性，它的方法也是 isSuccess()，RPC<br>框架在反向解析的时候，“以为”对应的属性名称是 success，导致属性获取不到，进而抛出异<br>常。</p>
<h3 id="9-【强制】包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用单数形式，但是类名如果有复数含义，类名可以使用复数形式"><a href="#9-【强制】包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用单数形式，但是类名如果有复数含义，类名可以使用复数形式" class="headerlink" title="9. 【强制】包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用单数形式，但是类名如果有复数含义，类名可以使用复数形式"></a>9. 【强制】包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用单数形式，但是类名如果有复数含义，类名可以使用复数形式</h3><p><code>正例</code>： 应用工具类包名为 com.alibaba.open.util、类名为 MessageUtils（此规则参考<br>spring 的框架结构）</p>
<h3 id="10-【强制】杜绝完全不规范的缩写，避免望文不知义"><a href="#10-【强制】杜绝完全不规范的缩写，避免望文不知义" class="headerlink" title="10. 【强制】杜绝完全不规范的缩写，避免望文不知义"></a>10. 【强制】杜绝完全不规范的缩写，避免望文不知义</h3><p><code>反例</code>： AbstractClass“缩写”命名成 AbsClass；condition“缩写”命名成 condi，此类<br>随意缩写严重降低了代码的可阅读性。</p>
<blockquote>
<p><strong>批注</strong>:<br>一个优秀程序员的自我修养！以后还是少用btn，写全button！</p>
</blockquote>
<h3 id="11-【推荐】如果使用到了设计模式，建议在类名中体现出具体模式"><a href="#11-【推荐】如果使用到了设计模式，建议在类名中体现出具体模式" class="headerlink" title="11. 【推荐】如果使用到了设计模式，建议在类名中体现出具体模式"></a>11. 【推荐】如果使用到了设计模式，建议在类名中体现出具体模式</h3><p>说明：将设计模式体现在名字中，有利于阅读者快速理解架构设计思想。<br><code>正例</code>：public class OrderFactory;<br>public class LoginProxy;<br>public class ResourceObserver;</p>
<h3 id="12-【推荐】接口类中的方法和属性不要加任何修饰符号（public-也不要加），保持代码的简洁性，并加上有效的-Javadoc-注释。尽量不要在接口里定义变量，如果一定要定义变量，肯定是与接口方法相关，并且是整个应用的基础常量"><a href="#12-【推荐】接口类中的方法和属性不要加任何修饰符号（public-也不要加），保持代码的简洁性，并加上有效的-Javadoc-注释。尽量不要在接口里定义变量，如果一定要定义变量，肯定是与接口方法相关，并且是整个应用的基础常量" class="headerlink" title="12. 【推荐】接口类中的方法和属性不要加任何修饰符号（public 也不要加），保持代码的简洁性，并加上有效的 Javadoc 注释。尽量不要在接口里定义变量，如果一定要定义变量，肯定是与接口方法相关，并且是整个应用的基础常量"></a>12. 【推荐】接口类中的方法和属性不要加任何修饰符号（public 也不要加），保持代码的简洁性，并加上有效的 Javadoc 注释。尽量不要在接口里定义变量，如果一定要定义变量，肯定是与接口方法相关，并且是整个应用的基础常量</h3><p><code>正例</code>：接口方法签名：void f();<br> 接口基础常量表示：String COMPANY = “alibaba”;<br><code>反例</code>：接口方法定义：public abstract void f();<br>说明：JDK8 中接口允许有默认实现，那么这个 default 方法，是对所有实现类都有价值的默<br>认实现。</p>
<blockquote>
<p><strong>批注</strong>:<br>个人还是习惯加上修饰符号。不过接口本身就是public的，要改掉这个坏习惯</p>
</blockquote>
<h3 id="13-接口和实现类的命名有两套规则："><a href="#13-接口和实现类的命名有两套规则：" class="headerlink" title="13. 接口和实现类的命名有两套规则："></a>13. 接口和实现类的命名有两套规则：</h3><p><strong> 1）【强制】对于 Service 和 DAO 类，基于 SOA 的理念，暴露出来的服务一定是接口，内部的实现类用 Impl 的后缀与接口区别。</strong><br><code>正例</code>：CacheServiceImpl 实现 CacheService 接口。<br><strong> 2）【推荐】如果是形容能力的接口名称，取对应的形容词做接口名（通常是–able 的形式）。</strong><br><code>正例</code>：AbstractTranslator 实现 Translatable。</p>
<h3 id="14-【参考】枚举类名建议带上-Enum-后缀，枚举成员名称需要全大写，单词间用下划线隔开。"><a href="#14-【参考】枚举类名建议带上-Enum-后缀，枚举成员名称需要全大写，单词间用下划线隔开。" class="headerlink" title="14. 【参考】枚举类名建议带上 Enum 后缀，枚举成员名称需要全大写，单词间用下划线隔开。"></a>14. 【参考】枚举类名建议带上 Enum 后缀，枚举成员名称需要全大写，单词间用下划线隔开。</h3><p>说明：枚举其实就是特殊的常量类，且构造方法被默认强制是私有<br><code>正例</code>：枚举名字：DealStatusEnum，成员名称：SUCCESS / UNKOWN_REASON。</p>
<h3 id="15-【参考】各层命名规约："><a href="#15-【参考】各层命名规约：" class="headerlink" title="15. 【参考】各层命名规约："></a>15. 【参考】各层命名规约：</h3><p><strong> A) Service/DAO 层方法命名规约 </strong><br>1） 获取单个对象的方法用 get 做前缀。<br>2） 获取多个对象的方法用 list 做前缀。<br>3） 获取统计值的方法用 count 做前缀。<br>4） 插入的方法用 save（推荐）或 insert 做前缀。<br>5） 删除的方法用 remove（推荐）或 delete 做前缀。<br>6） 修改的方法用 update 做前缀。</p>
<p><strong> B) 领域模型命名规约 </strong><br>1） 数据对象：xxxDO，xxx 即为数据表名。<br>2） 数据传输对象：xxxDTO，xxx 为业务领域相关的名称。<br>3） 展示对象：xxxVO，xxx 一般为网页名称。<br>4） POJO 是 DO/DTO/BO/VO 的统称，禁止命名成 xxxPOJO。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天拜读了阿里巴巴刚发布的java开发手册，之前做项目时在一些细节的处理上总是不知道如何下手，看完这个手册，收获颇多。附手册全文。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;/assets/pdf/alijava.pdf&quot;&gt;阿里巴巴java开发手册&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面是摘录加批注。注：引用标签内为批注，字面规则不附批注。&lt;/p&gt;
&lt;h3 id=&quot;1-【强制】-代码中的命名均不能以下划线或美元符号开始，也不能以下划线或美元符号结束&quot;&gt;&lt;a href=&quot;#1-【强制】-代码中的命名均不能以下划线或美元符号开始，也不能以下划线或美元符号结束&quot; class=&quot;headerlink&quot; title=&quot;1. 【强制】 代码中的命名均不能以下划线或美元符号开始，也不能以下划线或美元符号结束&quot;&gt;&lt;/a&gt;1. 【强制】 代码中的命名均不能以下划线或美元符号开始，也不能以下划线或美元符号结束&lt;/h3&gt;&lt;p&gt;&lt;code&gt;反例&lt;/code&gt;:&lt;em&gt;name / __name / $Object / name&lt;/em&gt; / name$ / Object$&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;批注&lt;/strong&gt;:&lt;br&gt;javascript表示不服！&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://yvshuo.github.io/tags/java/"/>
    
      <category term="java文档" scheme="http://yvshuo.github.io/tags/java%E6%96%87%E6%A1%A3/"/>
    
  </entry>
  
  <entry>
    <title>重构—重新组织函数</title>
    <link href="http://yvshuo.github.io/2017/01/16/2017-01-16-refactor/"/>
    <id>http://yvshuo.github.io/2017/01/16/2017-01-16-refactor/</id>
    <published>2017-01-16T03:03:47.000Z</published>
    <updated>2017-01-17T15:52:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>上次单位人力让挑书，然后选了这本《重构-改善既有代码的设计》这本书，作者Martin Fowler是ThoughtWorks公司的首席科学家。虽然书写于很多年前，但是很多思想在编程中依然非常实用。书里主要是讲的各种重构的手法，但是我觉得看完之后，个人感觉更重要的是告诉自己在写代码的过程中如何从源头上注意一些问题，让自己的代码更合理，更优美。最初选这本书也是因为觉得需要超脱语言的层面去理解一些编程的宏观的一些东西，不然总是觉得自己像个机器一样，写着代码，却不懂怎么写更好，为什么别人都那样分层。书已经看了一遍，似乎明白了一些哪些代码好一些、哪些代码差一点。<br>最近再一边读一边记下这个系列的读书笔记，算是记录吧~</p>
<h2 id="1-代码的坏味道"><a href="#1-代码的坏味道" class="headerlink" title="1. 代码的坏味道"></a>1. 代码的坏味道</h2><ul>
<li>重复代码：如果在两个不相关的类中出现了重复的相同功能的函数，就应该考虑新建一个独立的类将这个重复的函数提炼出去。</li>
<li>过长函数：写代码的过程中，有一个原则。<strong>代码块越小，代码的功能就越容易管理，代码的处理和移动也就越轻松。</strong></li>
<li>过大的类：一个类的代码太多的话，最后就会变成一坨，嗯。尽量将特别大的类进行分解。</li>
<li>过长的参数列:拆成bean。</li>
<li>switch泛滥：作者的建议是少用switch，在使用switch的地方考虑使用多态来解决。</li>
<li>数据泥团：数据成群的绑在一起。正确的做法是将总是绑定在一起的数据放到一个对象里。</li>
<li>发散式变化：多种变化都对应同一个类的修改。这种情况下需要考虑将这个类拆开，尽量每种变化只对应一个类的修改。</li>
<li>霰弹式修改：这个类一旦变化，会引发多个类的修改。这种情况下应该尽量将所有需要修改的方法放到一个类里。</li>
</ul>
<h2 id="2-重新组织函数"><a href="#2-重新组织函数" class="headerlink" title="2. 重新组织函数"></a>2. 重新组织函数</h2><h3 id="2-1-extract-method（提炼函数）"><a href="#2-1-extract-method（提炼函数）" class="headerlink" title="2.1 extract method（提炼函数）"></a>2.1 extract method（提炼函数）</h3><p>1) 没有局部变量，直接提炼。<br>2) 有局部变量，把这个局部变量作为参数传入被提炼函数<br>3) 如果需要对局部变量赋值，得需要使用remove Assignments to parameters.如果被赋值的局部变量只在被提炼的函数中被赋值，则把这个局部变量声明到被提炼函数中。如果被赋值的局部变量需要在被提炼的函数其它的地方使用，则需要被提炼函数返回一个被修改后的值。如果遇到返回的不止一个值，则最好的方法是再重新提炼一个新的方法，每次只返回一个值最佳。</p>
<p><code>before</code>:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">printOwing</span><span class="params">(<span class="keyword">double</span> amount)</span></span>&#123;</div><div class="line">    printBanner();</div><div class="line">    <span class="comment">//print details</span></div><div class="line">    System.out.println(<span class="string">"amount:"</span>+amount);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>after</code>:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">printOwing</span><span class="params">(<span class="keyword">double</span> amount)</span></span>&#123;</div><div class="line">    printBanner();</div><div class="line">    printDetails(amount);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDetails</span><span class="params">(<span class="keyword">double</span> amount)</span></span>&#123;</div><div class="line">    System.out.println(<span class="string">"amount:"</span>+amount);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<h3 id="2-2-inline-method-内联函数"><a href="#2-2-inline-method-内联函数" class="headerlink" title="2.2 inline method(内联函数)"></a>2.2 inline method(内联函数)</h3><p><code>before</code>:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getRating</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> (moreThanFiveLateDeliveries()) ? <span class="number">2</span>:<span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">moreThanFiveLateDeliveries</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> _numberOfLateDeliveries &gt; <span class="number">5</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>after</code>:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getRating</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> (_numberOfLateDeliveries &gt; <span class="number">5</span>) ? <span class="number">2</span>:<span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="2-3-inline-temp-内联临时变量"><a href="#2-3-inline-temp-内联临时变量" class="headerlink" title="2.3 inline temp(内联临时变量)"></a>2.3 inline temp(内联临时变量)</h3><p><code>before</code>:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">double</span> basePrice = anOrder.basePrice();</div><div class="line"><span class="keyword">return</span> (basePrice&gt;<span class="number">1000</span>);</div></pre></td></tr></table></figure></p>
<p><code>after</code>:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">return</span> (anOrder.basePrice()&gt;<span class="number">1000</span>);</div></pre></td></tr></table></figure></p>
<h3 id="2-4-replace-temp-with-query-以查询取代临时变量"><a href="#2-4-replace-temp-with-query-以查询取代临时变量" class="headerlink" title="2.4 replace temp with query(以查询取代临时变量)"></a>2.4 replace temp with query(以查询取代临时变量)</h3><p>临时变量的问题在于：他们是暂时的，而且只能在所属函数内使用。由于临时变量只在所属函数内可见，所以更好的方法是将其替换为一个查询，这样，同一个类中的所有函数都将可以获得这份信息。<br><code>before</code>:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">double</span> basePrice = _quantity * _itemPrice;</div><div class="line"><span class="keyword">if</span>(basePrice &gt; <span class="number">1000</span>)</div><div class="line">    <span class="keyword">return</span> basePrice * <span class="number">0.95</span>;</div><div class="line"><span class="keyword">else</span></div><div class="line">    <span class="keyword">return</span> basePrice * <span class="number">0.98</span>;</div></pre></td></tr></table></figure></p>
<p><code>after</code>:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">if</span>(basePrice() &gt; <span class="number">1000</span>)</div><div class="line">    <span class="keyword">return</span> basePrice() * <span class="number">0.95</span>;</div><div class="line"><span class="keyword">else</span></div><div class="line">    <span class="keyword">return</span> basePrice() * <span class="number">0.98</span>;</div><div class="line"><span class="function"><span class="keyword">double</span> <span class="title">basePrice</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> _quantity * _itemPrice;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在进行这项重构的时候有个需要注意的就是得确保这个临时变量是否只被赋值了一次，有个技巧是在这个临时变量前加final修饰符，如果不只被赋值一次，编译器就会报错。这时候就不能使用这个方法。</p>
<h3 id="2-5-introduce-explaining-variable（引入解释型变量）"><a href="#2-5-introduce-explaining-variable（引入解释型变量）" class="headerlink" title="2.5 introduce explaining variable（引入解释型变量）"></a>2.5 introduce explaining variable（引入解释型变量）</h3><p>将复杂表达式放进一个临时变量里，以此变量名称来解释表达式的用途。<br><code>before</code>:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">if</span>((platform.toUpperCase().indexOf(<span class="string">"MAC"</span>) &gt; -<span class="number">1</span>) &amp;&amp;</div><div class="line">    (browser.toUpperCase().indexOf(<span class="string">"IE"</span>) &gt; -<span class="number">1</span>) &amp;&amp;</div><div class="line">    resize&gt;<span class="number">0</span> )&#123;</div><div class="line">    <span class="comment">//do something</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>after</code>:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> isMacOs = platform.toUpperCase().indexOf(<span class="string">"MAC"</span>) &gt; -<span class="number">1</span>;</div><div class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> isIE = browser.toUpperCase().indexOf(<span class="string">"IE"</span>) &gt; -<span class="number">1</span>;</div><div class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> wasResized = resize&gt;<span class="number">0</span>;</div><div class="line"><span class="keyword">if</span>(isMacOs &amp;&amp; isIE &amp;&amp; wasResized)&#123;</div><div class="line">    <span class="comment">//do something</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="2-6-split-temporary-variable（分解临时变量）"><a href="#2-6-split-temporary-variable（分解临时变量）" class="headerlink" title="2.6 split temporary variable（分解临时变量）"></a>2.6 split temporary variable（分解临时变量）</h3><p>程序中有某个临时变量被赋值超过一次，它既不是循环变量，也不被用于收集计算结果。针对每次赋值，创造一个独立、对应的临时变量。<br><code>before</code>:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">double</span> temp = <span class="number">2</span> * (_height + _width);</div><div class="line">System.out.println(temp);</div><div class="line">temp = _height + _width;</div><div class="line">System.out.println(temp);</div></pre></td></tr></table></figure></p>
<p><code>after</code>:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="keyword">double</span> perimeter = <span class="number">2</span> * (_height + _width);</div><div class="line">System.out.println(perimeter);</div><div class="line"><span class="keyword">final</span> <span class="keyword">double</span> area = _height + _width;</div><div class="line">System.out.println(area);</div></pre></td></tr></table></figure></p>
<p>个人理解就是这种做法可以保证在重构过程中不出错，不会影响其他抽取函数等操作。而且也可以使代码变得清晰明了。</p>
<h3 id="2-7-remove-assignments-to-parameters（移除对参数的赋值）"><a href="#2-7-remove-assignments-to-parameters（移除对参数的赋值）" class="headerlink" title="2.7 remove assignments to parameters（移除对参数的赋值）"></a>2.7 remove assignments to parameters（移除对参数的赋值）</h3><p><code>before</code>:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">discount</span><span class="params">(<span class="keyword">int</span> inputVal,<span class="keyword">int</span> quantity,<span class="keyword">int</span> yearToDate)</span></span>&#123;</div><div class="line">	<span class="keyword">if</span>(inputVal &gt; <span class="number">50</span>) inputVal -= <span class="number">2</span>;</div></pre></td></tr></table></figure></p>
<p><code>after</code>:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">discount</span><span class="params">(<span class="keyword">int</span> inputVal,<span class="keyword">int</span> quantity,<span class="keyword">int</span> yearToDate)</span></span>&#123;</div><div class="line">	<span class="keyword">int</span> result = inputVal;</div><div class="line">	<span class="keyword">if</span>(inputVal &gt; <span class="number">50</span>) result -= <span class="number">2</span>;</div></pre></td></tr></table></figure></p>
<p>这么做主要是为了避免在某些按引用传递参数的语言中对调用端造成影响。而且这么做的话，代码会清晰很多，而且这种在任何语言中都会表现出相同的语义。<br>譬如下面的例子中，在参数是对象的情况下，对参数赋值就会造成一些让人糊涂的影响：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">	Date d1 = <span class="keyword">new</span> Date();</div><div class="line">	nextDateUpdate(d1);</div><div class="line">	System.out.println(<span class="string">"d1 after nextday:"</span>+d1);</div><div class="line">	</div><div class="line">	Date d2 = <span class="keyword">new</span> Date();</div><div class="line">	nextDateReplace(d2);</div><div class="line">	System.out.println(<span class="string">"d2 after nextday:"</span>+d2);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nextDateUpdate</span><span class="params">(Date arg)</span></span>&#123;</div><div class="line">	arg.setDate(arg.getDate()+<span class="number">1</span>);<span class="comment">//改变了调用端</span></div><div class="line">	System.out.println(<span class="string">"arg in nextDay update:"</span>+arg);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nextDateReplace</span><span class="params">(Date arg)</span></span>&#123;</div><div class="line">	arg=<span class="keyword">new</span> Date(arg.getYear(),arg.getMonth(),arg.getDate()+<span class="number">1</span>);<span class="comment">//没有改变调用端</span></div><div class="line">	System.out.println(<span class="string">"arg in nextDay replace:"</span>+arg);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>打印出来的结果是：<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">arg <span class="keyword">in</span> nextDay update:Wed Jan 18 10:51:18 CST 2017</div><div class="line">d1 after nextday:Wed Jan 18 10:51:18 CST 2017</div><div class="line">arg <span class="keyword">in</span> nextDay replace:Wed Jan 18 00:00:00 CST 2017</div><div class="line">d2 after nextday:Tue Jan 17 10:51:18 CST 2017</div></pre></td></tr></table></figure></p>
<blockquote>
<p>如果代码的语义是按引用传递的，请在调用端检查调用后是否还使用了这个参数。也要检查有多少个按引用传递的参数被赋值后又被使用。请尽量只以return方式返回一个值。如果需要返回的值不止一个，看看可否把需返回的大堆数据变成单一对象，或干脆为每个返回值设计对应的一个独立函数。</p>
</blockquote>
<h3 id="2-8-replace-method-with-method-object（以函数对象取代函数）"><a href="#2-8-replace-method-with-method-object（以函数对象取代函数）" class="headerlink" title="2.8 replace method with method object（以函数对象取代函数）"></a>2.8 replace method with method object（以函数对象取代函数）</h3><blockquote>
<p>只要将相对独立的代码从大型函数中提炼出来，就可以大大提高代码的可读性。但是，局部变量的存在会增加函数分解难度。如果一个函数中局部变量泛滥，分解函数就会变得困难。这时候就要以函数对象取代函数，将所有局部变量都变成函数对象的字段，从而将大型函数拆解变短。<br>这个就不举例子了~很容易理解。</p>
</blockquote>
<h3 id="2-9-substitute-algorithm（替换算法）"><a href="#2-9-substitute-algorithm（替换算法）" class="headerlink" title="2.9 substitute algorithm（替换算法）"></a>2.9 substitute algorithm（替换算法）</h3><p><code>before</code>:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function">String <span class="title">foundPerson</span><span class="params">(String[] people)</span></span>&#123;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;people.length;i++)&#123;</div><div class="line">		<span class="keyword">if</span>(people[i].equals(<span class="string">"Don"</span>))&#123;</div><div class="line">			<span class="keyword">return</span> <span class="string">"Don"</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span>(people[i].equals(<span class="string">"John"</span>))&#123;</div><div class="line">			<span class="keyword">return</span> <span class="string">"John"</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span>(people[i].equals(<span class="string">"Kent"</span>))&#123;</div><div class="line">			<span class="keyword">return</span> <span class="string">"Kent"</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="string">""</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>after</code>:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function">String <span class="title">foundPerson</span><span class="params">(String[] people)</span></span>&#123;</div><div class="line">	List constants = Arrays.asList(<span class="keyword">new</span> String[]&#123;<span class="string">"Don"</span>,<span class="string">"John"</span>,<span class="string">"Kent"</span>&#125;);</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;people.length;i++)&#123;</div><div class="line">		<span class="keyword">if</span>(constants.contains(people[i]))&#123;</div><div class="line">			<span class="keyword">return</span> people[i];</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="string">""</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>进行算法重构的步骤：<br>1)准备好另一个（替换用）的算法，让它通过编译。<br>2)针对现有测试，执行上述的新算法。如果结果与原本结果相同，重构结束。<br>3)如果测试结果不同于原先，在测试和调试过程中，以旧算法为比较参照标准。</p>
<blockquote>
<p>对于每个测试用例，分别以新旧两种算法执行，并观察两者结果是否相同。</p>
</blockquote>
<h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h2><p>这篇主要是对函数中的代码进行整理~都是些基本的重构手法，真正写代码过程中还是要根据实际情况来有针对性的使用。文中有些是我个人的理解，不一定正确。还是要多读书才能深入理解~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上次单位人力让挑书，然后选了这本《重构-改善既有代码的设计》这本书，作者Martin Fowler是ThoughtWorks公司的首席科学家。虽然书写于很多年前，但是很多思想在编程中依然非常实用。书里主要是讲的各种重构的手法，但是我觉得看完之后，个人感觉更重要的是告诉自己在写代码的过程中如何从源头上注意一些问题，让自己的代码更合理，更优美。最初选这本书也是因为觉得需要超脱语言的层面去理解一些编程的宏观的一些东西，不然总是觉得自己像个机器一样，写着代码，却不懂怎么写更好，为什么别人都那样分层。书已经看了一遍，似乎明白了一些哪些代码好一些、哪些代码差一点。&lt;br&gt;最近再一边读一边记下这个系列的读书笔记，算是记录吧~&lt;/p&gt;
&lt;h2 id=&quot;1-代码的坏味道&quot;&gt;&lt;a href=&quot;#1-代码的坏味道&quot; class=&quot;headerlink&quot; title=&quot;1. 代码的坏味道&quot;&gt;&lt;/a&gt;1. 代码的坏味道&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;重复代码：如果在两个不相关的类中出现了重复的相同功能的函数，就应该考虑新建一个独立的类将这个重复的函数提炼出去。&lt;/li&gt;
&lt;li&gt;过长函数：写代码的过程中，有一个原则。&lt;strong&gt;代码块越小，代码的功能就越容易管理，代码的处理和移动也就越轻松。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;过大的类：一个类的代码太多的话，最后就会变成一坨，嗯。尽量将特别大的类进行分解。&lt;/li&gt;
&lt;li&gt;过长的参数列:拆成bean。&lt;/li&gt;
&lt;li&gt;switch泛滥：作者的建议是少用switch，在使用switch的地方考虑使用多态来解决。&lt;/li&gt;
&lt;li&gt;数据泥团：数据成群的绑在一起。正确的做法是将总是绑定在一起的数据放到一个对象里。&lt;/li&gt;
&lt;li&gt;发散式变化：多种变化都对应同一个类的修改。这种情况下需要考虑将这个类拆开，尽量每种变化只对应一个类的修改。&lt;/li&gt;
&lt;li&gt;霰弹式修改：这个类一旦变化，会引发多个类的修改。这种情况下应该尽量将所有需要修改的方法放到一个类里。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;2-重新组织函数&quot;&gt;&lt;a href=&quot;#2-重新组织函数&quot; class=&quot;headerlink&quot; title=&quot;2. 重新组织函数&quot;&gt;&lt;/a&gt;2. 重新组织函数&lt;/h2&gt;&lt;h3 id=&quot;2-1-extract-method（提炼函数）&quot;&gt;&lt;a href=&quot;#2-1-extract-method（提炼函数）&quot; class=&quot;headerlink&quot; title=&quot;2.1 extract method（提炼函数）&quot;&gt;&lt;/a&gt;2.1 extract method（提炼函数）&lt;/h3&gt;&lt;p&gt;1) 没有局部变量，直接提炼。&lt;br&gt;2) 有局部变量，把这个局部变量作为参数传入被提炼函数&lt;br&gt;3) 如果需要对局部变量赋值，得需要使用remove Assignments to parameters.如果被赋值的局部变量只在被提炼的函数中被赋值，则把这个局部变量声明到被提炼函数中。如果被赋值的局部变量需要在被提炼的函数其它的地方使用，则需要被提炼函数返回一个被修改后的值。如果遇到返回的不止一个值，则最好的方法是再重新提炼一个新的方法，每次只返回一个值最佳。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;before&lt;/code&gt;:&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;printOwing&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; amount)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    printBanner();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//print details&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;amount:&quot;&lt;/span&gt;+amount);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;after&lt;/code&gt;:&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;printOwing&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; amount)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    printBanner();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    printDetails(amount);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;printDetails&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; amount)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;amount:&quot;&lt;/span&gt;+amount);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="重构" scheme="http://yvshuo.github.io/tags/%E9%87%8D%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>git知识备忘</title>
    <link href="http://yvshuo.github.io/2017/01/11/2017-01-11-review-git/"/>
    <id>http://yvshuo.github.io/2017/01/11/2017-01-11-review-git/</id>
    <published>2017-01-11T12:23:51.000Z</published>
    <updated>2017-01-11T13:11:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>单位用的svn，一个多月不用git，发现有些命令就忘了- -所以这是一篇git操作备忘。主要内容转载自<a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html" target="_blank" rel="external">常用 Git 命令清单</a>。</p>
<h2 id="1-git基本示意"><a href="#1-git基本示意" class="headerlink" title="1. git基本示意"></a>1. git基本示意</h2><p><img src="/assets/images/2017/01/11/1.png" alt="git示意图"></p>
<blockquote>
<ul>
<li>Workspace：工作区</li>
<li>Index / Stage：暂存区</li>
<li>Repository：仓库区（或本地仓库）</li>
<li>Remote：远程仓库</li>
</ul>
</blockquote>
<h2 id="2-常用操作命令"><a href="#2-常用操作命令" class="headerlink" title="2. 常用操作命令"></a>2. 常用操作命令</h2><h3 id="2-1-新建代码库"><a href="#2-1-新建代码库" class="headerlink" title="2.1 新建代码库"></a>2.1 新建代码库</h3><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 在当前目录新建一个Git代码库</span></div><div class="line">$ git init</div><div class="line"><span class="comment"># 新建一个目录，将其初始化为Git代码库</span></div><div class="line">$ git init [project-name]</div><div class="line"><span class="comment"># 下载一个项目和它的整个代码历史</span></div><div class="line">$ git <span class="built_in">clone</span> [url]</div></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="2-2-配置"><a href="#2-2-配置" class="headerlink" title="2.2 配置"></a>2.2 配置</h3><p>Git的设置文件为<code>.gitconfig</code>，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 显示当前的Git配置</span></div><div class="line">$ git config --list</div><div class="line"><span class="comment"># 编辑Git配置文件</span></div><div class="line">$ git config <span class="_">-e</span> [--global]</div><div class="line"><span class="comment"># 设置提交代码时的用户信息</span></div><div class="line">$ git config [--global] user.name <span class="string">"[name]"</span></div><div class="line">$ git config [--global] user.email <span class="string">"[email address]"</span></div></pre></td></tr></table></figure></p>
<h3 id="2-3-增加-删除文件"><a href="#2-3-增加-删除文件" class="headerlink" title="2.3 增加/删除文件"></a>2.3 增加/删除文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 添加指定文件到暂存区</span></div><div class="line">$ git add [file1] [file2] ...</div><div class="line"><span class="comment"># 添加指定目录到暂存区，包括子目录</span></div><div class="line">$ git add [dir]</div><div class="line"><span class="comment"># 添加当前目录的所有文件到暂存区</span></div><div class="line">$ git add .</div><div class="line"><span class="comment"># 添加每个变化前，都会要求确认</span></div><div class="line"><span class="comment"># 对于同一个文件的多处变化，可以实现分次提交</span></div><div class="line">$ git add -p</div><div class="line"><span class="comment"># 删除工作区文件，并且将这次删除放入暂存区</span></div><div class="line">$ git rm [file1] [file2] ...</div><div class="line"><span class="comment"># 停止追踪指定文件，但该文件会保留在工作区</span></div><div class="line">$ git rm --cached [file]</div><div class="line"><span class="comment"># 改名文件，并且将这个改名放入暂存区</span></div><div class="line">$ git mv [file-original] [file-renamed]</div></pre></td></tr></table></figure>
<h3 id="2-4-代码提交"><a href="#2-4-代码提交" class="headerlink" title="2.4 代码提交"></a>2.4 代码提交</h3><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 提交暂存区到仓库区</span></div><div class="line">$ git commit -m [message]</div><div class="line"><span class="comment"># 提交暂存区的指定文件到仓库区</span></div><div class="line">$ git commit [file1] [file2] ... -m [message]</div><div class="line"><span class="comment"># 提交工作区自上次commit之后的变化，直接到仓库区</span></div><div class="line">$ git commit <span class="_">-a</span></div><div class="line"><span class="comment"># 提交时显示所有diff信息</span></div><div class="line">$ git commit -v</div><div class="line"><span class="comment"># 使用一次新的commit，替代上一次提交</span></div><div class="line"><span class="comment"># 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span></div><div class="line">$ git commit --amend -m [message]</div><div class="line"><span class="comment"># 重做上一次commit，并包括指定文件的新变化</span></div><div class="line">$ git commit --amend [file1] [file2] ...</div></pre></td></tr></table></figure>
<h3 id="2-5-分支"><a href="#2-5-分支" class="headerlink" title="2.5 分支"></a>2.5 分支</h3><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 列出所有本地分支</span></div><div class="line">$ git branch</div><div class="line"><span class="comment"># 列出所有远程分支</span></div><div class="line">$ git branch -r</div><div class="line"><span class="comment"># 列出所有本地分支和远程分支</span></div><div class="line">$ git branch <span class="_">-a</span></div><div class="line"><span class="comment"># 新建一个分支，但依然停留在当前分支</span></div><div class="line">$ git branch [branch-name]</div><div class="line"><span class="comment"># 新建一个分支，并切换到该分支</span></div><div class="line">$ git checkout -b [branch]</div><div class="line"><span class="comment"># 新建一个分支，指向指定commit</span></div><div class="line">$ git branch [branch] [commit]</div><div class="line"><span class="comment"># 新建一个分支，与指定的远程分支建立追踪关系</span></div><div class="line">$ git branch --track [branch] [remote-branch]</div><div class="line"><span class="comment"># 切换到指定分支，并更新工作区</span></div><div class="line">$ git checkout [branch-name]</div><div class="line"><span class="comment"># 切换到上一个分支</span></div><div class="line">$ git checkout -</div><div class="line"><span class="comment"># 建立追踪关系，在现有分支与指定的远程分支之间</span></div><div class="line">$ git branch --set-upstream [branch] [remote-branch]</div><div class="line"><span class="comment"># 合并指定分支到当前分支</span></div><div class="line">$ git merge [branch]</div><div class="line"><span class="comment"># 选择一个commit，合并进当前分支</span></div><div class="line">$ git cherry-pick [commit]</div><div class="line"><span class="comment"># 删除分支</span></div><div class="line">$ git branch <span class="_">-d</span> [branch-name]</div><div class="line"><span class="comment"># 删除远程分支</span></div><div class="line">$ git push origin --delete [branch-name]</div><div class="line">$ git branch -dr [remote/branch]</div></pre></td></tr></table></figure>
<h3 id="2-6-标签"><a href="#2-6-标签" class="headerlink" title="2.6 标签"></a>2.6 标签</h3><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 列出所有tag</span></div><div class="line">$ git tag</div><div class="line"><span class="comment"># 新建一个tag在当前commit</span></div><div class="line">$ git tag [tag]</div><div class="line"><span class="comment"># 新建一个tag在指定commit</span></div><div class="line">$ git tag [tag] [commit]</div><div class="line"><span class="comment"># 删除本地tag</span></div><div class="line">$ git tag <span class="_">-d</span> [tag]</div><div class="line"><span class="comment"># 删除远程tag</span></div><div class="line">$ git push origin :refs/tags/[tagName]</div><div class="line"><span class="comment"># 查看tag信息</span></div><div class="line">$ git show [tag]</div><div class="line"><span class="comment"># 提交指定tag</span></div><div class="line">$ git push [remote] [tag]</div><div class="line"><span class="comment"># 提交所有tag</span></div><div class="line">$ git push [remote] --tags</div><div class="line"><span class="comment"># 新建一个分支，指向某个tag</span></div><div class="line">$ git checkout -b [branch] [tag]</div></pre></td></tr></table></figure>
<h3 id="2-7-查看信息"><a href="#2-7-查看信息" class="headerlink" title="2.7 查看信息"></a>2.7 查看信息</h3><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 显示有变更的文件</span></div><div class="line">$ git status</div><div class="line"><span class="comment"># 显示当前分支的版本历史</span></div><div class="line">$ git <span class="built_in">log</span></div><div class="line"><span class="comment"># 显示commit历史，以及每次commit发生变更的文件</span></div><div class="line">$ git <span class="built_in">log</span> --stat</div><div class="line"><span class="comment"># 搜索提交历史，根据关键词</span></div><div class="line">$ git <span class="built_in">log</span> -S [keyword]</div><div class="line"><span class="comment"># 显示某个commit之后的所有变动，每个commit占据一行</span></div><div class="line">$ git <span class="built_in">log</span> [tag] HEAD --pretty=format:%s</div><div class="line"><span class="comment"># 显示某个commit之后的所有变动，其"提交说明"必须符合搜索条件</span></div><div class="line">$ git <span class="built_in">log</span> [tag] HEAD --grep feature</div><div class="line"><span class="comment"># 显示某个文件的版本历史，包括文件改名</span></div><div class="line">$ git <span class="built_in">log</span> --follow [file]</div><div class="line">$ git whatchanged [file]</div><div class="line"><span class="comment"># 显示指定文件相关的每一次diff</span></div><div class="line">$ git <span class="built_in">log</span> -p [file]</div><div class="line"><span class="comment"># 显示过去5次提交</span></div><div class="line">$ git <span class="built_in">log</span> -5 --pretty --oneline</div><div class="line"><span class="comment"># 显示所有提交过的用户，按提交次数排序</span></div><div class="line">$ git shortlog -sn</div><div class="line"><span class="comment"># 显示指定文件是什么人在什么时间修改过</span></div><div class="line">$ git blame [file]</div><div class="line"><span class="comment"># 显示暂存区和工作区的差异</span></div><div class="line">$ git diff</div><div class="line"><span class="comment"># 显示暂存区和上一个commit的差异</span></div><div class="line">$ git diff --cached [file]</div><div class="line"><span class="comment"># 显示工作区与当前分支最新commit之间的差异</span></div><div class="line">$ git diff HEAD</div><div class="line"><span class="comment"># 显示两次提交之间的差异</span></div><div class="line">$ git diff [first-branch]...[second-branch]</div><div class="line"><span class="comment"># 显示今天你写了多少行代码</span></div><div class="line">$ git diff --shortstat <span class="string">"@&#123;0 day ago&#125;"</span></div><div class="line"><span class="comment"># 显示某次提交的元数据和内容变化</span></div><div class="line">$ git show [commit]</div><div class="line"><span class="comment"># 显示某次提交发生变化的文件</span></div><div class="line">$ git show --name-only [commit]</div><div class="line"><span class="comment"># 显示某次提交时，某个文件的内容</span></div><div class="line">$ git show [commit]:[filename]</div><div class="line"><span class="comment"># 显示当前分支的最近几次提交</span></div><div class="line">$ git reflog</div></pre></td></tr></table></figure>
<h3 id="2-8-远程同步"><a href="#2-8-远程同步" class="headerlink" title="2.8 远程同步"></a>2.8 远程同步</h3><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 下载远程仓库的所有变动</span></div><div class="line">$ git fetch [remote]</div><div class="line"><span class="comment"># 显示所有远程仓库</span></div><div class="line">$ git remote -v</div><div class="line"><span class="comment"># 显示某个远程仓库的信息</span></div><div class="line">$ git remote show [remote]</div><div class="line"><span class="comment"># 增加一个新的远程仓库，并命名</span></div><div class="line">$ git remote add [shortname] [url]</div><div class="line"><span class="comment"># 取回远程仓库的变化，并与本地分支合并</span></div><div class="line">$ git pull [remote] [branch]</div><div class="line"><span class="comment"># 上传本地指定分支到远程仓库</span></div><div class="line">$ git push [remote] [branch]</div><div class="line"><span class="comment"># 强行推送当前分支到远程仓库，即使有冲突</span></div><div class="line">$ git push [remote] --force</div><div class="line"><span class="comment"># 推送所有分支到远程仓库</span></div><div class="line">$ git push [remote] --all</div></pre></td></tr></table></figure>
<h3 id="2-9-撤销"><a href="#2-9-撤销" class="headerlink" title="2.9 撤销"></a>2.9 撤销</h3><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 恢复暂存区的指定文件到工作区</span></div><div class="line">$ git checkout [file]</div><div class="line"><span class="comment"># 恢复某个commit的指定文件到暂存区和工作区</span></div><div class="line">$ git checkout [commit] [file]</div><div class="line"><span class="comment"># 恢复暂存区的所有文件到工作区</span></div><div class="line">$ git checkout .</div><div class="line"><span class="comment"># 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span></div><div class="line">$ git reset [file]</div><div class="line"><span class="comment"># 重置暂存区与工作区，与上一次commit保持一致</span></div><div class="line">$ git reset --hard</div><div class="line"><span class="comment"># 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span></div><div class="line">$ git reset [commit]</div><div class="line"><span class="comment"># 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span></div><div class="line">$ git reset --hard [commit]</div><div class="line"><span class="comment"># 重置当前HEAD为指定commit，但保持暂存区和工作区不变</span></div><div class="line">$ git reset --keep [commit]</div><div class="line"><span class="comment"># 新建一个commit，用来撤销指定commit</span></div><div class="line"><span class="comment"># 后者的所有变化都将被前者抵消，并且应用到当前分支</span></div><div class="line">$ git revert [commit]</div><div class="line"><span class="comment"># 暂时将未提交的变化移除，稍后再移入</span></div><div class="line">$ git stash</div><div class="line">$ git stash pop</div></pre></td></tr></table></figure>
<h3 id="2-10-其他"><a href="#2-10-其他" class="headerlink" title="2.10 其他"></a>2.10 其他</h3><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 生成一个可供发布的压缩包</span></div><div class="line">$ git archive</div></pre></td></tr></table></figure>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h2><p>嗯，看来我是有一段时间没有抽时间好好学习了~最近在读一本讲java重构的书~回头写个读书笔记→_→</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;单位用的svn，一个多月不用git，发现有些命令就忘了- -所以这是一篇git操作备忘。主要内容转载自&lt;a href=&quot;http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html&quot;&gt;常用 Git 命令清单&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;1-git基本示意&quot;&gt;&lt;a href=&quot;#1-git基本示意&quot; class=&quot;headerlink&quot; title=&quot;1. git基本示意&quot;&gt;&lt;/a&gt;1. git基本示意&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/assets/images/2017/01/11/1.png&quot; alt=&quot;git示意图&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Workspace：工作区&lt;/li&gt;
&lt;li&gt;Index / Stage：暂存区&lt;/li&gt;
&lt;li&gt;Repository：仓库区（或本地仓库）&lt;/li&gt;
&lt;li&gt;Remote：远程仓库&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;2-常用操作命令&quot;&gt;&lt;a href=&quot;#2-常用操作命令&quot; class=&quot;headerlink&quot; title=&quot;2. 常用操作命令&quot;&gt;&lt;/a&gt;2. 常用操作命令&lt;/h2&gt;&lt;h3 id=&quot;2-1-新建代码库&quot;&gt;&lt;a href=&quot;#2-1-新建代码库&quot; class=&quot;headerlink&quot; title=&quot;2.1 新建代码库&quot;&gt;&lt;/a&gt;2.1 新建代码库&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 在当前目录新建一个Git代码库&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;$ git init&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 新建一个目录，将其初始化为Git代码库&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;$ git init [project-name]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 下载一个项目和它的整个代码历史&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;$ git &lt;span class=&quot;built_in&quot;&gt;clone&lt;/span&gt; [url]&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="git" scheme="http://yvshuo.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序初体验</title>
    <link href="http://yvshuo.github.io/2016/11/27/2016-11-27-wxapp/"/>
    <id>http://yvshuo.github.io/2016/11/27/2016-11-27-wxapp/</id>
    <published>2016-11-27T03:03:47.000Z</published>
    <updated>2017-02-10T10:46:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>p.s. 这篇文章是一个月之前写的，因为最近忙于其他项目，所以一直没来维护这个博客~微信小程序貌似也有了新的更新。先把这篇贴上，后续填坑23333</p>
<p>利用周末时间基于cnode社区的api撸了一发微信小程序，记录一下。</p>
<h3 id="1、开发环境"><a href="#1、开发环境" class="headerlink" title="1、开发环境"></a>1、开发环境</h3><p>微信mac版开发工具0.11.112301<br>下载地址：<a href="https://servicewechat.com/wxa-dev-logic/download_redirect?type=darwin&amp;from=mpwiki&amp;t=20161122" target="_blank" rel="external">使劲戳我</a><br>其他版本下载地址：<a href="https://mp.weixin.qq.com/debug/wxadoc/dev/devtools/download.html?t=20161122" target="_blank" rel="external">继续戳我</a></p>
<h3 id="2、项目创建"><a href="#2、项目创建" class="headerlink" title="2、项目创建"></a>2、项目创建</h3><p>扫码登录后按下图输入创建项目<br><img src="/assets/images/2016/11/27/1.png" alt=""></p>
<p>创建项目后界面的样子和默认的文件目录结构<br><img src="/assets/images/2016/11/27/2.png" alt=""></p>
<p>分析下目录结构<br><img src="/assets/images/2016/11/27/3.png" alt=""><br><code>pages</code>目录下有两个页面，<code>index</code>和<code>logs</code>。<code>.js</code>文件是负责处理该页面的逻辑，<code>.wxml</code>负责视图以及绑定一些交互事件，<code>.wxss</code>来写css样式，<code>.json</code>用来配置一些配置参数或者定义一些静态常量。<br><code>utils</code>目录下是一个工具类。根目录下的<code>app.js</code>是小程序的入口文件，用来注册app。<code>app.json</code>可以用来配置全局常量，<code>app.wxss</code>用来配置项目的公用样式。</p>
<p>初始程序提供了一个从<code>index</code>页面到<code>logs</code>页面的跳转<br><img src="/assets/images/2016/11/27/4.png" alt=""><br><code>index.wxml</code>中绑定的<code>bindViewTab</code>函数就是前面在<code>index.js</code>中标出的那个函数。函数中调用微信小程序的api定义了一个跳转<br><figure class="highlight js"><table><tr><td class="code"><pre><div class="line">bindViewTap: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    wx.navigateTo(&#123;</div><div class="line">      <span class="attr">url</span>: <span class="string">'../logs/logs'</span></div><div class="line">    &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>另外，在<code>logs.js</code>中调用了一下微信的api<code>wx.getStorageSync(KEY)</code>从本地缓存中同步获取指定key对应的内容。<br><figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">//app.js</span></div><div class="line">onLaunch: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">//调用API从本地缓存中获取数据</span></div><div class="line">  <span class="keyword">var</span> logs = wx.getStorageSync(<span class="string">'logs'</span>) || []</div><div class="line">  logs.unshift(<span class="built_in">Date</span>.now())</div><div class="line">  wx.setStorageSync(<span class="string">'logs'</span>, logs)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在小程序启动的时候就会在本地存储的<code>logs</code>中记录下当前时间，添加到数组的最前面。<br>所以每次重新启动小程序后在<code>logs</code>页面就会加一条数据。<br>重新启动前：<br><img src="/assets/images/2016/11/27/5.png" alt=""><br>重新启动后:<br><img src="/assets/images/2016/11/27/6.png" alt=""></p>
<h3 id="3、组件介绍"><a href="#3、组件介绍" class="headerlink" title="3、组件介绍"></a>3、组件介绍</h3><p>组件就是视图层的基本组成单元，简单的理解就是微信小程序提供的一些标签库，通过使用这些组件，可以快速搭建自带一些微信基本风格的视图。<br>官方说明文档：<a href="https://mp.weixin.qq.com/debug/wxadoc/dev/component/?t=20161122" target="_blank" rel="external">请大力戳我</a><br><figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="comment">&lt;!--logs.wxml--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"container log-list"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">block</span> <span class="attr">wx:for</span>=<span class="string">"&#123;&#123;logs&#125;&#125;"</span> <span class="attr">wx:for-item</span>=<span class="string">"log"</span> <span class="attr">wx:key</span>=<span class="string">"*this"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">text</span> <span class="attr">class</span>=<span class="string">"log-item"</span>&gt;</span>&#123;&#123;index + 1&#125;&#125;. &#123;&#123;log&#125;&#125;<span class="tag">&lt;/<span class="name">text</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">block</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>上面代码中的<code>view</code>标签和<code>text</code>标签就是组件，<code>view</code>是一个视图容器，支持嵌套。<code>text</code>就是一个文本组件。<br><figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="comment">&lt;!--index.wxml--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">view</span>  <span class="attr">bindtap</span>=<span class="string">"bindViewTap"</span> <span class="attr">class</span>=<span class="string">"userinfo"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">image</span> <span class="attr">class</span>=<span class="string">"userinfo-avatar"</span> <span class="attr">src</span>=<span class="string">"&#123;&#123;userInfo.avatarUrl&#125;&#125;"</span> <span class="attr">background-size</span>=<span class="string">"cover"</span>&gt;</span><span class="tag">&lt;/<span class="name">image</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">text</span> <span class="attr">class</span>=<span class="string">"userinfo-nickname"</span>&gt;</span>&#123;&#123;userInfo.nickName&#125;&#125;<span class="tag">&lt;/<span class="name">text</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">view</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"usermotto"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">text</span> <span class="attr">class</span>=<span class="string">"user-motto"</span>&gt;</span>&#123;&#123;motto&#125;&#125;<span class="tag">&lt;/<span class="name">text</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">view</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>这个就是在一个父<code>view</code>中嵌套了两个子<code>view</code>。<br>在<code>logs.wxml</code>中还有一个地方，就是<code>block</code>标签，这个是小程序框架中提供的一个包装元素，它不是一个组件，不会在页面中做任何渲染，只会接受基本的控制属性。</p>
<h3 id="4、API介绍"><a href="#4、API介绍" class="headerlink" title="4、API介绍"></a>4、API介绍</h3><p>小程序的框架提供了很多微信原生的API，可以方便的调起微信提供的能力，如获取用户信息，本地存储，支付功能等。<br>官方文档：<a href="https://mp.weixin.qq.com/debug/wxadoc/dev/api/?t=20161122" target="_blank" rel="external">不要停，继续戳</a><br>截止到目前，微信小程序提供了7大类API，网络、媒体、数据、位置、设备、界面、开放接口。<br>个人比较感兴趣的就是媒体类的API，提供了大量基于微信原生的丰富功能。看到了一个打开文档的接口<code>wx.openDocument(OBJECT)</code>，感觉可以基于这个接口开发一个管理微信聊天中发布的文档的小应用，然后需要的时候拿出来读~以后就再也不需要翻聊天记录翻来翻去了~因吹思婷！<br>另外界面API也很喜欢，一直以来都非常喜欢微信的UI设计，读了小程序的设计指南之后更是觉得微信的设计团队好厉害。<br>小程序的设计指南：<a href="https://mp.weixin.qq.com/debug/wxadoc/design/index.html?t=20161122" target="_blank" rel="external">戳吧</a><br>至于开放接口的API，个人感觉这块文档还很乱，另外个人开发者好像不能用。学习的时候感觉非常的蛋疼。希望能提供一个供学习的沙盒接口，同时完善下教程。</p>
<h3 id="5、开始撸代码"><a href="#5、开始撸代码" class="headerlink" title="5、开始撸代码"></a>5、开始撸代码</h3><p>首先放上cnode社区的API文档：<a href="https://cnodejs.org/api" target="_blank" rel="external">感谢cnode社区，请戳我</a><br>这里有个微信开发者工具的BUG，开发过程中发现我修改的代码始终处于一种缓存状态，修改的代码没法更新上去。选择了清除文件缓存和数据缓存，包括重启等方法均不行。<br><img src="/assets/images/2016/11/27/7.png" alt=""><br>嗯。。最后发现默认的这个代码热更新有BUG，导致了以上问题。如果还是发现代码不能更新的话，切换下这个选项框的选择状态就可以刷新项目了。</p>
<h4 id="5-1-配置"><a href="#5-1-配置" class="headerlink" title="5.1 配置"></a>5.1 配置</h4><p>使用根目录下的app.json来进行全局配置。<br><figure class="highlight json"><table><tr><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"pages"</span>: [</div><div class="line">    <span class="string">"pages/index/index"</span>,</div><div class="line">    <span class="string">"pages/logs/index"</span></div><div class="line">  ],</div><div class="line">  <span class="attr">"window"</span>: &#123;</div><div class="line">    <span class="attr">"navigationBarTitleText"</span>: <span class="string">"Demo"</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">"tabBar"</span>: &#123;</div><div class="line">    <span class="attr">"list"</span>: [&#123;</div><div class="line">      <span class="attr">"pagePath"</span>: <span class="string">"pages/index/index"</span>,</div><div class="line">      <span class="attr">"text"</span>: <span class="string">"首页"</span></div><div class="line">    &#125;, &#123;</div><div class="line">      <span class="attr">"pagePath"</span>: <span class="string">"pages/logs/logs"</span>,</div><div class="line">      <span class="attr">"text"</span>: <span class="string">"日志"</span></div><div class="line">    &#125;]</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">"networkTimeout"</span>: &#123;</div><div class="line">    <span class="attr">"request"</span>: <span class="number">10000</span>,</div><div class="line">    <span class="attr">"downloadFile"</span>: <span class="number">10000</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">"debug"</span>: <span class="literal">true</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>下面给出各个配置项的说明：</p>
<table>
<thead>
<tr>
<th style="text-align:center">属性</th>
<th style="text-align:center">类型</th>
<th style="text-align:center">必填</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">pages</td>
<td style="text-align:center">String Array</td>
<td style="text-align:center">是</td>
<td style="text-align:center">设置页面路径</td>
</tr>
<tr>
<td style="text-align:center">window</td>
<td style="text-align:center">Object</td>
<td style="text-align:center">否</td>
<td style="text-align:center">设置默认页面的窗口表现</td>
</tr>
<tr>
<td style="text-align:center">tabBar</td>
<td style="text-align:center">Object</td>
<td style="text-align:center">否</td>
<td style="text-align:center">设置底部 tab 的表现</td>
</tr>
<tr>
<td style="text-align:center">networkTimeout</td>
<td style="text-align:center">Object</td>
<td style="text-align:center">否</td>
<td style="text-align:center">设置网络超时时间</td>
</tr>
<tr>
<td style="text-align:center">debug</td>
<td style="text-align:center">Boolean</td>
<td style="text-align:center">否</td>
<td style="text-align:center">设置是否开启 debug 模式</td>
</tr>
</tbody>
</table>
<p>除了pages外其他几个属性都不是必须的。tabBar可以页面上方或者下方添加tab选项卡，最少2个选项卡，最多5个选项卡。每个选项的配置项都可以在<a href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/config.html" target="_blank" rel="external"><strong> 这里 </strong></a>查到，不再赘述。</p>
<h4 id="5-2-注册APP"><a href="#5-2-注册APP" class="headerlink" title="5.2 注册APP"></a>5.2 注册APP</h4><p>微信小程序是在根目录的app.js里通过App()函数来注册小程序的。这个函数可以接收一个object参数，指定小程序的生命周期函数等。</p>
<table>
<thead>
<tr>
<th style="text-align:center">属性</th>
<th style="text-align:center">类型</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">触发时机</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">onLaunch</td>
<td style="text-align:center">Function</td>
<td style="text-align:center">监听小程序初始化</td>
<td style="text-align:center">当小程序初始化完成时，会触发 onLaunch（全局只触发一次）</td>
</tr>
<tr>
<td style="text-align:center">onShow</td>
<td style="text-align:center">Function</td>
<td style="text-align:center">监听小程序显示</td>
<td style="text-align:center">当小程序启动，或从后台进入前台显示，会触发 onShow</td>
</tr>
<tr>
<td style="text-align:center">onHide</td>
<td style="text-align:center">Function</td>
<td style="text-align:center">监听小程序隐藏</td>
<td style="text-align:center">当小程序从前台进入后台，会触发 onHide</td>
</tr>
<tr>
<td style="text-align:center">其他</td>
<td style="text-align:center">Any</td>
<td style="text-align:center">开发者可以添加任意的函数或数据到 Object 参数中，用 this 可以访问</td>
<td style="text-align:center">-</td>
</tr>
</tbody>
</table>
<p>所以可以在这里配一些全局的静态参数什么的~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;p.s. 这篇文章是一个月之前写的，因为最近忙于其他项目，所以一直没来维护这个博客~微信小程序貌似也有了新的更新。先把这篇贴上，后续填坑23333&lt;/p&gt;
&lt;p&gt;利用周末时间基于cnode社区的api撸了一发微信小程序，记录一下。&lt;/p&gt;
&lt;h3 id=&quot;1、开发环境&quot;&gt;&lt;a href=&quot;#1、开发环境&quot; class=&quot;headerlink&quot; title=&quot;1、开发环境&quot;&gt;&lt;/a&gt;1、开发环境&lt;/h3&gt;&lt;p&gt;微信mac版开发工具0.11.112301&lt;br&gt;下载地址：&lt;a href=&quot;https://servicewechat.com/wxa-dev-logic/download_redirect?type=darwin&amp;amp;from=mpwiki&amp;amp;t=20161122&quot;&gt;使劲戳我&lt;/a&gt;&lt;br&gt;其他版本下载地址：&lt;a href=&quot;https://mp.weixin.qq.com/debug/wxadoc/dev/devtools/download.html?t=20161122&quot;&gt;继续戳我&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;2、项目创建&quot;&gt;&lt;a href=&quot;#2、项目创建&quot; class=&quot;headerlink&quot; title=&quot;2、项目创建&quot;&gt;&lt;/a&gt;2、项目创建&lt;/h3&gt;&lt;p&gt;扫码登录后按下图输入创建项目&lt;br&gt;&lt;img src=&quot;/assets/images/2016/11/27/1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;创建项目后界面的样子和默认的文件目录结构&lt;br&gt;&lt;img src=&quot;/assets/images/2016/11/27/2.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;分析下目录结构&lt;br&gt;&lt;img src=&quot;/assets/images/2016/11/27/3.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;code&gt;pages&lt;/code&gt;目录下有两个页面，&lt;code&gt;index&lt;/code&gt;和&lt;code&gt;logs&lt;/code&gt;。&lt;code&gt;.js&lt;/code&gt;文件是负责处理该页面的逻辑，&lt;code&gt;.wxml&lt;/code&gt;负责视图以及绑定一些交互事件，&lt;code&gt;.wxss&lt;/code&gt;来写css样式，&lt;code&gt;.json&lt;/code&gt;用来配置一些配置参数或者定义一些静态常量。&lt;br&gt;&lt;code&gt;utils&lt;/code&gt;目录下是一个工具类。根目录下的&lt;code&gt;app.js&lt;/code&gt;是小程序的入口文件，用来注册app。&lt;code&gt;app.json&lt;/code&gt;可以用来配置全局常量，&lt;code&gt;app.wxss&lt;/code&gt;用来配置项目的公用样式。&lt;/p&gt;
&lt;p&gt;初始程序提供了一个从&lt;code&gt;index&lt;/code&gt;页面到&lt;code&gt;logs&lt;/code&gt;页面的跳转&lt;br&gt;&lt;img src=&quot;/assets/images/2016/11/27/4.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;code&gt;index.wxml&lt;/code&gt;中绑定的&lt;code&gt;bindViewTab&lt;/code&gt;函数就是前面在&lt;code&gt;index.js&lt;/code&gt;中标出的那个函数。函数中调用微信小程序的api定义了一个跳转&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;bindViewTap: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    wx.navigateTo(&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;attr&quot;&gt;url&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;../logs/logs&#39;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="微信小程序" scheme="http://yvshuo.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>使用ESLint检查语法和代码风格</title>
    <link href="http://yvshuo.github.io/2016/11/15/2016-11-15-eslint/"/>
    <id>http://yvshuo.github.io/2016/11/15/2016-11-15-eslint/</id>
    <published>2016-11-15T13:37:39.000Z</published>
    <updated>2016-11-15T15:29:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>在学习ECMAScript6的过程中发现了一个代码风格和语法的检查工具，<a href="http://eslint.org/docs/user-guide/command-line-interface" target="_blank" rel="external">ESLint</a>，记录一下。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>这里记录的安装方法是通过npm的安装，所以前提条件是已经安装了npm。如果没有安装的话，建议直接安装nvm，可以方便的切换node的版本。<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">npm i -g eslint</div></pre></td></tr></table></figure></p>
<p>通过以上命令即可完成eslint CLI的安装。</p>
<a id="more"></a>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>ESLint的运行格式如下：<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">eslint [options] [file|dir|glob]*</div></pre></td></tr></table></figure></p>
<p>以下的几种方式都是可行的：<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">eslint file1.js file2.js</div><div class="line">eslint lib/**</div><div class="line">eslint <span class="string">"lib/**"</span></div></pre></td></tr></table></figure></p>
<h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><p>以下的内容可以通过eslint -h来查阅<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">eslint [options] file.js [file.js] [dir]</div><div class="line">Basic configuration:</div><div class="line">  -c, --config path::String    Use configuration from this file or shareable config</div><div class="line">  --no-eslintrc                Disable use of configuration from .eslintrc</div><div class="line">  --env [String]               Specify environments</div><div class="line">  --ext [String]               Specify JavaScript file extensions - default: .js</div><div class="line">  --global [String]            Define global variables</div><div class="line">  --parser String              Specify the parser to be used</div><div class="line">  --parser-options Object      Specify parser options</div><div class="line">Caching:</div><div class="line">  --cache                      Only check changed files - default: <span class="literal">false</span></div><div class="line">  --cache-file path::String    Path to the cache file. Deprecated: use --cache-location - default: .eslintcache</div><div class="line">  --cache-location path::String  Path to the cache file or directory</div><div class="line">Specifying rules and plugins:</div><div class="line">  --rulesdir [path::String]    Use additional rules from this directory</div><div class="line">  --plugin [String]            Specify plugins</div><div class="line">  --rule Object                Specify rules</div><div class="line">Ignoring files:</div><div class="line">  --ignore-path path::String   Specify path of ignore file</div><div class="line">  --no-ignore                  Disable use of ignore files and patterns</div><div class="line">  --ignore-pattern [String]    Pattern of files to ignore (<span class="keyword">in</span> addition to those <span class="keyword">in</span> .eslintignore)</div><div class="line">Using stdin:</div><div class="line">  --stdin                      Lint code provided on &lt;STDIN&gt; - default: <span class="literal">false</span></div><div class="line">  --stdin-filename String      Specify filename to process STDIN as</div><div class="line">Handling warnings:</div><div class="line">  --quiet                      Report errors only - default: <span class="literal">false</span></div><div class="line">  --max-warnings Int           Number of warnings to trigger nonzero <span class="built_in">exit</span> code - default: -1</div><div class="line">Output:</div><div class="line">  -o, --output-file path::String  Specify file to write report to</div><div class="line">  <span class="_">-f</span>, --format String          Use a specific output format - default: stylish</div><div class="line">  --color, --no-color          Force enabling/disabling of color</div><div class="line">Miscellaneous:</div><div class="line">  --init                       Run config initialization wizard - default: <span class="literal">false</span></div><div class="line">  --fix                        Automatically fix problems</div><div class="line">  --debug                      Output debugging information</div><div class="line">  -h, --help                   Show <span class="built_in">help</span></div><div class="line">  -v, --version                Output the version number</div><div class="line">  --no-inline-config           Prevent comments from changing config or rules</div><div class="line">  --print-config path::String  Print the configuration <span class="keyword">for</span> the given file</div></pre></td></tr></table></figure></p>
<p>例子：<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">eslint --ext .jsx --ext .js file.js</div><div class="line">eslint --ext .jsx,.js file.js</div></pre></td></tr></table></figure></p>
<h3 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h3><ul>
<li>-c,–config<br>这个选项能给ESLint指定一个附加的配置文件。<br><em>例子：</em><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">eslint -c ~/my-eslint.json file.js</div></pre></td></tr></table></figure>
</li>
</ul>
<p>这个例子使用<code>~/my-eslint.json</code>这个配置文件。<br>还有一种是使用共享的配置。<br><em>例子：</em><br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">eslint -c airbnb file.js</div></pre></td></tr></table></figure></p>
<p>这个例子使用的是<code>eslint-config-airbnb</code>的配置，使用之前需要安装。<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ npm i -g eslint-config-airbnb</div></pre></td></tr></table></figure></p>
<ul>
<li><p>–no-eslintrc<br>禁用<code>.eslintrc</code>和<code>package.json</code>中的配置<br><em>例子：</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">eslint --no-eslintrc file.js</div></pre></td></tr></table></figure>
</li>
<li><p>–env<br>指定特定的环境<br><em>例子：</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">eslint --env browser,node file.js</div><div class="line">eslint --env browser --env node file.js</div></pre></td></tr></table></figure>
</li>
<li><p>–ext<br>配置ESLint对哪些文件类型起作用<br><em>例子：</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 只对 .js2 后缀的文件类型起作用</span></div><div class="line">eslint . --ext .js2</div><div class="line"><span class="comment"># 对 .js 和 .js2 后缀的文件类型都起作用</span></div><div class="line">eslint . --ext .js --ext .js2</div><div class="line"><span class="comment"># 对 .js 和 .js2 后缀的文件类型都起作用</span></div><div class="line">eslint . --ext .js,.js2</div></pre></td></tr></table></figure>
</li>
<li><p>–ext<br>配置ESLint对哪些文件类型起作用<br><em>例子：</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 只对 .js2 后缀的文件类型起作用</span></div><div class="line">eslint . --ext .js2</div><div class="line"><span class="comment"># 对 .js 和 .js2 后缀的文件类型都起作用</span></div><div class="line">eslint . --ext .js --ext .js2</div><div class="line"><span class="comment"># 对 .js 和 .js2 后缀的文件类型都起作用</span></div><div class="line">eslint . --ext .js,.js2</div></pre></td></tr></table></figure>
</li>
<li><p>–global<br>设置全局参数<br><em>例子：</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">eslint --global require,exports:<span class="literal">true</span> file.js</div><div class="line">eslint --global require --global exports:<span class="literal">true</span></div></pre></td></tr></table></figure>
</li>
<li><p>–global<br>设置全局参数<br><em>例子：</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">eslint --global require,exports:<span class="literal">true</span> file.js</div><div class="line">eslint --global require --global exports:<span class="literal">true</span></div></pre></td></tr></table></figure>
</li>
<li><p>–plugin<br>设置需要载入的插件。设置前需要通过npm安装要载入的插件。<br><em>例子：</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">eslint --plugin jquery file.js</div><div class="line">eslint --plugin eslint-plugin-mocha file.js</div></pre></td></tr></table></figure>
</li>
<li><p>–rule<br>直接设置要使用的规则。<br><em>例子：</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">eslint --rule <span class="string">'quotes: [2, double]'</span></div><div class="line">eslint --rule <span class="string">'guard-for-in: 2'</span> --rule <span class="string">'brace-style: [2, 1tbs]'</span></div><div class="line">eslint --rule <span class="string">'jquery/dollar-sign: 2'</span></div></pre></td></tr></table></figure>
</li>
<li><p>–ignore-path<br>设置一个文件来代替<code>.eslintignore</code>的功能，如果不设置的话，eslint默认会使用当前工作空间的<code>.eslintignore</code><br><em>例子：</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">eslint --ignore-path tmp/.eslintignore file.js</div><div class="line">eslint --ignore-path .gitignore file.js</div></pre></td></tr></table></figure>
</li>
<li><p>–no-ignore<br>禁用<code>.eslintignore</code>, <code>--ignore-path</code>和<code>--ignore-pattern</code>中的例外情况<br><em>例子：</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">eslint --no-ignore file.js</div></pre></td></tr></table></figure>
</li>
<li><p>–ignore-pattern<br>设置忽略匹配指定正则类型的文件<br><em>例子：</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">eslint --ignore-pattern <span class="string">'/lib/'</span> --ignore-pattern <span class="string">'/src/vendor/*'</span> .</div></pre></td></tr></table></figure>
</li>
<li><p>–quiet<br>禁用reporting和warning，ESlint将只通知error<br><em>例子：</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">eslint --quiet file.js</div></pre></td></tr></table></figure>
</li>
<li><p>–max-warnings<br>设置eslint警告的临界值，在错误过多时强制eslint退出<br><em>例子：</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">eslint --max-warnings 10 file.js</div></pre></td></tr></table></figure>
</li>
<li><p>-o, –output-file<br>将report写进指定文件<br><em>例子：</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">eslint -o ./<span class="built_in">test</span>/test.html</div></pre></td></tr></table></figure>
</li>
<li><p>-f, –format<br>指定report输出的格式，可选格式为<code>checkstyle</code>，<code>codeframe</code>，<code>compact</code>，<code>html</code>，<code>jslint-xml</code>，<code>json</code>，<code>junit</code>，<code>stylish (the default)</code>，<code>table</code>，<code>tap</code>，<code>unix</code>，<code>visualstudio</code>。<br><em>例子：</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">eslint <span class="_">-f</span> compact file.js</div></pre></td></tr></table></figure>
</li>
<li><p>–color, –no-color<br>指定report的颜色<br><em>例子：</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">eslint --color file.js | cat</div><div class="line">eslint --no-color file.js</div></pre></td></tr></table></figure>
</li>
<li><p>init<br>初始化一些基本的配置。可以帮助新用户快速配置。</p>
</li>
<li><p>-h, –help<br>获得帮助菜单</p>
</li>
<li><p>-v, –version<br>显示当前的eslint版本</p>
</li>
<li><p>–print-config<br>打印当前eslint的配置信息</p>
</li>
<li><p>在<code>.eslintignore</code>中设置忽略的文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">node_modules/*</div><div class="line">**/vendor/*.js</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="实际例子"><a href="#实际例子" class="headerlink" title="实际例子"></a>实际例子</h3><p>在这个例子中使用<a href="https://github.com/airbnb/javascript" target="_blank" rel="external">Airbnb</a>的语法规则。安装Airbnb的语法规则：<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ npm i -g eslint-config-airbnb</div></pre></td></tr></table></figure></p>
<p>在项目的根目录下新建一个<code>.eslintrc</code>文件，配置ESLint。<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="string">"extends"</span>: <span class="string">"eslint-config-airbnb"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>待检查的<code>index.js</code>的代码如下：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> unusued = <span class="string">'I have no purpose!'</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> message = <span class="string">'Hello, World!'</span>;</div><div class="line">    alert(message);</div><div class="line">&#125;</div><div class="line">greet();</div></pre></td></tr></table></figure></p>
<p>使用ESLint检查这个文件<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ eslint index.js</div></pre></td></tr></table></figure></p>
<p>控制台输出：<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">index.js</div><div class="line">  1:5  error  unusued is defined but never used                 no-unused-vars</div><div class="line">  4:5  error  Expected indentation of 2 characters but found 4  indent</div><div class="line">  5:5  error  Expected indentation of 2 characters but found 4  indent</div><div class="line">✖ 3 problems (3 errors, 0 warnings)</div></pre></td></tr></table></figure></p>
<p>上面代码说明，原文件有三个错误，一个是定义了变量，却没有使用，另外两个是行首缩进为4个空格，而不是规定的2个空格。</p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><blockquote>
<p>1、<a href="http://eslint.org/docs/user-guide/command-line-interface" target="_blank" rel="external">ESLint Command Line Interface</a><br>2、<a href="http://es6.ruanyifeng.com/#docs/style#ESLint的使用" target="_blank" rel="external">ECMAScript 6 入门-编程风格-ESLint的使用</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在学习ECMAScript6的过程中发现了一个代码风格和语法的检查工具，&lt;a href=&quot;http://eslint.org/docs/user-guide/command-line-interface&quot;&gt;ESLint&lt;/a&gt;，记录一下。&lt;/p&gt;
&lt;h3 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h3&gt;&lt;p&gt;这里记录的安装方法是通过npm的安装，所以前提条件是已经安装了npm。如果没有安装的话，建议直接安装nvm，可以方便的切换node的版本。&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;npm i -g eslint&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;通过以上命令即可完成eslint CLI的安装。&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://yvshuo.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>webpack简介</title>
    <link href="http://yvshuo.github.io/2016/10/26/2016-10-26-webpacknote/"/>
    <id>http://yvshuo.github.io/2016/10/26/2016-10-26-webpacknote/</id>
    <published>2016-10-26T15:21:48.000Z</published>
    <updated>2016-11-03T14:13:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近一直在研究vue，顺带着研究了一下webpack。本文只是一篇简短的记录，后续会继续更新一些webpack深入的学习笔记。</p>
<h3 id="webpack概述"><a href="#webpack概述" class="headerlink" title="webpack概述"></a>webpack概述</h3><p>简单的说，webpack是一个前端的打包工具。它做的事情就是将你项目中使用的各种前端模块打包到一起，转换为合适的格式发布。通过使用webpack，可以将各种其他格式，如<code>scss</code>、<code>typescript</code>等拓展类型的语言转换为可运行的javascript。配合webpack的核心<code>loaders</code>和<code>plugins</code>，可以灵活的实现各种需求，非常的强力！<br><a id="more"></a><br>下面是一个典型的webpack的配置文件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</div><div class="line"><span class="keyword">var</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</div><div class="line"><span class="keyword">var</span> ExtractTextPlugin = <span class="built_in">require</span>(<span class="string">'extract-text-webpack-plugin'</span>);</div><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  <span class="attr">entry</span>: __dirname + <span class="string">"/app/main.js"</span>,</div><div class="line">  <span class="attr">output</span>: &#123;</div><div class="line">    <span class="attr">path</span>: __dirname + <span class="string">"/build"</span>,</div><div class="line">    <span class="attr">filename</span>: <span class="string">"[name]-[hash].js"</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">module</span>: &#123;</div><div class="line">    <span class="attr">loaders</span>: [</div><div class="line">      &#123;</div><div class="line">        <span class="attr">test</span>: <span class="regexp">/\.json$/</span>,</div><div class="line">        <span class="attr">loader</span>: <span class="string">"json"</span></div><div class="line">      &#125;,</div><div class="line">      &#123;</div><div class="line">        <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</div><div class="line">        <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>,</div><div class="line">        <span class="attr">loader</span>: <span class="string">'babel'</span></div><div class="line">      &#125;,</div><div class="line">      &#123;</div><div class="line">        <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</div><div class="line">        <span class="attr">loader</span>: ExtractTextPlugin.extract(<span class="string">'style'</span>, <span class="string">'css?modules!postcss'</span>)</div><div class="line">      &#125;</div><div class="line">    ]</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">postcss</span>: [</div><div class="line">    <span class="built_in">require</span>(<span class="string">'autoprefixer'</span>)</div><div class="line">  ],</div><div class="line">  <span class="attr">plugins</span>: [</div><div class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</div><div class="line">      <span class="attr">template</span>: __dirname + <span class="string">"/app/index.tmpl.html"</span></div><div class="line">    &#125;),</div><div class="line">    <span class="keyword">new</span> webpack.optimize.OccurenceOrderPlugin(),</div><div class="line">    <span class="keyword">new</span> webpack.optimize.UglifyJsPlugin(),</div><div class="line">    <span class="keyword">new</span> ExtractTextPlugin(<span class="string">"[name]-[hash].css"</span>)</div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面就来具体解释下webpack的使用方法以及配置文件的意思。</p>
<h3 id="基于webpack项目的基本结构"><a href="#基于webpack项目的基本结构" class="headerlink" title="基于webpack项目的基本结构"></a>基于webpack项目的基本结构</h3><p>通常会包含一些子模块文件目录以及一个<code>package.json</code>和<code>webpack.config.js</code>的文件。因为webpack是运行在<code>nodejs</code>环境下的，所以<code>package.json</code>中配置项目依赖，然后在<code>webpack.config.js</code>中配置打包的一些信息。<br>在package.json中通常会在script配置项下配置webpack的不同的运行信息。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">//package.json</span></div><div class="line">&#123;</div><div class="line">  <span class="string">"name"</span>: <span class="string">"webpack-sample-project"</span>,</div><div class="line">  <span class="string">"version"</span>: <span class="string">"1.0.0"</span>,</div><div class="line">  <span class="string">"description"</span>: <span class="string">"Sample webpack project"</span>,</div><div class="line">  <span class="string">"scripts"</span>: &#123;</div><div class="line">    <span class="string">"start"</span>: <span class="string">"webpack-dev-server --progress"</span>,</div><div class="line">    <span class="string">"build"</span>: <span class="string">"NODE_ENV=production webpack --config ./webpack.production.config.js --progress"</span></div><div class="line">  &#125;,</div><div class="line">  <span class="string">"author"</span>: <span class="string">"Cássio Zen"</span>,</div><div class="line">  <span class="string">"license"</span>: <span class="string">"ISC"</span>,</div><div class="line">  <span class="string">"devDependencies"</span>: &#123;...&#125;,</div><div class="line">  <span class="string">"dependencies"</span>: &#123;...&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后通过<code>npm start</code>就可以运行webpack开发状态下的打包命令，通过<code>npm build</code>就可以运行webpack生产环境下的打包命令了～轻松愉快</p>
<h3 id="loaders"><a href="#loaders" class="headerlink" title="loaders"></a>loaders</h3><p>Loaders是webpack中最让人激动人心的功能之一了。通过使用不同的loader，webpack通过调用外部的脚本或工具可以对各种各样的格式的文件进行处理，比如说分析JSON文件并把它转换为JavaScript文件，或者说把下一代的JS文件（ES6，ES7)转换为现代浏览器可以识别的JS文件。或者说对React的开发而言，合适的Loaders可以把React的JSX文件转换为JS文件。</p>
<p>Loaders需要单独安装并且需要在webpack.config.js下的modules关键字下进行配置，Loaders的配置选项包括以下几方面：</p>
<ul>
<li>test：一个匹配loaders所处理的文件的拓展名的正则表达式（必须）</li>
<li>loader：loader的名称（必须）</li>
<li>include/exclude:手动添加必须处理的文件（文件夹）或屏蔽不需要处理的文件（文件夹）（可选）；</li>
<li>query：为loaders提供额外的设置选项（可选）</li>
</ul>
<p>在前面的代码中有以下一段：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</div><div class="line">    <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>,</div><div class="line">    <span class="attr">loader</span>: <span class="string">'babel'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这句的意思就是对除掉node_modules文件夹中js文件外的所有js文件使用npm安装的<code>babel-loader</code>来进行处理。loaders为webpack提供了极其灵活的特性，可以使用丰富的第三方loaders来实现自己特定的需求。</p>
<h3 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h3><p>插件（Plugins）是用来拓展Webpack功能的，它们会在整个构建过程中生效，执行相关的任务。<br>Loaders和Plugins常常被弄混，但是他们其实是完全不同的东西，可以这么来说，loaders是在打包构建过程中用来处理源文件的（JSX，Scss，Less..），一次处理一个，插件并不直接操作单个文件，它直接对整个构建过程其作用。Webpack有很多内置插件，同时也有很多第三方插件，可以让我们完成更加丰富的功能。</p>
<p>我们以HtmlWebpackPlugin插件为例来说明webpack中使用plugins的方法。这个插件的作用是依据一个简单的模板，帮你生成最终的Html5文件，这个文件中自动引用了你打包后的JS文件。每次编译都在文件名中插入一个不同的哈希值。</p>
<p> 1.<strong>安装</strong><br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">npm install --save-dev html-webpack-plugin</div></pre></td></tr></table></figure></p>
<p> 2.<strong>在项目的app目录下创建一个html模版，我们将其命名为index.tmpl.html</strong><br><figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span> </div><div class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span> </div><div class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span> </div><div class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Webpack Sample Project<span class="tag">&lt;/<span class="name">title</span>&gt;</span> </div><div class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">body</span>&gt;</span> </div><div class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'root'</span>&gt;</span> <span class="tag">&lt;/<span class="name">div</span>&gt;</span> </div><div class="line">     <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"> <span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p> 3.<strong>更新webpack的配置文件，新建一个build文件夹用来存放最终的输出文件</strong><br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>); </div><div class="line"><span class="keyword">var</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>); </div><div class="line"><span class="built_in">module</span>.exports = &#123; </div><div class="line">    <span class="attr">devtool</span>: <span class="string">'eval-source-map'</span>, </div><div class="line">    <span class="attr">entry</span>: __dirname + <span class="string">"/app/main.js"</span>, </div><div class="line">    <span class="attr">output</span>: &#123; </div><div class="line">        <span class="attr">path</span>: __dirname + <span class="string">"/build"</span>, </div><div class="line">        <span class="attr">filename</span>: <span class="string">"bundle.js"</span> </div><div class="line">    &#125;, </div><div class="line">    <span class="attr">module</span>: &#123; </div><div class="line">        <span class="attr">loaders</span>: [ </div><div class="line">            &#123; </div><div class="line">                <span class="attr">test</span>: <span class="regexp">/\.json$/</span>, </div><div class="line">                <span class="attr">loader</span>: <span class="string">"json"</span> </div><div class="line">            &#125;, </div><div class="line">            &#123; </div><div class="line">                <span class="attr">test</span>: <span class="regexp">/\.js$/</span>, </div><div class="line">                <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>, </div><div class="line">                <span class="attr">loader</span>: <span class="string">'babel'</span> </div><div class="line">            &#125;, </div><div class="line">            &#123; </div><div class="line">                <span class="attr">test</span>: <span class="regexp">/\.css$/</span>, </div><div class="line">                <span class="attr">loader</span>: <span class="string">'style!css?modules!postcss'</span> </div><div class="line">            &#125; </div><div class="line">            ] </div><div class="line">    &#125;, </div><div class="line">    <span class="attr">postcss</span>: [ </div><div class="line">        <span class="built_in">require</span>(<span class="string">'autoprefixer'</span>) </div><div class="line">    ], </div><div class="line">    <span class="attr">plugins</span>: [ </div><div class="line">        <span class="keyword">new</span> HtmlWebpackPlugin(&#123; </div><div class="line">            <span class="attr">template</span>: __dirname + <span class="string">"/app/index.tmpl.html"</span><span class="comment">//new 一个这个插件的实例，并传入相关的参数 </span></div><div class="line">        &#125;) </div><div class="line">     ], </div><div class="line">    <span class="attr">devServer</span>: &#123; </div><div class="line">            <span class="attr">colors</span>: <span class="literal">true</span>, </div><div class="line">            <span class="attr">historyApiFallback</span>: <span class="literal">true</span>, </div><div class="line">            <span class="attr">inline</span>: <span class="literal">true</span> </div><div class="line">     &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p> 4.<strong>在编译过程中，本插件就会依据此模板生成最终的html页面，会自动添加所依赖的 css, js，favicon等文件</strong></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>本文仅仅是对webpack的主要功能做一个很简单的介绍，它丰富的特性需要在使用中逐渐体会，后续还会继续更新相关内容。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><blockquote>
<p>1、 <a href="http://www.pro-react.com/materials/appendixA/" target="_blank" rel="external">Webpack for React</a><br>2、 <a href="http://www.jianshu.com/p/42e11515c10f" target="_blank" rel="external">入门Webpack，看这篇就够了</a><br>3、 <a href="http://www.w2bc.com/Article/50764" target="_blank" rel="external">一小时包教会 —— webpack 入门指南</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近一直在研究vue，顺带着研究了一下webpack。本文只是一篇简短的记录，后续会继续更新一些webpack深入的学习笔记。&lt;/p&gt;
&lt;h3 id=&quot;webpack概述&quot;&gt;&lt;a href=&quot;#webpack概述&quot; class=&quot;headerlink&quot; title=&quot;webpack概述&quot;&gt;&lt;/a&gt;webpack概述&lt;/h3&gt;&lt;p&gt;简单的说，webpack是一个前端的打包工具。它做的事情就是将你项目中使用的各种前端模块打包到一起，转换为合适的格式发布。通过使用webpack，可以将各种其他格式，如&lt;code&gt;scss&lt;/code&gt;、&lt;code&gt;typescript&lt;/code&gt;等拓展类型的语言转换为可运行的javascript。配合webpack的核心&lt;code&gt;loaders&lt;/code&gt;和&lt;code&gt;plugins&lt;/code&gt;，可以灵活的实现各种需求，非常的强力！&lt;br&gt;
    
    </summary>
    
    
      <category term="webpack" scheme="http://yvshuo.github.io/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>一篇关于javascript闭包的笔记</title>
    <link href="http://yvshuo.github.io/2016/10/11/2016-10-11-closure/"/>
    <id>http://yvshuo.github.io/2016/10/11/2016-10-11-closure/</id>
    <published>2016-10-11T15:21:48.000Z</published>
    <updated>2016-10-11T16:09:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天读到了一篇讲<a href="http://web.jobbole.com/88167/" target="_blank" rel="external">闭包的文章</a>，是我目前看到的最透彻的一篇闭包的讲解。趁热记一下笔记。</p>
<p>在我以前的认识中，一直觉得闭包就是在js中提供了一种类似于java中get方法的功能，使我们可以通过闭包来访问到函数体内的局部变量。然鹅，我的理解也就顶多意会了闭包的一点皮毛。下面就直接通过代码来记录一下这篇文章中写到的知识点。</p>
<h3 id="静态作用域的理解"><a href="#静态作用域的理解" class="headerlink" title="静态作用域的理解"></a>静态作用域的理解</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;	</div><div class="line">  <span class="keyword">var</span> y = x + <span class="number">5</span>;	</div><div class="line">  <span class="keyword">return</span> y;	</div><div class="line">&#125;	</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123; 	</div><div class="line">  <span class="keyword">var</span> x = <span class="number">2</span>;	</div><div class="line">  <span class="keyword">return</span> foo();	</div><div class="line">&#125;	</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;	</div><div class="line">  foo(); <span class="comment">// Static scope: 15; Dynamic scope: 15	</span></div><div class="line">  bar(); <span class="comment">// Static scope: 15; Dynamic scope: 7	</span></div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>现在大部分的程序语言都是使用的静态作用域的规则，基本就是内嵌套作用域规则。</p>
<blockquote>
<p><strong>内嵌套作用域规则：</strong><br>由一个声明引进的标识符在这个声明所在的作用域里可见，而且在其内部嵌套的每个作用域里也可见，除非它被嵌套于内部的对同名标识符的另一个声明所掩盖。为了找到某个给定的标识符所引用的对象，应该在当前最内层作用域里查找。如果找到了一个声明，也就可以找到该标识符所引用的对象。否则我们就到直接的外层作用域里去查找，并继续向外顺序地检查外层作用域，直到到达程序的最外嵌套层次，也就是全局对象声明所在的作用域。如果在所有层次上都没有找到有关声明，那么这个程序就有错误。</p>
</blockquote>
<p>所以这个程序<code>main()</code>中的<code>foo()</code>和<code>bar()</code>在js中的返回值都是15。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> result = [];	</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;	</div><div class="line">  result[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;	</div><div class="line">    <span class="built_in">console</span>.log(i);	</div><div class="line">  &#125;;	</div><div class="line">&#125;	 	</div><div class="line">result[<span class="number">0</span>](); <span class="comment">// 5, expected 0 	</span></div><div class="line">result[<span class="number">1</span>](); <span class="comment">// 5, expected 1 	</span></div><div class="line">result[<span class="number">2</span>](); <span class="comment">// 5, expected 2 	</span></div><div class="line">result[<span class="number">3</span>](); <span class="comment">// 5, expected 3	</span></div><div class="line">result[<span class="number">4</span>](); <span class="comment">// 5, expected 4</span></div></pre></td></tr></table></figure>
<p>上面这个程序中日志输出的就都是5。</p>
<h3 id="保留外部作用域对一个变量的私有引用"><a href="#保留外部作用域对一个变量的私有引用" class="headerlink" title="保留外部作用域对一个变量的私有引用"></a>保留外部作用域对一个变量的私有引用</h3><p>这个就是我之前对闭包的理解。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">secretPassword</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> password = <span class="string">'xh38sk'</span>;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    <span class="attr">guessPassword</span>: <span class="function"><span class="keyword">function</span>(<span class="params">guess</span>) </span>&#123;</div><div class="line">      <span class="keyword">if</span> (guess === password) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;	</div><div class="line">  &#125;	</div><div class="line">&#125;	</div><div class="line"><span class="keyword">var</span> passwordGame = secretPassword();</div><div class="line">passwordGame.guessPassword(<span class="string">'heyisthisit?'</span>); <span class="comment">// false	</span></div><div class="line">passwordGame.guessPassword(<span class="string">'xh38sk'</span>); <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<p>通过闭包，我们可以在<code>secretPassword()</code>函数的外部访问到它的私有变量<code>password</code>。</p>
<h3 id="每调用一次函数就会创建一个单独的闭包"><a href="#每调用一次函数就会创建一个单独的闭包" class="headerlink" title="每调用一次函数就会创建一个单独的闭包"></a>每调用一次函数就会创建一个单独的闭包</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">iCantThinkOfAName</span>(<span class="params">num, obj</span>) </span>&#123;	</div><div class="line">  <span class="comment">// This array variable, along with the 2 parameters passed in,	</span></div><div class="line">  <span class="comment">// are 'captured' by the nested function 'doSomething'	</span></div><div class="line">  <span class="keyword">var</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];	</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params">i</span>) </span>&#123;	</div><div class="line">    num += i;	</div><div class="line">    array.push(num);	</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'num: '</span> + num);	</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'array: '</span> + array); 	</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'obj.value: '</span> + obj.value);	</div><div class="line">  &#125;	</div><div class="line">  <span class="keyword">return</span> doSomething;	</div><div class="line">&#125;	</div><div class="line"><span class="keyword">var</span> referenceObject = &#123; <span class="attr">value</span>: <span class="number">10</span> &#125;;	</div><div class="line"><span class="keyword">var</span> foo = iCantThinkOfAName(<span class="number">2</span>, referenceObject); <span class="comment">// closure #1	</span></div><div class="line"><span class="keyword">var</span> bar = iCantThinkOfAName(<span class="number">6</span>, referenceObject); <span class="comment">// closure #2</span></div><div class="line">foo(<span class="number">2</span>);</div><div class="line"><span class="comment">/*</span></div><div class="line">  num: 4</div><div class="line">  array: 1,2,3,4</div><div class="line">  obj.value: 10 	</div><div class="line">*/	</div><div class="line">bar(<span class="number">2</span>);	</div><div class="line"><span class="comment">/*	</span></div><div class="line">  num: 8	</div><div class="line">  array: 1,2,3,8	</div><div class="line">  obj.value: 10	</div><div class="line">*/	</div><div class="line">referenceObject.value++;	</div><div class="line">foo(<span class="number">4</span>);	</div><div class="line"><span class="comment">/*	</span></div><div class="line">  num: 8</div><div class="line">  array: 1,2,3,4,8</div><div class="line">  obj.value: 11 	</div><div class="line">*/	</div><div class="line">bar(<span class="number">4</span>);	</div><div class="line"><span class="comment">/*	</span></div><div class="line">  num: 12	</div><div class="line">  array: 1,2,3,8,12	</div><div class="line">  obj.value: 11	</div><div class="line">*/</div></pre></td></tr></table></figure>
<p>先得赞一下作者起的这个函数名，<code>iCantThinkOfAName</code>2333333,很喜欢这种画风。顺带提一下今天在github上看到一个开原协议，叫<a href="https://en.wikipedia.org/wiki/WTFPL" target="_blank" rel="external">WTFPL</a>,感兴趣的话可以戳一下这个协议的WIKI链接。全名叫做Do What the Fuck You Want To Public License。哈哈哈哈哈，简直笑尿。</p>
<p>呐，回到上面的程序。这里就用了闭包的一个很重要的特性，<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = iCantThinkOfAName(<span class="number">2</span>, referenceObject); <span class="comment">// closure #1	</span></div><div class="line"><span class="keyword">var</span> bar = iCantThinkOfAName(<span class="number">6</span>, referenceObject); <span class="comment">// closure #2</span></div></pre></td></tr></table></figure></p>
<p>上面这两句创建了两个独立的闭包，每个闭包对<code>iCantThinkOfAName</code>函数中<code>array</code>这个私有变量都创建了一个自己独立的引用（这个概念大概不准确，但是大概可以这么类比吧→_→），而且还能保存住自己作用域中的变量，很有点新建一个对象的感觉- -<br>用作者翻译的话来说就是：</p>
<blockquote>
<p>每个函数都有一个执行上下文，它包括一个在函数中赋予变量含义的词法环境和对其父环境的引用。因为函数对环境的引用，使它看起来就像是函数“记住了”这个环境（作用域）一样。这就是一个闭包</p>
</blockquote>
<p>仿佛明白了一些了不起的道理！厉害！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天读到了一篇讲&lt;a href=&quot;http://web.jobbole.com/88167/&quot;&gt;闭包的文章&lt;/a&gt;，是我目前看到的最透彻的一篇闭包的讲解。趁热记一下笔记。&lt;/p&gt;
&lt;p&gt;在我以前的认识中，一直觉得闭包就是在js中提供了一种类似于java中get方法的功能，使我们可以通过闭包来访问到函数体内的局部变量。然鹅，我的理解也就顶多意会了闭包的一点皮毛。下面就直接通过代码来记录一下这篇文章中写到的知识点。&lt;/p&gt;
&lt;h3 id=&quot;静态作用域的理解&quot;&gt;&lt;a href=&quot;#静态作用域的理解&quot; class=&quot;headerlink&quot; title=&quot;静态作用域的理解&quot;&gt;&lt;/a&gt;静态作用域的理解&lt;/h3&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; x = &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;foo&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;	&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; y = x + &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;;	&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; y;	&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;	&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;bar&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123; 	&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; x = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;	&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; foo();	&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;	&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;	&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  foo(); &lt;span class=&quot;comment&quot;&gt;// Static scope: 15; Dynamic scope: 15	&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  bar(); &lt;span class=&quot;comment&quot;&gt;// Static scope: 15; Dynamic scope: 7	&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;	&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://yvshuo.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>配置hexo的一键打包部署</title>
    <link href="http://yvshuo.github.io/2016/10/07/2016-10-07-githubssh/"/>
    <id>http://yvshuo.github.io/2016/10/07/2016-10-07-githubssh/</id>
    <published>2016-10-07T04:31:27.000Z</published>
    <updated>2016-10-11T15:23:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天研究了一下hexo的自动打包部署，记录一下。</p>
<h2 id="配置github的ssh"><a href="#配置github的ssh" class="headerlink" title="配置github的ssh"></a>配置github的ssh</h2><h3 id="本地生成公钥"><a href="#本地生成公钥" class="headerlink" title="本地生成公钥"></a>本地生成公钥</h3><p>运行 git Bash 客户端，检查是否已经配置过SSH key。<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ <span class="built_in">cd</span> ~/.ssh</div><div class="line">$ ls</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>如果没有 id_rsa 和 id_rsa.pub，则需要创建一个SSH key。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ ssh-keygen -t rsa -C <span class="string">"XXX@XXX.com"</span></div></pre></td></tr></table></figure>
<ul>
<li>-t 制定密钥类型，默认rsa，可以省略</li>
<li>-C 设置注释文字，通常设置自己的邮箱</li>
<li>-f 制定密钥文件存储文件名</li>
</ul>
<p>然后就会生成 id_rsa 和 id_rsa.pub 两个文件，其中 id_rsa.pub就是我们要配在github里的公钥。</p>
<h3 id="在github中配置ssh-key"><a href="#在github中配置ssh-key" class="headerlink" title="在github中配置ssh key"></a>在github中配置ssh key</h3><p>在github中找到配置项的SSH and GPG keys，然后按下图所示配置。</p>
<p><img src="/assets/images/2016/10/07/githubssh-1.png" alt=""></p>
<p>配置完成后，测试一下是否配置成功。<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ ssh -T git@github.com</div></pre></td></tr></table></figure></p>
<p>如果显示以下警告：<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">The authenticity of host <span class="string">'github.com (207.97.227.239)'</span> can<span class="string">'t be established.</span></div><div class="line"># RSA key fingerprint is &lt;your fingerprint&gt;.</div><div class="line"># Are you sure you want to continue connecting (yes/no)?</div></pre></td></tr></table></figure></p>
<p>则说明已经配置成功了，输入yes即可。</p>
<h2 id="配置hexo的自动打包部署"><a href="#配置hexo的自动打包部署" class="headerlink" title="配置hexo的自动打包部署"></a>配置hexo的自动打包部署</h2><h3 id="安装hexo-deployer-git"><a href="#安装hexo-deployer-git" class="headerlink" title="安装hexo-deployer-git"></a>安装hexo-deployer-git</h3><p>还是通过npm来安装，输入下面的命令，稍等片刻即可安装成功。<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ npm install hexo-deployer-git --save</div></pre></td></tr></table></figure></p>
<h3 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h3><p>在根目录的_config.yml中找到以下代码段。<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">deploy:</div><div class="line">  <span class="built_in">type</span>: git</div><div class="line">  repo: &lt;repository url&gt;</div><div class="line">  branch: [branch]</div><div class="line">  message: [message]</div></pre></td></tr></table></figure></p>
<ul>
<li>repo 里配置git仓库的信息，这里我的就是git@github.com:yvshuo/yvshuo.github.io</li>
<li>branch 里配置分支名称，我的是主分支，就配置的master</li>
<li>message 是自定义提交的信息，默认为Site updated: {{ now('YYYY-MM-DD HH:mm:ss') }}，可以空着</li>
</ul>
<h3 id="自动部署提交"><a href="#自动部署提交" class="headerlink" title="自动部署提交"></a>自动部署提交</h3><p>配置完成后，剩下的就是一条命令了。<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ hexo generate --deploy</div></pre></td></tr></table></figure></p>
<p>缩写的命令也是可以的。<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ hexo g -<span class="_">-d</span></div></pre></td></tr></table></figure></p>
<p>开开心心。。。。</p>
<h2 id="最后唠叨几句"><a href="#最后唠叨几句" class="headerlink" title="最后唠叨几句"></a>最后唠叨几句</h2><ul>
<li>记得关掉vpn代理啥的，不然ssh可能会有问题</li>
<li>发现一篇很好的介绍hexo的文章，戳<a href="http://blog.fens.me/hexo-blog-github/" target="_blank" rel="external">Hexo在github上构建免费的Web应用</a></li>
<li>明天又要上班了，终于又可以开心的建设社会主义了。。。。。。（逃</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天研究了一下hexo的自动打包部署，记录一下。&lt;/p&gt;
&lt;h2 id=&quot;配置github的ssh&quot;&gt;&lt;a href=&quot;#配置github的ssh&quot; class=&quot;headerlink&quot; title=&quot;配置github的ssh&quot;&gt;&lt;/a&gt;配置github的ssh&lt;/h2&gt;&lt;h3 id=&quot;本地生成公钥&quot;&gt;&lt;a href=&quot;#本地生成公钥&quot; class=&quot;headerlink&quot; title=&quot;本地生成公钥&quot;&gt;&lt;/a&gt;本地生成公钥&lt;/h3&gt;&lt;p&gt;运行 git Bash 客户端，检查是否已经配置过SSH key。&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ &lt;span class=&quot;built_in&quot;&gt;cd&lt;/span&gt; ~/.ssh&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;$ ls&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="hexo" scheme="http://yvshuo.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>使用hexo在github上搭建博客的记录</title>
    <link href="http://yvshuo.github.io/2016/10/06/2016-10-06-create/"/>
    <id>http://yvshuo.github.io/2016/10/06/2016-10-06-create/</id>
    <published>2016-10-05T16:40:58.000Z</published>
    <updated>2017-02-21T12:08:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>工作已经一年了，想着该稍微停下来总结一下了。恰巧印象笔记开始限终端限流量。于是就有了写博客记录一下日常感想，同时将之前的一些笔记迁移到博客的想法。</p>
<p>在github闲逛的时候看到了<a href="https://litten.github.io/" target="_blank" rel="external">Litten</a>的博客，很是喜欢。于是发现了<a href="https://hexo.io/" target="_blank" rel="external">hexo</a>,各种特性都让我甚是喜欢，就这么对Hexo一见钟情了。在知乎上搜到了一篇介绍<a href="https://www.zhihu.com/question/24422335" target="_blank" rel="external">hexo主题</a>的回答,一圈看下来，还是比较喜欢<a href="https://github.com/litten/hexo-theme-yilia" target="_blank" rel="external">Yilia</a>这个主题，也就是我最早看到的Litten开发的~缘分啊，（逃</p>
<p>于是果断决定使用这个主题，计划着先直接用着，后续有时间的话自己也试着DIY一下自己的主题。</p>
<p>废话不多说了，简单的记录一下第一次搭建Hexo博客的过程。</p>
<a id="more"></a>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Hexo是在nodejs环境下搭建的，在npm的帮助下几行命令就轻松搞定，简直是轻松愉快。当然了，前提是已经安装好了git和nodejs。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ npm install hexo-cli -g</div><div class="line">$ hexo init blog</div><div class="line">$ <span class="built_in">cd</span> blog</div><div class="line">$ npm install</div><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<h2 id="切换主题"><a href="#切换主题" class="headerlink" title="切换主题"></a>切换主题</h2><p>同样很方便，到博客的根目录下，将主题git下来。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ git <span class="built_in">clone</span> https://github.com/litten/hexo-theme-yilia.git themes/yilia</div></pre></td></tr></table></figure>
<p>然后修改根目录下_config.yml中的配置项theme: yilia。如果server是在运行状态下，甚至都不需要重启。只需要刷新下页面，新的主题就已经换上去了。开开心心- -</p>
<h2 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h2><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ hexo new <span class="string">"我的文章"</span></div></pre></td></tr></table></figure>
<p>这样就会生成一篇叫“我的文章”的文章了。默认会在_posts文件夹下新建一个对应的markdown文件“我的文章.md”，编辑这个md文件就可以写文章并发布了。格式遵循<a href="https://daringfireball.net/projects/markdown/syntax" target="_blank" rel="external">md的语法</a>。</p>
<h2 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>生成的静态文件在public文件夹中，这些文件就可以提交到github来搭建自己的个人博客了~简直炫酷。</p>
<h2 id="发布到github上"><a href="#发布到github上" class="headerlink" title="发布到github上"></a>发布到github上</h2><p>每个github账号下都默认有一个自己的XXX.github.io的子域名，可以部署静态代码来生成自己的网站。</p>
<p>譬如我的github账号是yvshuo,于是我要新建一个名字叫做yvshuo.github.io的项目。然后到刚才生成的public文件下将代码提交到github仓库里。如果不熟悉git操作，可以参看<a href="http://rogerdudler.github.io/git-guide/index.zh.html" target="_blank" rel="external">git-简明指南</a>快速入手。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ <span class="built_in">cd</span> public/</div><div class="line">$ git init</div><div class="line">$ git add --all</div><div class="line">$ git commit -m <span class="string">"create"</span></div><div class="line">$ git remote add origin https://github.com/yvshuo/yvshuo.github.io.git</div><div class="line">$ git push -u origin master</div></pre></td></tr></table></figure>
<p>然后就是享受成果的时候了~~<a href="https://yvshuo.github.io/">yvshuo</a></p>
<h2 id="一点点小补充"><a href="#一点点小补充" class="headerlink" title="一点点小补充"></a>一点点小补充</h2><ol>
<li>除了上面说的最基本的一些东西外，还有很多配置和可以自己来diy的东西。具体可参考hexo的<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="external">中文文档</a>。再次表达对hexo的爱~</li>
<li>md编辑器可以自己在sublime text里配，也可以用专门的编辑器，如<a href="http://markdownpad.com/" target="_blank" rel="external">MarkdownPad</a>。当然，我觉得最爽的还是在本地开着hexo server然后监听文件变动自动部署，再直接在浏览器里F5~</li>
<li>今天第一次接触hexo，还有待后续进一步发掘这个工具的强大之处</li>
</ol>
<h2 id="立FLAG"><a href="#立FLAG" class="headerlink" title="立FLAG"></a>立FLAG</h2><blockquote>
<p>要把这个博客经营下去。谢老师监督我→_→</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;工作已经一年了，想着该稍微停下来总结一下了。恰巧印象笔记开始限终端限流量。于是就有了写博客记录一下日常感想，同时将之前的一些笔记迁移到博客的想法。&lt;/p&gt;
&lt;p&gt;在github闲逛的时候看到了&lt;a href=&quot;https://litten.github.io/&quot;&gt;Litten&lt;/a&gt;的博客，很是喜欢。于是发现了&lt;a href=&quot;https://hexo.io/&quot;&gt;hexo&lt;/a&gt;,各种特性都让我甚是喜欢，就这么对Hexo一见钟情了。在知乎上搜到了一篇介绍&lt;a href=&quot;https://www.zhihu.com/question/24422335&quot;&gt;hexo主题&lt;/a&gt;的回答,一圈看下来，还是比较喜欢&lt;a href=&quot;https://github.com/litten/hexo-theme-yilia&quot;&gt;Yilia&lt;/a&gt;这个主题，也就是我最早看到的Litten开发的~缘分啊，（逃&lt;/p&gt;
&lt;p&gt;于是果断决定使用这个主题，计划着先直接用着，后续有时间的话自己也试着DIY一下自己的主题。&lt;/p&gt;
&lt;p&gt;废话不多说了，简单的记录一下第一次搭建Hexo博客的过程。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://yvshuo.github.io/tags/java/"/>
    
  </entry>
  
</feed>
