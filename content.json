[{"title":"阿里巴巴java开发手册解读1-命名规约","date":"2017-02-09T14:43:47.000Z","path":"2017/02/09/2017-02-09-javarule-1/","text":"今天拜读了阿里巴巴刚发布的java开发手册，之前做项目时在一些细节的处理上总是不知道如何下手，看完这个手册，收获颇多。附手册全文。 阿里巴巴java开发手册 下面是摘录加批注。注：引用标签内为批注，字面规则不附批注。 1. 【强制】 代码中的命名均不能以下划线或美元符号开始，也不能以下划线或美元符号结束反例:name / __name / $Object / name / name$ / Object$ 批注:javascript表示不服！ 2. 【强制】 代码中的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。说明：正确的英文拼写和语法可以让阅读者易于理解，避免歧义。注意，即使纯拼音命名方式也要避免采用反例：DaZhePromotion [打折] / getPingfenByName() [评分] / int 某变量 = 3正例：alibaba / taobao / youku / hangzhou 等国际通用的名称，可视同英文。 批注:用拼音命名的同学请举起手！你不是一个人！ 3. 【强制】类名使用 UpperCamelCase 风格，必须遵从驼峰形式以下情形例外：（领域模型的相关命名）DO / BO / DTO / VO 等正例：MarcoPolo / UserDO / XmlService / TcpUdpDeal / TaPromotion反例：macroPolo / UserDo / XMLService / TCPUDPDeal / TAPromotion 批注:1） DO(data object) 数据对象2） DAO(data access object) 数据访问对象3） DTO(Data Transfer Object) 数据传输对象4） VO(value object) 值对象5） BO(business object) 业务对象6） POJO 是 DO/DTO/BO/VO 的统称 4. 【强制】方法名、参数名、成员变量、局部变量都统一使用 lowerCamelCase 风格，必须遵从驼峰形式正例： localValue / getHttpMessage() / inputUserId 5. 【强制】常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长正例： MAX_STOCK_COUNT反例： MAX_COUNT 6. 【强制】抽象类命名使用 Abstract 或 Base 开头；异常类命名使用 Exception 结尾；测试类命名以它要测试的类的名称开始，以 Test 结尾7. 【强制】中括号是数组类型的一部分数组定义如下：String[] args反例：请勿使用 String args[]的方式来定义 批注:务必注意 8. 【强制】POJO 类中布尔类型的变量，都不要加 is否则部分框架解析会引起序列化错误反例：定义为基本数据类型 boolean isSuccess；的属性，它的方法也是 isSuccess()，RPC框架在反向解析的时候，“以为”对应的属性名称是 success，导致属性获取不到，进而抛出异常。 9. 【强制】包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用单数形式，但是类名如果有复数含义，类名可以使用复数形式正例： 应用工具类包名为 com.alibaba.open.util、类名为 MessageUtils（此规则参考spring 的框架结构） 10. 【强制】杜绝完全不规范的缩写，避免望文不知义反例： AbstractClass“缩写”命名成 AbsClass；condition“缩写”命名成 condi，此类随意缩写严重降低了代码的可阅读性。 批注:一个优秀程序员的自我修养！以后还是少用btn，写全button！ 11. 【推荐】如果使用到了设计模式，建议在类名中体现出具体模式说明：将设计模式体现在名字中，有利于阅读者快速理解架构设计思想。正例：public class OrderFactory;public class LoginProxy;public class ResourceObserver; 12. 【推荐】接口类中的方法和属性不要加任何修饰符号（public 也不要加），保持代码的简洁性，并加上有效的 Javadoc 注释。尽量不要在接口里定义变量，如果一定要定义变量，肯定是与接口方法相关，并且是整个应用的基础常量正例：接口方法签名：void f(); 接口基础常量表示：String COMPANY = “alibaba”;反例：接口方法定义：public abstract void f();说明：JDK8 中接口允许有默认实现，那么这个 default 方法，是对所有实现类都有价值的默认实现。 批注:个人还是习惯加上修饰符号。 13. 接口和实现类的命名有两套规则： 1）【强制】对于 Service 和 DAO 类，基于 SOA 的理念，暴露出来的服务一定是接口，内部的实现类用 Impl 的后缀与接口区别。正例：CacheServiceImpl 实现 CacheService 接口。 2）【推荐】如果是形容能力的接口名称，取对应的形容词做接口名（通常是–able 的形式）。正例：AbstractTranslator 实现 Translatable。 14. 【参考】枚举类名建议带上 Enum 后缀，枚举成员名称需要全大写，单词间用下划线隔开。说明：枚举其实就是特殊的常量类，且构造方法被默认强制是私有正例：枚举名字：DealStatusEnum，成员名称：SUCCESS / UNKOWN_REASON。 15. 【参考】各层命名规约： A) Service/DAO 层方法命名规约 1） 获取单个对象的方法用 get 做前缀。2） 获取多个对象的方法用 list 做前缀。3） 获取统计值的方法用 count 做前缀。4） 插入的方法用 save（推荐）或 insert 做前缀。5） 删除的方法用 remove（推荐）或 delete 做前缀。6） 修改的方法用 update 做前缀。 B) 领域模型命名规约 1） 数据对象：xxxDO，xxx 即为数据表名。2） 数据传输对象：xxxDTO，xxx 为业务领域相关的名称。3） 展示对象：xxxVO，xxx 一般为网页名称。4） POJO 是 DO/DTO/BO/VO 的统称，禁止命名成 xxxPOJO。","tags":[{"name":"java","slug":"java","permalink":"http://yvshuo.github.io/tags/java/"}]},{"title":"重构—重新组织函数","date":"2017-01-16T03:03:47.000Z","path":"2017/01/16/2017-01-16-refactor/","text":"上次单位人力让挑书，然后选了这本《重构-改善既有代码的设计》这本书，作者Martin Fowler是ThoughtWorks公司的首席科学家。虽然书写于很多年前，但是很多思想在编程中依然非常实用。书里主要是讲的各种重构的手法，但是我觉得看完之后，个人感觉更重要的是告诉自己在写代码的过程中如何从源头上注意一些问题，让自己的代码更合理，更优美。最初选这本书也是因为觉得需要超脱语言的层面去理解一些编程的宏观的一些东西，不然总是觉得自己像个机器一样，写着代码，却不懂怎么写更好，为什么别人都那样分层。书已经看了一遍，似乎明白了一些哪些代码好一些、哪些代码差一点。最近再一边读一边记下这个系列的读书笔记，算是记录吧~ 1. 代码的坏味道 重复代码：如果在两个不相关的类中出现了重复的相同功能的函数，就应该考虑新建一个独立的类将这个重复的函数提炼出去。 过长函数：写代码的过程中，有一个原则。代码块越小，代码的功能就越容易管理，代码的处理和移动也就越轻松。 过大的类：一个类的代码太多的话，最后就会变成一坨，嗯。尽量将特别大的类进行分解。 过长的参数列:拆成bean。 switch泛滥：作者的建议是少用switch，在使用switch的地方考虑使用多态来解决。 数据泥团：数据成群的绑在一起。正确的做法是将总是绑定在一起的数据放到一个对象里。 发散式变化：多种变化都对应同一个类的修改。这种情况下需要考虑将这个类拆开，尽量每种变化只对应一个类的修改。 霰弹式修改：这个类一旦变化，会引发多个类的修改。这种情况下应该尽量将所有需要修改的方法放到一个类里。 2. 重新组织函数2.1 extract method（提炼函数）1) 没有局部变量，直接提炼。2) 有局部变量，把这个局部变量作为参数传入被提炼函数3) 如果需要对局部变量赋值，得需要使用remove Assignments to parameters.如果被赋值的局部变量只在被提炼的函数中被赋值，则把这个局部变量声明到被提炼函数中。如果被赋值的局部变量需要在被提炼的函数其它的地方使用，则需要被提炼函数返回一个被修改后的值。如果遇到返回的不止一个值，则最好的方法是再重新提炼一个新的方法，每次只返回一个值最佳。 before:12345void printOwing(double amount)&#123; printBanner(); //print details System.out.println(\"amount:\"+amount);&#125; after:1234567void printOwing(double amount)&#123; printBanner(); printDetails(amount);&#125;void printDetails(double amount)&#123; System.out.println(\"amount:\"+amount);&#125; 2.2 inline method(内联函数)before:123456int getRating()&#123; return (moreThanFiveLateDeliveries()) ? 2:1;&#125;boolean moreThanFiveLateDeliveries()&#123; return _numberOfLateDeliveries &gt; 5;&#125; after:123int getRating()&#123; return (_numberOfLateDeliveries &gt; 5) ? 2:1;&#125; 2.3 inline temp(内联临时变量)before:12double basePrice = anOrder.basePrice();return (basePrice&gt;1000); after:1return (anOrder.basePrice()&gt;1000); 2.4 replace temp with query(以查询取代临时变量)临时变量的问题在于：他们是暂时的，而且只能在所属函数内使用。由于临时变量只在所属函数内可见，所以更好的方法是将其替换为一个查询，这样，同一个类中的所有函数都将可以获得这份信息。before:12345double basePrice = _quantity * _itemPrice;if(basePrice &gt; 1000) return basePrice * 0.95;else return basePrice * 0.98; after:1234567if(basePrice() &gt; 1000) return basePrice() * 0.95;else return basePrice() * 0.98;double basePrice()&#123; return _quantity * _itemPrice;&#125; 在进行这项重构的时候有个需要注意的就是得确保这个临时变量是否只被赋值了一次，有个技巧是在这个临时变量前加final修饰符，如果不只被赋值一次，编译器就会报错。这时候就不能使用这个方法。 2.5 introduce explaining variable（引入解释型变量）将复杂表达式放进一个临时变量里，以此变量名称来解释表达式的用途。before:12345if((platform.toUpperCase().indexOf(\"MAC\") &gt; -1) &amp;&amp; (browser.toUpperCase().indexOf(\"IE\") &gt; -1) &amp;&amp; resize&gt;0 )&#123; //do something&#125; after:123456final boolean isMacOs = platform.toUpperCase().indexOf(\"MAC\") &gt; -1;final boolean isIE = browser.toUpperCase().indexOf(\"IE\") &gt; -1;final boolean wasResized = resize&gt;0;if(isMacOs &amp;&amp; isIE &amp;&amp; wasResized)&#123; //do something&#125; 2.6 split temporary variable（分解临时变量）程序中有某个临时变量被赋值超过一次，它既不是循环变量，也不被用于收集计算结果。针对每次赋值，创造一个独立、对应的临时变量。before:1234double temp = 2 * (_height + _width);System.out.println(temp);temp = _height + _width;System.out.println(temp); after:1234final double perimeter = 2 * (_height + _width);System.out.println(perimeter);final double area = _height + _width;System.out.println(area); 个人理解就是这种做法可以保证在重构过程中不出错，不会影响其他抽取函数等操作。而且也可以使代码变得清晰明了。 2.7 remove assignments to parameters（移除对参数的赋值）before:12int discount(int inputVal,int quantity,int yearToDate)&#123; if(inputVal &gt; 50) inputVal -= 2; after:123int discount(int inputVal,int quantity,int yearToDate)&#123; int result = inputVal; if(inputVal &gt; 50) result -= 2; 这么做主要是为了避免在某些按引用传递参数的语言中对调用端造成影响。而且这么做的话，代码会清晰很多，而且这种在任何语言中都会表现出相同的语义。譬如下面的例子中，在参数是对象的情况下，对参数赋值就会造成一些让人糊涂的影响：1234567891011121314151617public static void main(String[] args) &#123; Date d1 = new Date(); nextDateUpdate(d1); System.out.println(\"d1 after nextday:\"+d1); Date d2 = new Date(); nextDateReplace(d2); System.out.println(\"d2 after nextday:\"+d2);&#125;private static void nextDateUpdate(Date arg)&#123; arg.setDate(arg.getDate()+1);//改变了调用端 System.out.println(\"arg in nextDay update:\"+arg);&#125;private static void nextDateReplace(Date arg)&#123; arg=new Date(arg.getYear(),arg.getMonth(),arg.getDate()+1);//没有改变调用端 System.out.println(\"arg in nextDay replace:\"+arg);&#125; 打印出来的结果是：1234arg in nextDay update:Wed Jan 18 10:51:18 CST 2017d1 after nextday:Wed Jan 18 10:51:18 CST 2017arg in nextDay replace:Wed Jan 18 00:00:00 CST 2017d2 after nextday:Tue Jan 17 10:51:18 CST 2017 如果代码的语义是按引用传递的，请在调用端检查调用后是否还使用了这个参数。也要检查有多少个按引用传递的参数被赋值后又被使用。请尽量只以return方式返回一个值。如果需要返回的值不止一个，看看可否把需返回的大堆数据变成单一对象，或干脆为每个返回值设计对应的一个独立函数。 2.8 replace method with method object（以函数对象取代函数） 只要将相对独立的代码从大型函数中提炼出来，就可以大大提高代码的可读性。但是，局部变量的存在会增加函数分解难度。如果一个函数中局部变量泛滥，分解函数就会变得困难。这时候就要以函数对象取代函数，将所有局部变量都变成函数对象的字段，从而将大型函数拆解变短。这个就不举例子了~很容易理解。 2.9 substitute algorithm（替换算法）before:1234567891011121314String foundPerson(String[] people)&#123; for(int i=0;i&lt;people.length;i++)&#123; if(people[i].equals(\"Don\"))&#123; return \"Don\"; &#125; if(people[i].equals(\"John\"))&#123; return \"John\"; &#125; if(people[i].equals(\"Kent\"))&#123; return \"Kent\"; &#125; &#125; return \"\";&#125; after:123456789String foundPerson(String[] people)&#123; List constants = Arrays.asList(new String[]&#123;\"Don\",\"John\",\"Kent\"&#125;); for(int i=0;i&lt;people.length;i++)&#123; if(constants.contains(people[i]))&#123; return people[i]; &#125; &#125; return \"\";&#125; 进行算法重构的步骤：1)准备好另一个（替换用）的算法，让它通过编译。2)针对现有测试，执行上述的新算法。如果结果与原本结果相同，重构结束。3)如果测试结果不同于原先，在测试和调试过程中，以旧算法为比较参照标准。 对于每个测试用例，分别以新旧两种算法执行，并观察两者结果是否相同。 3. 小结这篇主要是对函数中的代码进行整理~都是些基本的重构手法，真正写代码过程中还是要根据实际情况来有针对性的使用。文中有些是我个人的理解，不一定正确。还是要多读书才能深入理解~","tags":[{"name":"重构","slug":"重构","permalink":"http://yvshuo.github.io/tags/重构/"}]},{"title":"git知识备忘","date":"2017-01-11T12:23:51.000Z","path":"2017/01/11/2017-01-11-review-git/","text":"单位用的svn，一个多月不用git，发现有些命令就忘了- -所以这是一篇git操作备忘。主要内容转载自常用 Git 命令清单。 1. git基本示意 Workspace：工作区 Index / Stage：暂存区 Repository：仓库区（或本地仓库） Remote：远程仓库 2. 常用操作命令2.1 新建代码库123456# 在当前目录新建一个Git代码库$ git init# 新建一个目录，将其初始化为Git代码库$ git init [project-name]# 下载一个项目和它的整个代码历史$ git clone [url] 2.2 配置Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。1234567# 显示当前的Git配置$ git config --list# 编辑Git配置文件$ git config -e [--global]# 设置提交代码时的用户信息$ git config [--global] user.name \"[name]\"$ git config [--global] user.email \"[email address]\" 2.3 增加/删除文件123456789101112131415# 添加指定文件到暂存区$ git add [file1] [file2] ...# 添加指定目录到暂存区，包括子目录$ git add [dir]# 添加当前目录的所有文件到暂存区$ git add .# 添加每个变化前，都会要求确认# 对于同一个文件的多处变化，可以实现分次提交$ git add -p# 删除工作区文件，并且将这次删除放入暂存区$ git rm [file1] [file2] ...# 停止追踪指定文件，但该文件会保留在工作区$ git rm --cached [file]# 改名文件，并且将这个改名放入暂存区$ git mv [file-original] [file-renamed] 2.4 代码提交12345678910111213# 提交暂存区到仓库区$ git commit -m [message]# 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message]# 提交工作区自上次commit之后的变化，直接到仓库区$ git commit -a# 提交时显示所有diff信息$ git commit -v# 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息$ git commit --amend -m [message]# 重做上一次commit，并包括指定文件的新变化$ git commit --amend [file1] [file2] ... 2.5 分支1234567891011121314151617181920212223242526272829# 列出所有本地分支$ git branch# 列出所有远程分支$ git branch -r# 列出所有本地分支和远程分支$ git branch -a# 新建一个分支，但依然停留在当前分支$ git branch [branch-name]# 新建一个分支，并切换到该分支$ git checkout -b [branch]# 新建一个分支，指向指定commit$ git branch [branch] [commit]# 新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区$ git checkout [branch-name]# 切换到上一个分支$ git checkout -# 建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream [branch] [remote-branch]# 合并指定分支到当前分支$ git merge [branch]# 选择一个commit，合并进当前分支$ git cherry-pick [commit]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch] 2.6 标签123456789101112131415161718# 列出所有tag$ git tag# 新建一个tag在当前commit$ git tag [tag]# 新建一个tag在指定commit$ git tag [tag] [commit]# 删除本地tag$ git tag -d [tag]# 删除远程tag$ git push origin :refs/tags/[tagName]# 查看tag信息$ git show [tag]# 提交指定tag$ git push [remote] [tag]# 提交所有tag$ git push [remote] --tags# 新建一个分支，指向某个tag$ git checkout -b [branch] [tag] 2.7 查看信息1234567891011121314151617181920212223242526272829303132333435363738394041# 显示有变更的文件$ git status# 显示当前分支的版本历史$ git log# 显示commit历史，以及每次commit发生变更的文件$ git log --stat# 搜索提交历史，根据关键词$ git log -S [keyword]# 显示某个commit之后的所有变动，每个commit占据一行$ git log [tag] HEAD --pretty=format:%s# 显示某个commit之后的所有变动，其\"提交说明\"必须符合搜索条件$ git log [tag] HEAD --grep feature# 显示某个文件的版本历史，包括文件改名$ git log --follow [file]$ git whatchanged [file]# 显示指定文件相关的每一次diff$ git log -p [file]# 显示过去5次提交$ git log -5 --pretty --oneline# 显示所有提交过的用户，按提交次数排序$ git shortlog -sn# 显示指定文件是什么人在什么时间修改过$ git blame [file]# 显示暂存区和工作区的差异$ git diff# 显示暂存区和上一个commit的差异$ git diff --cached [file]# 显示工作区与当前分支最新commit之间的差异$ git diff HEAD# 显示两次提交之间的差异$ git diff [first-branch]...[second-branch]# 显示今天你写了多少行代码$ git diff --shortstat \"@&#123;0 day ago&#125;\"# 显示某次提交的元数据和内容变化$ git show [commit]# 显示某次提交发生变化的文件$ git show --name-only [commit]# 显示某次提交时，某个文件的内容$ git show [commit]:[filename]# 显示当前分支的最近几次提交$ git reflog 2.8 远程同步12345678910111213141516# 下载远程仓库的所有变动$ git fetch [remote]# 显示所有远程仓库$ git remote -v# 显示某个远程仓库的信息$ git remote show [remote]# 增加一个新的远程仓库，并命名$ git remote add [shortname] [url]# 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch]# 上传本地指定分支到远程仓库$ git push [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force# 推送所有分支到远程仓库$ git push [remote] --all 2.9 撤销12345678910111213141516171819202122# 恢复暂存区的指定文件到工作区$ git checkout [file]# 恢复某个commit的指定文件到暂存区和工作区$ git checkout [commit] [file]# 恢复暂存区的所有文件到工作区$ git checkout .# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file]# 重置暂存区与工作区，与上一次commit保持一致$ git reset --hard# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit]# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset --hard [commit]# 重置当前HEAD为指定commit，但保持暂存区和工作区不变$ git reset --keep [commit]# 新建一个commit，用来撤销指定commit# 后者的所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit]# 暂时将未提交的变化移除，稍后再移入$ git stash$ git stash pop 2.10 其他12# 生成一个可供发布的压缩包$ git archive 3 总结嗯，看来我是有一段时间没有抽时间好好学习了~最近在读一本讲java重构的书~回头写个读书笔记→_→","tags":[{"name":"git","slug":"git","permalink":"http://yvshuo.github.io/tags/git/"}]},{"title":"微信小程序初体验（1）","date":"2016-11-27T03:03:47.000Z","path":"2016/11/27/2016-11-27-wxapp/","text":"p.s. 这篇文章是一个月之前写的，因为最近忙于其他项目，所以一直没来维护这个博客~微信小程序貌似也有了新的更新。先把这篇贴上，后续填坑23333 利用周末时间基于cnode社区的api撸了一发微信小程序，记录一下。 1、开发环境微信mac版开发工具0.11.112301下载地址：使劲戳我其他版本下载地址：继续戳我 2、项目创建扫码登录后按下图输入创建项目 创建项目后界面的样子和默认的文件目录结构 分析下目录结构pages目录下有两个页面，index和logs。.js文件是负责处理该页面的逻辑，.wxml负责视图以及绑定一些交互事件，.wxss来写css样式，.json用来配置一些配置参数或者定义一些静态常量。utils目录下是一个工具类。根目录下的app.js是小程序的入口文件，用来注册app。app.json可以用来配置全局常量，app.wxss用来配置项目的公用样式。 初始程序提供了一个从index页面到logs页面的跳转index.wxml中绑定的bindViewTab函数就是前面在index.js中标出的那个函数。函数中调用微信小程序的api定义了一个跳转12345bindViewTap: function() &#123; wx.navigateTo(&#123; url: '../logs/logs' &#125;)&#125; 另外，在logs.js中调用了一下微信的apiwx.getStorageSync(KEY)从本地缓存中同步获取指定key对应的内容。1234567//app.jsonLaunch: function () &#123; //调用API从本地缓存中获取数据 var logs = wx.getStorageSync('logs') || [] logs.unshift(Date.now()) wx.setStorageSync('logs', logs)&#125; 在小程序启动的时候就会在本地存储的logs中记录下当前时间，添加到数组的最前面。所以每次重新启动小程序后在logs页面就会加一条数据。重新启动前：重新启动后: 3、组件介绍组件就是视图层的基本组成单元，简单的理解就是微信小程序提供的一些标签库，通过使用这些组件，可以快速搭建自带一些微信基本风格的视图。官方说明文档：请大力戳我123456&lt;!--logs.wxml--&gt;&lt;view class=\"container log-list\"&gt; &lt;block wx:for=\"&#123;&#123;logs&#125;&#125;\" wx:for-item=\"log\" wx:key=\"*this\"&gt; &lt;text class=\"log-item\"&gt;&#123;&#123;index + 1&#125;&#125;. &#123;&#123;log&#125;&#125;&lt;/text&gt; &lt;/block&gt;&lt;/view&gt; 上面代码中的view标签和text标签就是组件，view是一个视图容器，支持嵌套。text就是一个文本组件。12345678910&lt;!--index.wxml--&gt;&lt;view class=\"container\"&gt; &lt;view bindtap=\"bindViewTap\" class=\"userinfo\"&gt; &lt;image class=\"userinfo-avatar\" src=\"&#123;&#123;userInfo.avatarUrl&#125;&#125;\" background-size=\"cover\"&gt;&lt;/image&gt; &lt;text class=\"userinfo-nickname\"&gt;&#123;&#123;userInfo.nickName&#125;&#125;&lt;/text&gt; &lt;/view&gt; &lt;view class=\"usermotto\"&gt; &lt;text class=\"user-motto\"&gt;&#123;&#123;motto&#125;&#125;&lt;/text&gt; &lt;/view&gt;&lt;/view&gt; 这个就是在一个父view中嵌套了两个子view。在logs.wxml中还有一个地方，就是block标签，这个是小程序框架中提供的一个包装元素，它不是一个组件，不会在页面中做任何渲染，只会接受基本的控制属性。 4、API介绍小程序的框架提供了很多微信原生的API，可以方便的调起微信提供的能力，如获取用户信息，本地存储，支付功能等。官方文档：不要停，继续戳截止到目前，微信小程序提供了7大类API，网络、媒体、数据、位置、设备、界面、开放接口。个人比较感兴趣的就是媒体类的API，提供了大量基于微信原生的丰富功能。看到了一个打开文档的接口wx.openDocument(OBJECT)，感觉可以基于这个接口开发一个管理微信聊天中发布的文档的小应用，然后需要的时候拿出来读~以后就再也不需要翻聊天记录翻来翻去了~因吹思婷！另外界面API也很喜欢，一直以来都非常喜欢微信的UI设计，读了小程序的设计指南之后更是觉得微信的设计团队好厉害。小程序的设计指南：戳吧至于开放接口的API，个人感觉这块文档还很乱，另外个人开发者好像不能用。学习的时候感觉非常的蛋疼。希望能提供一个供学习的沙盒接口，同时完善下教程。 5、开始撸代码首先放上cnode社区的API文档：感谢cnode社区，请戳我这里有个微信开发者工具的BUG，开发过程中发现我修改的代码始终处于一种缓存状态，修改的代码没法更新上去。选择了清除文件缓存和数据缓存，包括重启等方法均不行。嗯。。最后发现默认的这个代码热更新有BUG，导致了以上问题。如果还是发现代码不能更新的话，切换下这个选项框的选择状态就可以刷新项目了。 5.1 配置使用根目录下的app.json来进行全局配置。1234567891011121314151617181920212223&#123; \"pages\": [ \"pages/index/index\", \"pages/logs/index\" ], \"window\": &#123; \"navigationBarTitleText\": \"Demo\" &#125;, \"tabBar\": &#123; \"list\": [&#123; \"pagePath\": \"pages/index/index\", \"text\": \"首页\" &#125;, &#123; \"pagePath\": \"pages/logs/logs\", \"text\": \"日志\" &#125;] &#125;, \"networkTimeout\": &#123; \"request\": 10000, \"downloadFile\": 10000 &#125;, \"debug\": true&#125; 下面给出各个配置项的说明： 属性 类型 必填 描述 pages String Array 是 设置页面路径 window Object 否 设置默认页面的窗口表现 tabBar Object 否 设置底部 tab 的表现 networkTimeout Object 否 设置网络超时时间 debug Boolean 否 设置是否开启 debug 模式 除了pages外其他几个属性都不是必须的。tabBar可以页面上方或者下方添加tab选项卡，最少2个选项卡，最多5个选项卡。每个选项的配置项都可以在 这里 查到，不再赘述。 5.2 注册APP微信小程序是在根目录的app.js里通过App()函数来注册小程序的。这个函数可以接收一个object参数，指定小程序的生命周期函数等。 属性 类型 描述 触发时机 onLaunch Function 监听小程序初始化 当小程序初始化完成时，会触发 onLaunch（全局只触发一次） onShow Function 监听小程序显示 当小程序启动，或从后台进入前台显示，会触发 onShow onHide Function 监听小程序隐藏 当小程序从前台进入后台，会触发 onHide 其他 Any 开发者可以添加任意的函数或数据到 Object 参数中，用 this 可以访问 - 所以可以在这里配一些全局的静态参数什么的~","tags":[{"name":"微信小程序","slug":"微信小程序","permalink":"http://yvshuo.github.io/tags/微信小程序/"}]},{"title":"使用ESLint检查语法和代码风格","date":"2016-11-15T13:37:39.000Z","path":"2016/11/15/2016-11-15-eslint/","text":"在学习ECMAScript6的过程中发现了一个代码风格和语法的检查工具，ESLint，记录一下。 安装这里记录的安装方法是通过npm的安装，所以前提条件是已经安装了npm。如果没有安装的话，建议直接安装nvm，可以方便的切换node的版本。1npm i -g eslint 通过以上命令即可完成eslint CLI的安装。 使用ESLint的运行格式如下：1eslint [options] [file|dir|glob]* 以下的几种方式都是可行的：123eslint file1.js file2.jseslint lib/**eslint \"lib/**\" 选项以下的内容可以通过eslint -h来查阅123456789101112131415161718192021222324252627282930313233343536373839eslint [options] file.js [file.js] [dir]Basic configuration: -c, --config path::String Use configuration from this file or shareable config --no-eslintrc Disable use of configuration from .eslintrc --env [String] Specify environments --ext [String] Specify JavaScript file extensions - default: .js --global [String] Define global variables --parser String Specify the parser to be used --parser-options Object Specify parser optionsCaching: --cache Only check changed files - default: false --cache-file path::String Path to the cache file. Deprecated: use --cache-location - default: .eslintcache --cache-location path::String Path to the cache file or directorySpecifying rules and plugins: --rulesdir [path::String] Use additional rules from this directory --plugin [String] Specify plugins --rule Object Specify rulesIgnoring files: --ignore-path path::String Specify path of ignore file --no-ignore Disable use of ignore files and patterns --ignore-pattern [String] Pattern of files to ignore (in addition to those in .eslintignore)Using stdin: --stdin Lint code provided on &lt;STDIN&gt; - default: false --stdin-filename String Specify filename to process STDIN asHandling warnings: --quiet Report errors only - default: false --max-warnings Int Number of warnings to trigger nonzero exit code - default: -1Output: -o, --output-file path::String Specify file to write report to -f, --format String Use a specific output format - default: stylish --color, --no-color Force enabling/disabling of colorMiscellaneous: --init Run config initialization wizard - default: false --fix Automatically fix problems --debug Output debugging information -h, --help Show help -v, --version Output the version number --no-inline-config Prevent comments from changing config or rules --print-config path::String Print the configuration for the given file 例子：12eslint --ext .jsx --ext .js file.jseslint --ext .jsx,.js file.js 基本配置 -c,–config这个选项能给ESLint指定一个附加的配置文件。例子：1eslint -c ~/my-eslint.json file.js 这个例子使用~/my-eslint.json这个配置文件。还有一种是使用共享的配置。例子：1eslint -c airbnb file.js 这个例子使用的是eslint-config-airbnb的配置，使用之前需要安装。1$ npm i -g eslint-config-airbnb –no-eslintrc禁用.eslintrc和package.json中的配置例子： 1eslint --no-eslintrc file.js –env指定特定的环境例子： 12eslint --env browser,node file.jseslint --env browser --env node file.js –ext配置ESLint对哪些文件类型起作用例子： 123456# 只对 .js2 后缀的文件类型起作用eslint . --ext .js2# 对 .js 和 .js2 后缀的文件类型都起作用eslint . --ext .js --ext .js2# 对 .js 和 .js2 后缀的文件类型都起作用eslint . --ext .js,.js2 –ext配置ESLint对哪些文件类型起作用例子： 123456# 只对 .js2 后缀的文件类型起作用eslint . --ext .js2# 对 .js 和 .js2 后缀的文件类型都起作用eslint . --ext .js --ext .js2# 对 .js 和 .js2 后缀的文件类型都起作用eslint . --ext .js,.js2 –global设置全局参数例子： 12eslint --global require,exports:true file.jseslint --global require --global exports:true –global设置全局参数例子： 12eslint --global require,exports:true file.jseslint --global require --global exports:true –plugin设置需要载入的插件。设置前需要通过npm安装要载入的插件。例子： 12eslint --plugin jquery file.jseslint --plugin eslint-plugin-mocha file.js –rule直接设置要使用的规则。例子： 123eslint --rule 'quotes: [2, double]'eslint --rule 'guard-for-in: 2' --rule 'brace-style: [2, 1tbs]'eslint --rule 'jquery/dollar-sign: 2' –ignore-path设置一个文件来代替.eslintignore的功能，如果不设置的话，eslint默认会使用当前工作空间的.eslintignore例子： 12eslint --ignore-path tmp/.eslintignore file.jseslint --ignore-path .gitignore file.js –no-ignore禁用.eslintignore, --ignore-path和--ignore-pattern中的例外情况例子： 1eslint --no-ignore file.js –ignore-pattern设置忽略匹配指定正则类型的文件例子： 1eslint --ignore-pattern '/lib/' --ignore-pattern '/src/vendor/*' . –quiet禁用reporting和warning，ESlint将只通知error例子： 1eslint --quiet file.js –max-warnings设置eslint警告的临界值，在错误过多时强制eslint退出例子： 1eslint --max-warnings 10 file.js -o, –output-file将report写进指定文件例子： 1eslint -o ./test/test.html -f, –format指定report输出的格式，可选格式为checkstyle，codeframe，compact，html，jslint-xml，json，junit，stylish (the default)，table，tap，unix，visualstudio。例子： 1eslint -f compact file.js –color, –no-color指定report的颜色例子： 12eslint --color file.js | cateslint --no-color file.js init初始化一些基本的配置。可以帮助新用户快速配置。 -h, –help获得帮助菜单 -v, –version显示当前的eslint版本 –print-config打印当前eslint的配置信息 在.eslintignore中设置忽略的文件 12node_modules/***/vendor/*.js 实际例子在这个例子中使用Airbnb的语法规则。安装Airbnb的语法规则：1$ npm i -g eslint-config-airbnb 在项目的根目录下新建一个.eslintrc文件，配置ESLint。123&#123; \"extends\": \"eslint-config-airbnb\"&#125; 待检查的index.js的代码如下：123456var unusued = 'I have no purpose!';function greet() &#123; var message = 'Hello, World!'; alert(message);&#125;greet(); 使用ESLint检查这个文件1$ eslint index.js 控制台输出：12345index.js 1:5 error unusued is defined but never used no-unused-vars 4:5 error Expected indentation of 2 characters but found 4 indent 5:5 error Expected indentation of 2 characters but found 4 indent✖ 3 problems (3 errors, 0 warnings) 上面代码说明，原文件有三个错误，一个是定义了变量，却没有使用，另外两个是行首缩进为4个空格，而不是规定的2个空格。 参考文章 1、ESLint Command Line Interface2、ECMAScript 6 入门-编程风格-ESLint的使用","tags":[{"name":"js","slug":"js","permalink":"http://yvshuo.github.io/tags/js/"}]},{"title":"webpack简介","date":"2016-10-26T15:21:48.000Z","path":"2016/10/26/2016-10-26-webpacknote/","text":"最近一直在研究vue，顺带着研究了一下webpack。本文只是一篇简短的记录，后续会继续更新一些webpack深入的学习笔记。 webpack概述简单的说，webpack是一个前端的打包工具。它做的事情就是将你项目中使用的各种前端模块打包到一起，转换为合适的格式发布。通过使用webpack，可以将各种其他格式，如scss、typescript等拓展类型的语言转换为可运行的javascript。配合webpack的核心loaders和plugins，可以灵活的实现各种需求，非常的强力！下面是一个典型的webpack的配置文件： 1234567891011121314151617181920212223242526272829303132333435363738var webpack = require('webpack');var HtmlWebpackPlugin = require('html-webpack-plugin');var ExtractTextPlugin = require('extract-text-webpack-plugin');module.exports = &#123; entry: __dirname + \"/app/main.js\", output: &#123; path: __dirname + \"/build\", filename: \"[name]-[hash].js\" &#125;, module: &#123; loaders: [ &#123; test: /\\.json$/, loader: \"json\" &#125;, &#123; test: /\\.js$/, exclude: /node_modules/, loader: 'babel' &#125;, &#123; test: /\\.css$/, loader: ExtractTextPlugin.extract('style', 'css?modules!postcss') &#125; ] &#125;, postcss: [ require('autoprefixer') ], plugins: [ new HtmlWebpackPlugin(&#123; template: __dirname + \"/app/index.tmpl.html\" &#125;), new webpack.optimize.OccurenceOrderPlugin(), new webpack.optimize.UglifyJsPlugin(), new ExtractTextPlugin(\"[name]-[hash].css\") ]&#125; 下面就来具体解释下webpack的使用方法以及配置文件的意思。 基于webpack项目的基本结构通常会包含一些子模块文件目录以及一个package.json和webpack.config.js的文件。因为webpack是运行在nodejs环境下的，所以package.json中配置项目依赖，然后在webpack.config.js中配置打包的一些信息。在package.json中通常会在script配置项下配置webpack的不同的运行信息。1234567891011121314//package.json&#123; \"name\": \"webpack-sample-project\", \"version\": \"1.0.0\", \"description\": \"Sample webpack project\", \"scripts\": &#123; \"start\": \"webpack-dev-server --progress\", \"build\": \"NODE_ENV=production webpack --config ./webpack.production.config.js --progress\" &#125;, \"author\": \"Cássio Zen\", \"license\": \"ISC\", \"devDependencies\": &#123;...&#125;, \"dependencies\": &#123;...&#125;&#125; 然后通过npm start就可以运行webpack开发状态下的打包命令，通过npm build就可以运行webpack生产环境下的打包命令了～轻松愉快 loadersLoaders是webpack中最让人激动人心的功能之一了。通过使用不同的loader，webpack通过调用外部的脚本或工具可以对各种各样的格式的文件进行处理，比如说分析JSON文件并把它转换为JavaScript文件，或者说把下一代的JS文件（ES6，ES7)转换为现代浏览器可以识别的JS文件。或者说对React的开发而言，合适的Loaders可以把React的JSX文件转换为JS文件。 Loaders需要单独安装并且需要在webpack.config.js下的modules关键字下进行配置，Loaders的配置选项包括以下几方面： test：一个匹配loaders所处理的文件的拓展名的正则表达式（必须） loader：loader的名称（必须） include/exclude:手动添加必须处理的文件（文件夹）或屏蔽不需要处理的文件（文件夹）（可选）； query：为loaders提供额外的设置选项（可选） 在前面的代码中有以下一段：12345&#123; test: /\\.js$/, exclude: /node_modules/, loader: 'babel'&#125; 这句的意思就是对除掉node_modules文件夹中js文件外的所有js文件使用npm安装的babel-loader来进行处理。loaders为webpack提供了极其灵活的特性，可以使用丰富的第三方loaders来实现自己特定的需求。 plugins插件（Plugins）是用来拓展Webpack功能的，它们会在整个构建过程中生效，执行相关的任务。Loaders和Plugins常常被弄混，但是他们其实是完全不同的东西，可以这么来说，loaders是在打包构建过程中用来处理源文件的（JSX，Scss，Less..），一次处理一个，插件并不直接操作单个文件，它直接对整个构建过程其作用。Webpack有很多内置插件，同时也有很多第三方插件，可以让我们完成更加丰富的功能。 我们以HtmlWebpackPlugin插件为例来说明webpack中使用plugins的方法。这个插件的作用是依据一个简单的模板，帮你生成最终的Html5文件，这个文件中自动引用了你打包后的JS文件。每次编译都在文件名中插入一个不同的哈希值。 1.安装1npm install --save-dev html-webpack-plugin 2.在项目的app目录下创建一个html模版，我们将其命名为index.tmpl.html12345678910&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;Webpack Sample Project&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id='root'&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 3.更新webpack的配置文件，新建一个build文件夹用来存放最终的输出文件12345678910111213141516171819202122232425262728293031323334353637383940var webpack = require('webpack'); var HtmlWebpackPlugin = require('html-webpack-plugin'); module.exports = &#123; devtool: 'eval-source-map', entry: __dirname + \"/app/main.js\", output: &#123; path: __dirname + \"/build\", filename: \"bundle.js\" &#125;, module: &#123; loaders: [ &#123; test: /\\.json$/, loader: \"json\" &#125;, &#123; test: /\\.js$/, exclude: /node_modules/, loader: 'babel' &#125;, &#123; test: /\\.css$/, loader: 'style!css?modules!postcss' &#125; ] &#125;, postcss: [ require('autoprefixer') ], plugins: [ new HtmlWebpackPlugin(&#123; template: __dirname + \"/app/index.tmpl.html\"//new 一个这个插件的实例，并传入相关的参数 &#125;) ], devServer: &#123; colors: true, historyApiFallback: true, inline: true &#125; &#125; 4.在编译过程中，本插件就会依据此模板生成最终的html页面，会自动添加所依赖的 css, js，favicon等文件 小结本文仅仅是对webpack的主要功能做一个很简单的介绍，它丰富的特性需要在使用中逐渐体会，后续还会继续更新相关内容。 参考资料 1、 Webpack for React2、 入门Webpack，看这篇就够了3、 一小时包教会 —— webpack 入门指南","tags":[{"name":"webpack","slug":"webpack","permalink":"http://yvshuo.github.io/tags/webpack/"}]},{"title":"一篇关于javascript闭包的笔记","date":"2016-10-11T15:21:48.000Z","path":"2016/10/11/2016-10-11-closure/","text":"今天读到了一篇讲闭包的文章，是我目前看到的最透彻的一篇闭包的讲解。趁热记一下笔记。 在我以前的认识中，一直觉得闭包就是在js中提供了一种类似于java中get方法的功能，使我们可以通过闭包来访问到函数体内的局部变量。然鹅，我的理解也就顶多意会了闭包的一点皮毛。下面就直接通过代码来记录一下这篇文章中写到的知识点。 静态作用域的理解1234567891011121314var x = 10;function foo() &#123; var y = x + 5; return y; &#125; function bar() &#123; var x = 2; return foo(); &#125; function main() &#123; foo(); // Static scope: 15; Dynamic scope: 15 bar(); // Static scope: 15; Dynamic scope: 7 return 0; &#125; 现在大部分的程序语言都是使用的静态作用域的规则，基本就是内嵌套作用域规则。 内嵌套作用域规则：由一个声明引进的标识符在这个声明所在的作用域里可见，而且在其内部嵌套的每个作用域里也可见，除非它被嵌套于内部的对同名标识符的另一个声明所掩盖。为了找到某个给定的标识符所引用的对象，应该在当前最内层作用域里查找。如果找到了一个声明，也就可以找到该标识符所引用的对象。否则我们就到直接的外层作用域里去查找，并继续向外顺序地检查外层作用域，直到到达程序的最外嵌套层次，也就是全局对象声明所在的作用域。如果在所有层次上都没有找到有关声明，那么这个程序就有错误。 所以这个程序main()中的foo()和bar()在js中的返回值都是15。 1234567891011var result = []; for (var i = 0; i &lt; 5; i++) &#123; result[i] = function () &#123; console.log(i); &#125;; &#125; result[0](); // 5, expected 0 result[1](); // 5, expected 1 result[2](); // 5, expected 2 result[3](); // 5, expected 3 result[4](); // 5, expected 4 上面这个程序中日志输出的就都是5。 保留外部作用域对一个变量的私有引用这个就是我之前对闭包的理解。123456789101112131415function secretPassword() &#123; var password = 'xh38sk'; return &#123; guessPassword: function(guess) &#123; if (guess === password) &#123; return true; &#125; else &#123; return false; &#125; &#125; &#125; &#125; var passwordGame = secretPassword();passwordGame.guessPassword('heyisthisit?'); // false passwordGame.guessPassword('xh38sk'); // true 通过闭包，我们可以在secretPassword()函数的外部访问到它的私有变量password。 每调用一次函数就会创建一个单独的闭包1234567891011121314151617181920212223242526272829303132333435363738394041function iCantThinkOfAName(num, obj) &#123; // This array variable, along with the 2 parameters passed in, // are 'captured' by the nested function 'doSomething' var array = [1, 2, 3]; function doSomething(i) &#123; num += i; array.push(num); console.log('num: ' + num); console.log('array: ' + array); console.log('obj.value: ' + obj.value); &#125; return doSomething; &#125; var referenceObject = &#123; value: 10 &#125;; var foo = iCantThinkOfAName(2, referenceObject); // closure #1 var bar = iCantThinkOfAName(6, referenceObject); // closure #2foo(2);/* num: 4 array: 1,2,3,4 obj.value: 10 */ bar(2); /* num: 8 array: 1,2,3,8 obj.value: 10 */ referenceObject.value++; foo(4); /* num: 8 array: 1,2,3,4,8 obj.value: 11 */ bar(4); /* num: 12 array: 1,2,3,8,12 obj.value: 11 */ 先得赞一下作者起的这个函数名，iCantThinkOfAName2333333,很喜欢这种画风。顺带提一下今天在github上看到一个开原协议，叫WTFPL,感兴趣的话可以戳一下这个协议的WIKI链接。全名叫做Do What the Fuck You Want To Public License。哈哈哈哈哈，简直笑尿。 呐，回到上面的程序。这里就用了闭包的一个很重要的特性，12var foo = iCantThinkOfAName(2, referenceObject); // closure #1 var bar = iCantThinkOfAName(6, referenceObject); // closure #2 上面这两句创建了两个独立的闭包，每个闭包对iCantThinkOfAName函数中array这个私有变量都创建了一个自己独立的引用（这个概念大概不准确，但是大概可以这么类比吧→_→），而且还能保存住自己作用域中的变量，很有点新建一个对象的感觉- -用作者翻译的话来说就是： 每个函数都有一个执行上下文，它包括一个在函数中赋予变量含义的词法环境和对其父环境的引用。因为函数对环境的引用，使它看起来就像是函数“记住了”这个环境（作用域）一样。这就是一个闭包 仿佛明白了一些了不起的道理！厉害！","tags":[{"name":"js","slug":"js","permalink":"http://yvshuo.github.io/tags/js/"}]},{"title":"配置hexo的一键打包部署","date":"2016-10-07T04:31:27.000Z","path":"2016/10/07/2016-10-07-githubssh/","text":"今天研究了一下hexo的自动打包部署，记录一下。 配置github的ssh本地生成公钥运行 git Bash 客户端，检查是否已经配置过SSH key。12$ cd ~/.ssh$ ls 如果没有 id_rsa 和 id_rsa.pub，则需要创建一个SSH key。 1$ ssh-keygen -t rsa -C \"XXX@XXX.com\" -t 制定密钥类型，默认rsa，可以省略 -C 设置注释文字，通常设置自己的邮箱 -f 制定密钥文件存储文件名 然后就会生成 id_rsa 和 id_rsa.pub 两个文件，其中 id_rsa.pub就是我们要配在github里的公钥。 在github中配置ssh key在github中找到配置项的SSH and GPG keys，然后按下图所示配置。 配置完成后，测试一下是否配置成功。1$ ssh -T git@github.com 如果显示以下警告：123The authenticity of host 'github.com (207.97.227.239)' can't be established.# RSA key fingerprint is &lt;your fingerprint&gt;.# Are you sure you want to continue connecting (yes/no)? 则说明已经配置成功了，输入yes即可。 配置hexo的自动打包部署安装hexo-deployer-git还是通过npm来安装，输入下面的命令，稍等片刻即可安装成功。1$ npm install hexo-deployer-git --save 修改配置在根目录的_config.yml中找到以下代码段。12345deploy: type: git repo: &lt;repository url&gt; branch: [branch] message: [message] repo 里配置git仓库的信息，这里我的就是git@github.com:yvshuo/yvshuo.github.io branch 里配置分支名称，我的是主分支，就配置的master message 是自定义提交的信息，默认为Site updated: {{ now('YYYY-MM-DD HH:mm:ss') }}，可以空着 自动部署提交配置完成后，剩下的就是一条命令了。1$ hexo generate --deploy 缩写的命令也是可以的。1$ hexo g --d 开开心心。。。。 最后唠叨几句 记得关掉vpn代理啥的，不然ssh可能会有问题 发现一篇很好的介绍hexo的文章，戳Hexo在github上构建免费的Web应用 明天又要上班了，终于又可以开心的建设社会主义了。。。。。。（逃","tags":[{"name":"hexo","slug":"hexo","permalink":"http://yvshuo.github.io/tags/hexo/"}]},{"title":"使用hexo在github上搭建博客的记录","date":"2016-10-05T16:40:58.000Z","path":"2016/10/06/2016-10-06-create/","text":"工作已经一年了，想着该稍微停下来总结一下了。恰巧印象笔记开始限终端限流量。于是就有了写博客记录一下日常感想，同时将之前的一些笔记迁移到博客的想法。 在github闲逛的时候看到了Litten的博客，很是喜欢。于是发现了hexo,各种特性都让我甚是喜欢，就这么对Hexo一见钟情了。在知乎上搜到了一篇介绍hexo主题的回答,一圈看下来，还是比较喜欢Yilia这个主题，也就是我最早看到的Litten开发的~缘分啊，（逃 于是果断决定使用这个主题，计划着先直接用着，后续有时间的话自己也试着DIY一下自己的主题。 废话不多说了，简单的记录一下第一次搭建Hexo博客的过程。 概述Hexo是在nodejs环境下搭建的，在npm的帮助下几行命令就轻松搞定，简直是轻松愉快。当然了，前提是已经安装好了git和nodejs。 12345$ npm install hexo-cli -g$ hexo init blog$ cd blog$ npm install$ hexo server 切换主题同样很方便，到博客的根目录下，将主题git下来。 1$ git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 然后修改根目录下_config.yml中的配置项theme: yilia。如果server是在运行状态下，甚至都不需要重启。只需要刷新下页面，新的主题就已经换上去了。开开心心- - 新建文章1$ hexo new \"我的文章\" 这样就会生成一篇叫“我的文章”的文章了。默认会在_posts文件夹下新建一个对应的markdown文件“我的文章.md”，编辑这个md文件就可以写文章并发布了。格式遵循md的语法。 生成静态文件1$ hexo generate 生成的静态文件在public文件夹中，这些文件就可以提交到github来搭建自己的个人博客了~简直炫酷。 发布到github上每个github账号下都默认有一个自己的XXX.github.io的子域名，可以部署静态代码来生成自己的网站。 譬如我的github账号是yvshuo,于是我要新建一个名字叫做yvshuo.github.io的项目。然后到刚才生成的public文件下将代码提交到github仓库里。如果不熟悉git操作，可以参看git-简明指南快速入手。 123456$ cd public/$ git init$ git add --all$ git commit -m \"create\"$ git remote add origin https://github.com/yvshuo/yvshuo.github.io.git$ git push -u origin master 然后就是享受成果的时候了~~yvshuo 一点点小补充 除了上面说的最基本的一些东西外，还有很多配置和可以自己来diy的东西。具体可参考hexo的中文文档。再次表达对hexo的爱~ md编辑器可以自己在sublime text里配，也可以用专门的编辑器，如MarkdownPad。当然，我觉得最爽的还是在本地开着hexo server然后监听文件变动自动部署，再直接在浏览器里F5~ 今天第一次接触hexo，还有待后续进一步发掘这个工具的强大之处 立FLAG 要把这个博客经营下去。谢老师监督我→_→","tags":[{"name":"hexo","slug":"hexo","permalink":"http://yvshuo.github.io/tags/hexo/"}]}]