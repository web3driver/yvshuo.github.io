<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
    
  
  <title>
    阿里巴巴java开发手册解读4-OOP 规约|香辣猪蹄儿
  </title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="1. 【强制】避免通过一个类的对象引用访问此类的静态变量或静态方法,无谓增加编译器解析成本,直接用类名来访问即可
批注:正例:Integer.parseInt(&quot;1&quot;);

反例:Integer i = new Integer(0);i.parseInt(&quot;1&quot;);">
<meta property="og:type" content="article">
<meta property="og:title" content="阿里巴巴java开发手册解读4-OOP 规约">
<meta property="og:url" content="http://yvshuo.github.io/2017/02/13/2017-02-10-javarule-4/index.html">
<meta property="og:site_name" content="香辣猪蹄儿">
<meta property="og:description" content="1. 【强制】避免通过一个类的对象引用访问此类的静态变量或静态方法,无谓增加编译器解析成本,直接用类名来访问即可
批注:正例:Integer.parseInt(&quot;1&quot;);

反例:Integer i = new Integer(0);i.parseInt(&quot;1&quot;);">
<meta property="og:updated_time" content="2017-02-13T15:21:37.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="阿里巴巴java开发手册解读4-OOP 规约">
<meta name="twitter:description" content="1. 【强制】避免通过一个类的对象引用访问此类的静态变量或静态方法,无谓增加编译器解析成本,直接用类名来访问即可
批注:正例:Integer.parseInt(&quot;1&quot;);

反例:Integer i = new Integer(0);i.parseInt(&quot;1&quot;);">
  
    <link rel="alternate" href="/atom.xml" title="config.title" type="application/atom+xml">
  
  
    <link rel="icon" href="/blog/assets/images/global/favicon.ico" >
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/blog/css/page.css">
  <script src="/blog/js/vue.min.js"></script>
  <script>window.PAGE_TYPE = ""</script>
</head>
<body class="docs">
  
  <div id="mobile-bar" >
  <a class="menu-button"></a>
  <a class="logo" href="/"></a>
</div>
  <div id="header">
  <a id="logo" href="/">
    <img src="/blog/img/avatar.jpg">
    <span>香辣猪蹄儿</span>
  </a>
  <ul id="nav">
    <li><a href="/blog" class="nav-link">首页</a></li>
<li><a href="/blog/archives" class="nav-link">文章列表</a></li>
<li><a href="/blog/docs" class="nav-link">文档</a></li>

  </ul>
</div>

  <div id="main" class="fix-sidebar">
      
    <div class="sidebar blog">
        <ul class="main-menu">
            <li><a href="/blog" class="nav-link">首页</a></li>
<li><a href="/blog/archives" class="nav-link">文章列表</a></li>
<li><a href="/blog/docs" class="nav-link">文档</a></li>

        </ul>
        <div class="list">
            <h2>
                最新文章
            </h2>
            <ul style="padding:0">
            
            
                
                    <li>
                        <a href="/blog/2017/03/25/2017-03-25-es6-4/" class="sidebar-link">Promises</a>
                    </li>
                
            
                
                    <li>
                        <a href="/blog/2017/03/25/2017-03-25-es6-3/" class="sidebar-link">Modules</a>
                    </li>
                
            
                
                    <li>
                        <a href="/blog/2017/03/19/2017-03-19-es6-2/" class="sidebar-link">Default + Rest + Spread</a>
                    </li>
                
            
                
                    <li>
                        <a href="/blog/2017/03/19/2017-03-19-es6-1/" class="sidebar-link">Arrows and Lexical This</a>
                    </li>
                
            
                
                    <li>
                        <a href="/blog/2017/02/23/2017-02-23-javarule-9/" class="sidebar-link">阿里巴巴java开发手册解读9-其他编程规约</a>
                    </li>
                
            
                
                    <li>
                        <a href="/blog/2017/02/23/2017-02-23-javarule-8/" class="sidebar-link">阿里巴巴java开发手册解读8-注释规约</a>
                    </li>
                
            
                
                    <li>
                        <a href="/blog/2017/02/22/2017-02-22-javarule-7/" class="sidebar-link">阿里巴巴java开发手册解读7-控制语句</a>
                    </li>
                
            
                
                    <li>
                        <a href="/blog/2017/02/18/2017-02-18-javarule-6/" class="sidebar-link">阿里巴巴java开发手册解读6-并发处理</a>
                    </li>
                
            
                
                    <li>
                        <a href="/blog/2017/02/17/2017-02-17-javarule-5/" class="sidebar-link">阿里巴巴java开发手册解读5-集合处理</a>
                    </li>
                
            
                
                    <li>
                        <a href="/blog/2017/02/13/2017-02-10-javarule-4/" class="sidebar-link current">阿里巴巴java开发手册解读4-OOP 规约</a>
                    </li>
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
            </ul>
        </div>
    </div>
    <div class="content with-sidebar blog post">
        <h1>阿里巴巴java开发手册解读4-OOP 规约</h1>
        <h4>Feb 13, 2017</h4>
        <h3 id="1-【强制】避免通过一个类的对象引用访问此类的静态变量或静态方法-无谓增加编译器解析成本-直接用类名来访问即可"><a href="#1-【强制】避免通过一个类的对象引用访问此类的静态变量或静态方法-无谓增加编译器解析成本-直接用类名来访问即可" class="headerlink" title="1. 【强制】避免通过一个类的对象引用访问此类的静态变量或静态方法,无谓增加编译器解析成本,直接用类名来访问即可"></a>1. 【强制】避免通过一个类的对象引用访问此类的静态变量或静态方法,无谓增加编译器解析成本,直接用类名来访问即可</h3><blockquote>
<p><strong>批注</strong>:<br><code>正例</code>:<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">Integer.parseInt(<span class="string">"1"</span>);</div></pre></td></tr></table></figure></p>
</blockquote>
<p><code>反例</code>:<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">Integer i = new Integer(0);</div><div class="line">i.parseInt(<span class="string">"1"</span>);</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<h3 id="2-【强制】所有的覆写方法-必须加-Override注解"><a href="#2-【强制】所有的覆写方法-必须加-Override注解" class="headerlink" title="2. 【强制】所有的覆写方法,必须加@Override注解"></a>2. 【强制】所有的覆写方法,必须加@Override注解</h3><p>反例:getObject()与 get0bject()的问题。一个是字母的 O,一个是数字的 0,加@Override 可以准确判断是否覆盖成功。另外,如果在抽象类中对方法签名进行修改,其实现类会马上编译报错。</p>
<blockquote>
<p><strong>批注</strong>:@Override会去检查是否和覆写类的名字相同</p>
</blockquote>
<h3 id="3-【强制】相同参数类型-相同业务含义-才可以使用-Java-的可变参数-避免使用-Object"><a href="#3-【强制】相同参数类型-相同业务含义-才可以使用-Java-的可变参数-避免使用-Object" class="headerlink" title="3. 【强制】相同参数类型,相同业务含义,才可以使用 Java 的可变参数,避免使用 Object"></a>3. 【强制】相同参数类型,相同业务含义,才可以使用 Java 的可变参数,避免使用 Object</h3><p>说明:可变参数必须放置在参数列表的最后。<strong>(提倡同学们尽量不用可变参数编程)</strong><br><code>正例</code>:public User getUsers(String type, Integer… ids)</p>
<h3 id="4-【强制】对外暴露的接口签名-原则上不允许修改方法签名-避免对接口调用方产生影响"><a href="#4-【强制】对外暴露的接口签名-原则上不允许修改方法签名-避免对接口调用方产生影响" class="headerlink" title="4. 【强制】对外暴露的接口签名,原则上不允许修改方法签名,避免对接口调用方产生影响"></a>4. 【强制】对外暴露的接口签名,原则上不允许修改方法签名,避免对接口调用方产生影响</h3><p>接口过时必须加@Deprecated 注解,并清晰地说明采用的新接口或者新服务是什么。</p>
<blockquote>
<p><strong>批注</strong>:接口重构中的一项基本原则</p>
</blockquote>
<h3 id="5-【强制】不能使用过时的类或方法"><a href="#5-【强制】不能使用过时的类或方法" class="headerlink" title="5. 【强制】不能使用过时的类或方法"></a>5. 【强制】不能使用过时的类或方法</h3><p>说明:java.net.URLDecoder 中的方法 decode(String encodeStr) 这个方法已经过时,应该使用双参数 decode(String source, String encode)。接口提供方既然明确是过时接口, 那么有义务同时提供新的接口;作为调用方来说,有义务去考证过时方法的新实现是什么。</p>
<h3 id="6-【强制】Object-的-equals-方法容易抛空指针异常-应使用常量或确定有值的对象来调用equals。"><a href="#6-【强制】Object-的-equals-方法容易抛空指针异常-应使用常量或确定有值的对象来调用equals。" class="headerlink" title="6. 【强制】Object 的 equals 方法容易抛空指针异常,应使用常量或确定有值的对象来调用equals。"></a>6. 【强制】Object 的 equals 方法容易抛空指针异常,应使用常量或确定有值的对象来调用equals。</h3><p><code>正例</code>: “test”.equals(object);<br><code>反例</code>: object.equals(“test”);<br>说明:推荐使用java.util.Objects#equals (JDK7引入的工具类)</p>
<blockquote>
<p><strong>批注</strong>:想起自己每次都是判断一下object是否实例化然后再使用反例- -捂脸</p>
</blockquote>
<h3 id="7-【强制】所有的相同类型的包装类对象之间值的比较-全部使用-equals-方法比较"><a href="#7-【强制】所有的相同类型的包装类对象之间值的比较-全部使用-equals-方法比较" class="headerlink" title="7. 【强制】所有的相同类型的包装类对象之间值的比较,全部使用 equals 方法比较"></a>7. 【强制】所有的相同类型的包装类对象之间值的比较,全部使用 equals 方法比较</h3><p>说明:对于Integer var=?在-128至127之间的赋值,Integer对象是在 IntegerCache.cache 产生,会复用已有对象,这个区间内的 Integer 值可以直接使用==进行 判断,但是这个区间之外的所有数据,都会在堆上产生,并不会复用已有对象,这是一个大坑, 推荐使用 equals 方法进行判断。</p>
<h3 id="8-【强制】关于基本数据类型与包装数据类型的使用标准如下"><a href="#8-【强制】关于基本数据类型与包装数据类型的使用标准如下" class="headerlink" title="8. 【强制】关于基本数据类型与包装数据类型的使用标准如下:"></a>8. 【强制】关于基本数据类型与包装数据类型的使用标准如下:</h3><p><strong>1) 所有的POJO类属性必须使用包装数据类型。</strong><br><strong>2) RPC方法的返回值和参数必须使用包装数据类型。</strong><br><strong>3) 所有的局部变量【推荐】使用基本数据类型。</strong><br>说明:POJO 类属性没有初值是提醒使用者在需要使用时,必须自己显式地进行赋值,任何NPE问题,或者入库检查,都由使用者来保证。<br><code>正例</code>:数据库的查询结果可能是 null,因为自动拆箱,用基本数据类型接收有 NPE 风险。<br><code>反例</code>:比如显示成交总额涨跌情况,即正负 x%,x 为基本数据类型,调用的 RPC 服务,调用不成功时,返回的是默认值,页面显示:0%,这是不合理的,应该显示成中划线-。所以包装 数据类型的 null 值,能够表示额外的信息,如:远程调用失败,异常退出。</p>
<blockquote>
<p><strong>批注</strong>:NPE是指空指针异常。在单位的java项目中经常遇到复杂的POJO类。这条准则就是将处理NPE的职责进行明确划分，将POJO类的检查交给使用者。</p>
</blockquote>
<h3 id="9-【强制】定义-DO-DTO-VO-等-POJO-类时-不要设定任何属性默认值"><a href="#9-【强制】定义-DO-DTO-VO-等-POJO-类时-不要设定任何属性默认值" class="headerlink" title="9. 【强制】定义 DO/DTO/VO 等 POJO 类时,不要设定任何属性默认值"></a>9. 【强制】定义 DO/DTO/VO 等 POJO 类时,不要设定任何属性默认值</h3><p><code>反例</code>:POJO类的gmtCreate默认值为new Date();但是这个属性在数据提取时并没有置入具体值,在更新其它字段时又附带更新了此字段,导致创建时间被修改成当前时间。</p>
<blockquote>
<p><strong>批注</strong>:不给POJO类设置属性默认值，避免出现奇奇怪怪的问题</p>
</blockquote>
<h3 id="10-【强制】序列化类新增属性时-请不要修改-serialVersionUID-字段-避免反序列失败"><a href="#10-【强制】序列化类新增属性时-请不要修改-serialVersionUID-字段-避免反序列失败" class="headerlink" title="10. 【强制】序列化类新增属性时,请不要修改 serialVersionUID 字段,避免反序列失败"></a>10. 【强制】序列化类新增属性时,请不要修改 serialVersionUID 字段,避免反序列失败</h3><p>如果完全不兼容升级,避免反序列化混乱,那么请修改 serialVersionUID 值。<br>说明:注意 serialVersionUID 不一致会抛出序列化运行时异常。</p>
<h3 id="11-【强制】构造方法里面禁止加入任何业务逻辑-如果有初始化逻辑-请放在-init-方法中"><a href="#11-【强制】构造方法里面禁止加入任何业务逻辑-如果有初始化逻辑-请放在-init-方法中" class="headerlink" title="11. 【强制】构造方法里面禁止加入任何业务逻辑,如果有初始化逻辑,请放在 init 方法中"></a>11. 【强制】构造方法里面禁止加入任何业务逻辑,如果有初始化逻辑,请放在 init 方法中</h3><h3 id="12-【强制】POJO-类必须写-toString-方法。使用-IDE-的中工具-source-gt-generate-toString-时-如果继承了另一个-POJO-类-注意在前面加一下-super-toString。"><a href="#12-【强制】POJO-类必须写-toString-方法。使用-IDE-的中工具-source-gt-generate-toString-时-如果继承了另一个-POJO-类-注意在前面加一下-super-toString。" class="headerlink" title="12. 【强制】POJO 类必须写 toString 方法。使用 IDE 的中工具:source&gt; generate toString 时,如果继承了另一个 POJO 类,注意在前面加一下 super.toString。"></a>12. 【强制】POJO 类必须写 toString 方法。使用 IDE 的中工具:source&gt; generate toString 时,如果继承了另一个 POJO 类,注意在前面加一下 super.toString。</h3><p>说明:在方法执行抛出异常时,可以直接调用 POJO 的 toString()方法打印其属性值,便于排查问题。</p>
<blockquote>
<p><strong>批注</strong>:这项应该是阿里巴巴的经验，这种方法更便于日志调错。重写toString方法后就不需要再断点看值了。</p>
</blockquote>
<h3 id="13-【推荐】使用索引访问用-String-的-split-方法得到的数组时-需做最后一个分隔符后有无内容的检查-否则会有抛-IndexOutOfBoundsException-的风险。"><a href="#13-【推荐】使用索引访问用-String-的-split-方法得到的数组时-需做最后一个分隔符后有无内容的检查-否则会有抛-IndexOutOfBoundsException-的风险。" class="headerlink" title="13. 【推荐】使用索引访问用 String 的 split 方法得到的数组时,需做最后一个分隔符后有无内容的检查,否则会有抛 IndexOutOfBoundsException 的风险。"></a>13. 【推荐】使用索引访问用 String 的 split 方法得到的数组时,需做最后一个分隔符后有无内容的检查,否则会有抛 IndexOutOfBoundsException 的风险。</h3><p>说明:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">String str = <span class="string">"a,b,c,,"</span>;</div><div class="line">String[] ary = str.split(<span class="string">","</span>); <span class="comment">//预期大于 3,结果是 3 System.out.println(ary.length);</span></div></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>批注</strong>:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">String str = <span class="string">"a,b,,c,,"</span>;</div><div class="line">String[] ary = str.split(<span class="string">","</span>); <span class="comment">//返回结果为4，只有最后一个分隔符需要做检查</span></div></pre></td></tr></table></figure></p>
</blockquote>
<p>在使用索引的时候，一般还是要判断一下length再访问</p>
<h3 id="14-【推荐】当一个类有多个构造方法-或者多个同名方法-这些方法应该按顺序放置在一起-便于阅读"><a href="#14-【推荐】当一个类有多个构造方法-或者多个同名方法-这些方法应该按顺序放置在一起-便于阅读" class="headerlink" title="14. 【推荐】当一个类有多个构造方法,或者多个同名方法,这些方法应该按顺序放置在一起, 便于阅读"></a>14. 【推荐】当一个类有多个构造方法,或者多个同名方法,这些方法应该按顺序放置在一起, 便于阅读</h3><h3 id="15-【推荐】-类内方法定义顺序依次是-公有方法或保护方法-gt-私有方法-gt-getter-setter方法"><a href="#15-【推荐】-类内方法定义顺序依次是-公有方法或保护方法-gt-私有方法-gt-getter-setter方法" class="headerlink" title="15.【推荐】 类内方法定义顺序依次是:公有方法或保护方法 &gt; 私有方法 &gt; getter/setter方法"></a>15.【推荐】 类内方法定义顺序依次是:公有方法或保护方法 &gt; 私有方法 &gt; getter/setter方法</h3><p>说明:公有方法是类的调用者和维护者最关心的方法,首屏展示最好;保护方法虽然只是子类 关心,也可能是“模板设计模式”下的核心方法;而私有方法外部一般不需要特别关心,是一个 黑盒实现;因为方法信息价值较低,所有 Service 和 DAO 的 getter/setter 方法放在类体最 后。</p>
<h3 id="16-【推荐】setter-方法中-参数名称与类成员变量名称一致-this-成员名-参数名。在getter-setter-方法中-尽量不要增加业务逻辑-增加排查问题的难度。"><a href="#16-【推荐】setter-方法中-参数名称与类成员变量名称一致-this-成员名-参数名。在getter-setter-方法中-尽量不要增加业务逻辑-增加排查问题的难度。" class="headerlink" title="16. 【推荐】setter 方法中,参数名称与类成员变量名称一致,this.成员名=参数名。在getter/setter 方法中,尽量不要增加业务逻辑,增加排查问题的难度。"></a>16. 【推荐】setter 方法中,参数名称与类成员变量名称一致,this.成员名=参数名。在getter/setter 方法中,尽量不要增加业务逻辑,增加排查问题的难度。</h3><p><code>反例</code>:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">getData</span><span class="params">()</span></span>&#123; </div><div class="line">    <span class="keyword">if</span>(<span class="keyword">true</span>) &#123;</div><div class="line">        <span class="keyword">return</span> data + <span class="number">100</span>; </div><div class="line">    &#125;<span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> data - <span class="number">100</span>; </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>批注</strong>:有些框架会默认去用get+set属性名去操作属性值，所以直接用eclipse的source-&gt;generate getter/setter吧</p>
</blockquote>
<h3 id="17-【推荐】循环体内-字符串的联接方式-使用-StringBuilder-的-append-方法进行扩展。"><a href="#17-【推荐】循环体内-字符串的联接方式-使用-StringBuilder-的-append-方法进行扩展。" class="headerlink" title="17. 【推荐】循环体内,字符串的联接方式,使用 StringBuilder 的 append 方法进行扩展。"></a>17. 【推荐】循环体内,字符串的联接方式,使用 StringBuilder 的 append 方法进行扩展。</h3><p><code>反例</code>:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">String str = <span class="string">"start"</span>; </div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++)&#123;</div><div class="line">    str = str + <span class="string">"hello"</span>; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>说明:反编译出的字节码文件显示每次循环都会 new 出一个 StringBuilder 对象,然后进行 append 操作,最后通过 toString 方法返回 String 对象,造成内存资源浪费。</p>
<blockquote>
<p><strong>批注</strong>:<br>使用下面的测试代码就可以只管看出两者的区别：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer();</div><div class="line">String str = <span class="keyword">new</span> String();</div><div class="line"><span class="keyword">long</span> startTime1=System.currentTimeMillis();</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</div><div class="line">    sb.append(<span class="string">"hello"</span>);</div><div class="line">&#125;</div><div class="line">sb.toString();</div><div class="line"><span class="keyword">long</span> endTime1=System.currentTimeMillis();</div><div class="line"><span class="keyword">long</span> startTime2=System.currentTimeMillis();</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</div><div class="line">    str = str + <span class="string">"hello"</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">long</span> endTime2=System.currentTimeMillis();</div><div class="line">System.out.println(<span class="string">"StringBuffer耗时:"</span>+(endTime1-startTime1)+<span class="string">"ms"</span>);</div><div class="line">System.out.println(<span class="string">"加号连接耗时:"</span>+(endTime2-startTime2)+<span class="string">"ms"</span>);</div></pre></td></tr></table></figure></p>
</blockquote>
<p>测试结果:<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">StringBuffer耗时:4ms</div><div class="line">加号连接耗时:205ms</div></pre></td></tr></table></figure></p>
<h3 id="18-【推荐】final-可提高程序响应效率-声明成-final-的情况"><a href="#18-【推荐】final-可提高程序响应效率-声明成-final-的情况" class="headerlink" title="18. 【推荐】final 可提高程序响应效率,声明成 final 的情况:"></a>18. 【推荐】final 可提高程序响应效率,声明成 final 的情况:</h3><p><strong>1) 不需要重新赋值的变量,包括类属性、局部变量。</strong><br><strong>2) 对象参数前加final,表示不允许修改引用的指向。</strong><br><strong>3) 类方法确定不允许被重写。</strong></p>
<h3 id="19-【推荐】慎用-Object-的-clone-方法来拷贝对象"><a href="#19-【推荐】慎用-Object-的-clone-方法来拷贝对象" class="headerlink" title="19. 【推荐】慎用 Object 的 clone 方法来拷贝对象"></a>19. 【推荐】慎用 Object 的 clone 方法来拷贝对象</h3><p>说明:对象的 clone 方法默认是浅拷贝,若想实现深拷贝需要重写 clone 方法实现属性对象的拷贝。</p>
<blockquote>
<p><strong>批注</strong>:浅拷贝是指拷贝对象时仅仅拷贝对象本身（包括对象中的基本变量），而不拷贝对象包含的引用指向的对象。深拷贝不仅拷贝对象本身，而且拷贝对象包含的引用指向的所有对象。举例来说更加清楚：对象A1中包含对B1的引用，B1中包含对C1的引用。浅拷贝A1得到A2，A2 中依然包含对B1的引用，B1中依然包含对C1的引用。深拷贝则是对浅拷贝的递归，深拷贝A1得到A2，A2中包含对B2（B1的copy）的引用，B2 中包含对C2（C1的copy）的引用。</p>
</blockquote>
<h3 id="20-【推荐】类成员与方法访问控制从严"><a href="#20-【推荐】类成员与方法访问控制从严" class="headerlink" title="20. 【推荐】类成员与方法访问控制从严:"></a>20. 【推荐】类成员与方法访问控制从严:</h3><p><strong>1) 如果不允许外部直接通过new来创建对象,那么构造方法必须是private。</strong><br><strong>2) 工具类不允许有public或default构造方法。</strong><br><strong>3) 类非static成员变量并且与子类共享,必须是protected。</strong><br><strong>4) 类非static成员变量并且仅在本类使用,必须是private。</strong><br><strong>5) 类static成员变量如果仅在本类使用,必须是private。</strong><br><strong>6) 若是static成员变量,必须考虑是否为final。</strong><br><strong>7) 类成员方法只供类内部调用,必须是private。</strong><br><strong>8) 类成员方法只对继承类公开,那么限制为protected。</strong><br>说明:任何类、方法、参数、变量,严控访问范围。过宽泛的访问范围,不利于模块解耦。<br>思考:如果是一个 private 的方法,想删除就删除,可是一个 public 的 Service 方法,或者一 个 public 的成员变量,删除一下,不得手心冒点汗吗?变量像自己的小孩,尽量在自己的视 线内,变量作用域太大,如果无限制的到处跑,那么你会担心的。</p>

        <div class="guide-links">
            
                <span>← <a href="/blog/2017/02/17/2017-02-17-javarule-5/">阿里巴巴java开发手册解读5-集合处理</a></span>
            
            
                <span style="float:right"><a href="/blog/2017/02/10/2017-02-10-javarule-3/">阿里巴巴java开发手册解读3-格式规约</a> →</span>
            
        </div>
    </div>

  </div>
  
  
<script>
var topScrolled = false
window.addEventListener('scroll', function () {
  if (window.pageYOffset > 165 && !topScrolled) {
    topScrolled = true
    document.getElementById('mobile-bar').classList.remove('top')
  } else if (window.pageYOffset <= 165 && topScrolled) {
    topScrolled = false
    document.getElementById('mobile-bar').classList.add('top')
  }
})
</script>
<script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script>
<script src="/blog/js/script.js"></script>
<script src="/blog/js/common.js"></script>
<script>

    let $a = document.querySelectorAll(('.blog p:not(.article-more-link)>a'))
    $a.forEach(($em) => {
      $em.setAttribute('target', '_blank')
    })
    let $b = document.querySelectorAll(('.docs p>a'))
    $b.forEach(($em) => {
      $em.setAttribute('target', '_blank')
    })

</script>

</body>
</html>

