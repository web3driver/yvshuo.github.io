[{"title":"javascript常见判断研究","date":"2017-05-10T12:48:17.000Z","path":"2017/05/10/2017-05-10-is/","text":"我的参考对象是 is 这个被经常使用的npm包。 在研究这个包之前，先看一看最新版本的ECMASCRIPT对类型的基本介绍： The ECMAScript language types are Undefined, Null, Boolean, String, Symbol, Number, and Object.Undefined : The Undefined type has exactly one value, called undefined. Any variable that has not been assigned a value has the value undefined.Null : The Null type has exactly one value, called null.Boolean : The Boolean type represents a logical entity having two values, called true and false.String : The String type is the set of all ordered sequences of zero or more 16-bit unsigned integer values (“elements”) up to a maximum length of 253-1 elements.Symbol : The Symbol type is the set of all non-String values that may be used as the key of an Object property.Number : The Number type has exactly 18437736874454810627 (that is, 264-253+3) values, representing the double-precision 64-bit format IEEE 754-2008 values as specified in the IEEE Standard for Binary Floating-Point Arithmetic, except that the 9007199254740990 (that is, 253-2) distinct “Not-a-Number” values of the IEEE Standard are represented in ECMAScript as a single special NaN value. There are two other special values, called positive Infinity and negative Infinity.Object : An Object is logically a collection of properties. 引自 https://tc39.github.io/ecma262/ 1、基本判断 undefined虽然Object.prototype.toString.call(undefined) === &#39;[object Undefined]&#39;可以返回true,但是对于未定义的变量会报错，所以还是使用typeof来判断。 function isUndefined (value) &#123; return typeof value === 'undefined';&#125;; null 注意 `typeof null`是`object`。function isNull (value) &#123; return value === null;&#125;; boolean function isBoolean (value) &#123; return Object.prototype.toString.call(value) === '[object Boolean]';&#125; string function isString (value) &#123; return Object.prototype.toString.call(value) === '[object String]';&#125; number function isNumber (value) &#123; return Object.prototype.toString.call(value) === '[object Number]';&#125; object function isObject (value) &#123; return Object.prototype.toString.call(value) === '[object Object]';&#125; function function isFunction (value) &#123; var isAlert = typeof window !== 'undefined' &amp;&amp; value === window.alert; if (isAlert) &#123; return true; &#125; var str = Object.prototype.toString.call(value); return str === '[object Function]' || str === '[object GeneratorFunction]' || str === '[object AsyncFunction]';&#125; regExp function isRegExp (value) &#123; return Object.prototype.toString.call(value) === '[object RegExp]';&#125; array function isArray (value) &#123; return Object.prototype.toString.call(value) === '[object Array]';&#125; 2、特殊的一些判断 判断一个值是否为空 function isEmpty (value) &#123; var type = Object.prototype.toString.call(value); var key; if (type === '[object Array]' || type === '[object Arguments]' || type === '[object String]') &#123; return value.length === 0; &#125; if (type === '[object Object]') &#123; for (key in value) &#123; if (Object.prototype.hasOwnProperty.call(value, key)) &#123; return false; &#125; &#125; return true; &#125; return !value;&#125; 判断两个值是否相等 function isEqual (value, other) &#123; // 基本类型直接判断 if (value === other) &#123; return true; &#125; var type = Object.prototype.toString.call(value); var key; if (type !== Object.prototype.toString.call(other)) &#123; return false; &#125; // 遍历key和值，都相等的话相等 if (type === '[object Object]') &#123; for (key in value) &#123; if (!isEqual(value[key], other[key]) || !(key in other)) &#123; return false; &#125; &#125; for (key in other) &#123; if (!is.equal(value[key], other[key]) || !(key in value)) &#123; return false; &#125; &#125; return true; &#125; if (type === '[object Array]') &#123; key = value.length; if (key !== other.length) &#123; return false; &#125; while (key--) &#123; if (!isEqual(value[key], other[key])) &#123; return false; &#125; &#125; return true; &#125; // 这个。。见仁见智吧 if (type === '[object Function]') &#123; return value.prototype === other.prototype; &#125; if (type === '[object Date]') &#123; return value.getTime() === other.getTime(); &#125; return false;&#125; 检测类数组对象因为标准里对类数组的定义并不是很明确，所以我还是更倾向于犀牛书里的这个检验方法。 function isArrayLike (value) &#123; return !!value &amp;&amp; typeof value === 'object' &amp;&amp; Object.prototype.hasOwnProperty.call(value, 'length') &amp;&amp; Object.prototype.toString.call(value.length) === '[object Number]' &amp;&amp; isFinite(value.length) &amp;&amp; value.length % 1 === 0 &amp;&amp; value.length &gt;= 0 &amp;&amp; value.length &lt; 2^53 - 1;&#125; is库中并没有校验length的属性是否为整数，然后我给作者提了一个PR，和其中一位作者有了 #31里的讨论。。。他说因为标准里会把array-like数组的length属性转成整数，所以并不需要这样的校验。 This is a great intuition to spot - but this isn’t actually required; the spec coerces non-integers to integers (see https://tc39.github.io/ecma262/#sec-createlistfromarraylike step 3), so { length: 1.2, 0: ‘a’ } is a perfectly valid arraylike. https://github.com/enricomarino/is/pull/31 其实我心里还是有些不明白的，既然标准里使用length属性时候会规定执行tolength，那么标准里的tolength是这么说的： The abstract operation ToLength converts argument to an integer suitable for use as the length of an array-like object. It performs the following steps: Let len be ? ToInteger(argument). // 转成整数 If len ≤ +0, return +0. // 转成+0 Return min(len, 2^53-1). // 取有限位 https://tc39.github.io/ecma262/#sec-tolength 再看看tointeger: The abstract operation ToInteger converts argument to an integral numeric value. This abstract operation functions as follows: Let number be ? ToNumber(argument). If number is NaN, return +0. If number is +0, -0, +∞, or -∞, return number. Return the number value that is the same sign as number and whose magnitude is floor(abs(number)). https://tc39.github.io/ecma262/#sec-tointeger 那么按照他的说法，我们也不需要校验这个数是否为正以及是否有限了。于是又追了一个问题。个人认为，虽然说js编译器可能不会在意你的类数组的length是否为一些奇怪的属性或值，但是我觉得正常情况下，length是这些值的话还是显得有些奇怪。所以我觉得还是应该都校验一下。以及希望ECMA262啥时候能给一个标准的array-like的定义。","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yvshuo.github.io/tags/javascript/"},{"name":"library","slug":"library","permalink":"http://yvshuo.github.io/tags/library/"}]},{"title":"说一说数组去重","date":"2017-05-10T04:04:17.000Z","path":"2017/05/10/2017-05-10-NaN/","text":"首先看一道题目。 题目描述:为 Array 对象添加一个去除重复项的方法 输入例子:[false, true, undefined, null, NaN, 0, 1, {}, {}, ‘a’, ‘a’, NaN].uniq() 输出例子:[false, true, undefined, null, NaN, 0, 1, {}, {}, ‘a’] 我的第一次解法（不考虑参数异常情况）：Array.prototype.uniq = function () &#123; var result = []; var hash = &#123;&#125;; for (var i = 0; i &lt; this.length; i++) &#123; var arr = this[i]; if(!hash[arr]) &#123; hash[arr] = true; result.push(arr); &#125; &#125; return result;&#125; 输出结果是：[false, true, undefined, null, NaN, 0, 1, Object, \"a\"] 仔细看了一下原题，发现对象并没有被去重。仔细想了一下，对象类型确实不应该被去重，因为{}!=={}. 我的第二次解法：Array.prototype.uniq = function () &#123; var result = []; for (var i = 0; i &lt; this.length; i++) &#123; if (this.indexOf(this[i]) === i) &#123; result.push(this[i]); &#125; &#125; return result;&#125; 输出结果是：[false, true, undefined, null, 0, 1, Object, Object, \"a\"] 黑人问号脸。NaN不见了。问stackoverflow： NaN is defined not to be equal to anything (not even itself). NaN === NaN 输出：false 翻开犀牛书37页。 没办法通过x==NaN来普安段变量x是否为NaN。应当使用x!=x来判断，当且仅当x为NaN时才为true。 最终答案：Array.prototype.uniq = function () &#123; var result = []; var flag = true; for (var i = 0; i &lt; this.length; i++) &#123; if (this.indexOf(this[i]) === i) &#123; result.push(this[i]); &#125; else if (this[i] !== this[i]) &#123; if (flag) &#123; result.push(this[i]); flag = false; &#125; &#125; &#125; return result;&#125; 虽然实际项目中很少会遇到这种极端的情况，不过确实是又巩固了一遍基础。 后记最近越来越觉得夯实基础很重要很重要。框架在不停的变，而基础的东西才能决定是否能深刻理解框架的一些深层次的东西。加油。","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yvshuo.github.io/tags/javascript/"}]},{"title":"js作用域链","date":"2017-04-27T13:13:55.000Z","path":"2017/04/27/2017-04-27-scopechain/","text":"1. Scope Chainvar test = 1;function f() &#123; console.log(test); var test = 2;&#125;f();console.log(test); 输出的结果是什么呢？undefined1 搬出小红书的概念定义： 每个函数都有自己的执行环境。当执行流进入一个函数时,函数的环境就会被推入一个环境栈中。 而在函数执行之后,栈将其环境弹出,把控制权返回给之前的执行环境。 当代码在一个环境中执行时,会创建变量对象的一个作用域链(scope chain)。作用域链的用途,是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端,始终都是当前执行的代码所在环境的变量对象。如果这个环境是函数,则将其活动对象(activation object)作为变量对象。活动对象在最开始时只包含一个变量,即 arguments 对象(这个对象在全局环境中是不存在的)。作用域链中的下一个变量对象来自包含(外部)环境,而再下一个变量对象则来自下一个包含环境。这样,一直延续到全局执行环境;全局执行环境的变量对象始终都是作用域链中的最后一个对象。 最佳实践都告诉我们js编程应该在函数的最开始声明变量，可是在遵守这个规则的时候，之前却一直不明白为什么要这样做。上面的例子就是一个违反最佳实践后的奇怪场景：在全局环境中声明了一个变量，然后在函数中调用了这个全局变量。如果在之后不巧又声明了一个同名的局部变量，前面对全局变量的引用就出现了奇怪的undefined。在严格模式或者eslint中，重复声明都会报错。所以上面的例子可以作为是一道对js作用域链加深理解的题目。 上面这个例子的分析：step1: 这段代码共有两个执行环境：全局环境和f()的局部环境step2: 全局环境中有一个变量test 和 一个函数 f()step3: f()中有一个变量test 这里需要注意的就是在js的作用域中，var 声明的变量提升提升的是变量的声明，并不会把变量的赋值也提升上来 step4: f()函数执行到console.log(test)这一句时，先在作用域链最顶端查找，也就是f()内部这个作用域，因为var test = 2;被提升，而此时还没有被赋值，所以此时test是undefined，f()内的代码等同于function f() &#123; var test; console.log(test); test = 2;&#125; step5: f()执行完后，对应的f()的执行环境从环境栈中弹出，进入全局执行环境。此时在f()内的变量被js的垃圾回收标记为可清除step6: 执行到最后一句，console.log(test)在全局作用域中查找，打印出test的值 1 2. 函数声明的提升f();function f() &#123; console.log('test');&#125; 这个是常见的写法。输出test。但是为什么可以这样写？因为在进入执行环境的时候，会把执行环境中var声明的变量还有声明的函数首先存在所在环境的变量对象中。需要注意的是，只有这种函数声明形式，才能被提升。f();var f = function () &#123; console.log('test');&#125; 这个就会直接抛异常了。因为f的声明提升了，赋值并没有提升。所以f最开始时是undefined，并不是一个函数，所以直接抛异常。 3. js垃圾回收机制 标记清除 当变量进入执行环境时，标记这个变量正在被这个执行环境使用，离开执行环境时，标记变量离开了这个执行环境。离开当前执行环境的变量，就可以被回收了。 引用计数 引用计数的含义是跟踪记录每 个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时,则这个值的引用次数就是 1。 如果同一个值又被赋给另一个变量,则该值的引用次数加 1。相反,如果包含对这个值引用的变量又取 得了另外一个值,则这个值的引用次数减 1。当这个值的引用次数变成 0 时,则说明没有办法再访问这 个值了,因而就可以将其占用的内存空间回收回来。 引用计数的垃圾回收机制在循环引用时会无法正常工作，因为互相引用导致变量的引用计数一直不会变为0.也就无法回收，最终导致内存溢出。IE9以下就因为其BOM和DOM对象使用的COM采用了引用计数而存在内存泄漏的问题。IE9之后已修复这个问题。 var element = document.getElementById(\"some_element\");var myObject = new Object();myObject.element = element;element.someObject = myObject; 这个例子在一个 DOM 元素(element)与一个原生 JavaScript 对象(myObject)之间创建了循环引用。IE9之后，已经没有此问题。其他的一些现代浏览器都是采用的标记清除的垃圾回收机制，都不会存在内存泄漏的问题。","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yvshuo.github.io/tags/javascript/"}]},{"title":"easytiny 简易说明","date":"2017-03-31T16:04:06.000Z","path":"2017/04/01/2017-04-01-easytiny-1/","text":"写了个批量压缩图片的命令行小工具 easytiny。使用这个工具就不用再每次都往 tinypng 网站上托图片压缩了。 首先需要去tinypng的网站上申请一个API KEY。 $ npm install -g easytiny$ easytiny config set key XXXXXXXXXXXX 这个 XXXXXXX就是你申请的API KEY。每个月有500次的压缩图片的次数限制，但是可以用多个邮箱申请多个KEY，所以还是能轻松满足个人日常需求的。就可以使用了。$ easytiny start 默认模式下是会把压缩后的文件放到当前目录的一个新的文件夹里。$ easytiny start -o -o 直接覆盖原始图片。$ easytiny start -r -r 按照提示在压缩过程中对图片的大小进行调整。$ easytiny start -f -f 强制压缩模式，不逼逼，直接开始压缩。详细说明文档直接戳 easytiny README。 请无视我蹩脚的英语- -","tags":[{"name":"easytiny","slug":"easytiny","permalink":"http://yvshuo.github.io/tags/easytiny/"}]},{"title":"(多图慎入!)类vue官网的hexo主题yvue发布Beta0.1版本","date":"2017-03-26T14:47:32.000Z","path":"2017/03/26/2017-03-26-hexo-theme-yvue-1/","text":"因为很喜欢vue网站简洁的风格，大概两个月之前就已经零零散散的完成了这个由vue site修改的主题。因为最开始的想法是自用，所以样式仍然沿用了vue官网的样式，目前只是按照hexo的文档进行了一些主题化的重构。这个周末又对自己的博客做了一些结构的调整和改动，所以想着干脆把这个自用的主题真正的做成一个HEXO的主题。为了督促自己一把，所以在开发阶段就发布了Beta版本，算是逼着自己不要把这个事情烂尾了吧。目前只有最简单的博客展示功能。 1、首页PC mobile 2、sidebarPC mobile 3、文章列表PC mobile 4、标签列表PC mobile 5、安装方式目前这个主题仍然处于开发状态！所以直接拿去用应该还会有很多坑~如果你想试一试的话。$ git clone https://github.com/yvshuo/hexo-theme-yvue.git themes/yvue 然后参考yvue说明文档吧~","tags":[{"name":"hexo","slug":"hexo","permalink":"http://yvshuo.github.io/tags/hexo/"}]},{"title":"Promises","date":"2017-03-25T08:49:49.000Z","path":"2017/03/25/2017-03-25-es6-4/","text":"一句话。Promises are a library for asynchronous programming.然后再看一个例子：Promise Example 从这个简单的例子中，可以直观的感受到Promise的威力。让异步请求一步一步的进行~ 类似于jQuery里的Deferred对象，Promises提供了异步编程的解决方案，一个简单的例子：function timeout(duration = 0) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(resolve, duration); &#125;)&#125;var p = timeout(1000).then(() =&gt; &#123; return timeout(2000);&#125;).then(() =&gt; &#123; throw new Error(\"hmm\");&#125;).catch(err =&gt; &#123; return Promise.all([timeout(100), timeout(200)]);&#125;) 这种调用方式比起传统的回调函数的方式看起来舒服不止一百倍。 1、Promise对象的三种状态 Pending 进行中 Resolve/fullfill 已完成 reject 已失败类比于回调函数中的写法,resolve类似于success的回调，reject类似于fail的回调，Promise对象状态的变化就两种，一种从Pending进入Resolve,一种从Pending进入Reject。Promise.prototype.then()提供了两个回调的参数，then(resolve, reject)，但是更好的一种写法是在Promise.prototype.catch()中来写失败的回调，这样可以让程序读起来更舒服。var someAsyncThing = function() &#123; return new Promise(function(resolve, reject) &#123; // 下面一行会报错，因为x没有声明 resolve(x + 2); &#125;);&#125;;someAsyncThing().catch(function(error) &#123; console.log('oh no', error);&#125;).then(function() &#123; console.log('carry on');&#125;);// oh no [ReferenceError: x is not defined]// carry on Promise.prototype.catch()返回的仍然是一个Promise对象，后面可以接着调用then方法。 2、Promise对象的几个方法Promise.resolvePromise.resolve('foo')// 等价于new Promise(resolve =&gt; resolve('foo')) 返回一个resolved的Promise对象。 Promise.rejectvar p = Promise.reject('出错了');// 等同于var p = new Promise((resolve, reject) =&gt; reject('出错了'))p.then(null, function (s) &#123; console.log(s)&#125;);// 出错了 返回一个rejected的Promise对象。 Promise.all()类似于Array.every()方法，所有参数都返回resolved的Promise对象后，Promise.all()才会进入rejected状态，否则进入rejected状态。需要注意的几点: 参数不是Promise对象时，会首先调用Promise.resolve()方法转换成Promise对象 全部参数都返回resolved的Promise对象后，这些返回的对象会组成一个数组作为Promise.all()的返回值 有一个参数返回rejected对象后，第一个返回的rejected的Promise对象会作为Promise.al()的返回值 Promise.race()和Promise.all()相对，这个方法类似于Array.some()方法，有一个参数的状态改变后，Promise.race()对象的状态就会改变。race这个方法名也很有意思，所有参数比赛，然后最先改变状态的那个参数返回的Promise对象就会作为Promise.race()的返回值。这个方法比较有用的一个使用方法就是设定异步请求的最大延时。const p = Promise.race([ fetch('/resource-that-may-take-a-while'), new Promise(function (resolve, reject) &#123; setTimeout(() =&gt; reject(new Error('request timeout')), 5000) &#125;)]);p.then(response =&gt; console.log(response));p.catch(error =&gt; console.log(error)); 上面的函数就为fetch方法设定了5秒的延时。 参考文章 1、Learn ES20152、Promise对象3、JavaScript Promises: an Introduction","tags":[{"name":"温故而知新","slug":"温故而知新","permalink":"http://yvshuo.github.io/tags/温故而知新/"},{"name":"ES6","slug":"ES6","permalink":"http://yvshuo.github.io/tags/ES6/"}]},{"title":"Modules","date":"2017-03-25T07:57:37.000Z","path":"2017/03/25/2017-03-25-es6-3/","text":"1、ES6模块化 vs. CommonJSES6在语言层面上提供了模块化的支持，相较与CommonJS和AMD的模块化解决方案，ES6的模块化提供的是编译时的模块化支持，而CommonJS和AMD都是运行时的模块化。ES6的模块方案提供的是对模块的引用，而CommonJS提供的则是一个拷贝。 CommonJS方式// lib.jsvar counter = 3;function incCounter() &#123; counter++;&#125;module.exports = &#123; counter: counter, incCounter: incCounter,&#125;;// main.jsvar mod = require('./lib');console.log(mod.counter); // 3mod.incCounter();console.log(mod.counter); // 3 lib.js模块加载以后，它的内部变化就影响不到输出的mod.counter了。这是因为mod.counter是一个原始类型的值，会被缓存。除非写成一个函数，才能得到内部变动后的值。// lib.jsvar counter = 3;function incCounter() &#123; counter++;&#125;module.exports = &#123; get counter() &#123; return counter &#125;, incCounter: incCounter,&#125;; 这种情况下就可以得到内部变动后的值。 ES6模块// lib.jsexport let counter = 3;export function incCounter() &#123; counter++;&#125;// main.jsimport &#123; counter, incCounter &#125; from './lib';console.log(counter); // 3incCounter();console.log(counter); // 4 ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。 2、常见的ES6模块引用方式// lib/math.jsexport function sum(x, y) &#123; return x + y;&#125;export var pi = 3.141593; 下面是通过import * as ... from ...来引用// app.jsimport * as math from \"lib/math\";console.log(\"2π = \" + math.sum(math.pi, math.pi)); 另一种就是类似于解构赋值的引用方式// otherApp.jsimport &#123;sum, pi&#125; from \"lib/math\";console.log(\"2π = \" + sum(pi, pi)); 3、export default 和 export *// lib/mathplusplus.jsexport * from \"lib/math\";export var e = 2.71828182846;export default function(x) &#123; return Math.exp(x);&#125; 两种引用方式有点区别// app.jsimport exp, &#123;pi, e&#125; from \"lib/mathplusplus\";console.log(\"e^π = \" + exp(pi)); 参考文章 1、Learn ES20152、Module 的加载实现","tags":[{"name":"温故而知新","slug":"温故而知新","permalink":"http://yvshuo.github.io/tags/温故而知新/"},{"name":"ES6","slug":"ES6","permalink":"http://yvshuo.github.io/tags/ES6/"}]},{"title":"Default + Rest + Spread","date":"2017-03-19T04:57:56.000Z","path":"2017/03/19/2017-03-19-es6-2/","text":"function f(x, y=12) &#123; // y is 12 if not passed (or passed as undefined) return x + y;&#125;f(3) == 15 给参数设置默认值。function f(x, ...y) &#123; // y is an Array return x * y.length;&#125;f(3, \"hello\", true) == 6 ES6的Rest参数，类似于java里的接收不定个数的参数。Rest参数可以替代以前的arguments的用法，需要注意的一点就是Rest参数只能在函数参数列表的最后一个。// error!function f(...x, y) &#123;&#125; 上面这个例子中的Rest参数就会报错。function f(x, y, z) &#123; return x + y + z;&#125;// Pass each elem of array as argumentf(...[1,2,3]) == 6 展开数组，极其好用的一个功能。function f() &#123; const arr1 = ['a', 'b']; const arr2 = ['c']; const arr3 = ['d', 'e', ['a', 'b']]; return [...arr1, ...arr2, ...arr3];&#125;// return [ \"a\", \"b\", \"c\", \"d\", \"e\", [ \"a\", \"b\" ] ] 展开数组只能展开一级。 参考文章：Learn ES2015","tags":[{"name":"温故而知新","slug":"温故而知新","permalink":"http://yvshuo.github.io/tags/温故而知新/"},{"name":"ES6","slug":"ES6","permalink":"http://yvshuo.github.io/tags/ES6/"}]},{"title":"Arrows and Lexical This","date":"2017-03-19T03:34:22.000Z","path":"2017/03/19/2017-03-19-es6-1/","text":"Arrows are a function shorthand using the =&gt; syntax.Unlike functions, arrows share the same lexical this as their surrounding code.If an arrow is inside another function, it shares the arguments variable of its parent function. // Expression bodiesvar odds = evens.map(v =&gt; v + 1);var nums = evens.map((v, i) =&gt; v + i);// Statement bodiesnums.forEach(v =&gt; &#123; if (v % 5 === 0) fives.push(v);&#125;); 上面的代码一种是箭头函数的表达式形式，一种是语句的形式。表达式形式return表达式的值。语句形式可以执行语句，不带返回值，也可以带返回值，这点和function是一样的。 // Lexical thisvar bob = &#123; _name: \"Bob\", _friends: [], printFriends() &#123; this._friends.forEach(f =&gt; // a console.log(this._name + \" knows \" + f)); // b &#125;&#125;; 箭头函数的this和它周围的代码的this指向同一个地方，上面代码中注释a这一行的this和注释b这一行的this就都指向bob变量。在实际使用中，我们需要根据自己不同的需要使用function或者是箭头函数。 // Lexical argumentsfunction square() &#123; let example = () =&gt; &#123; let numbers = []; for (let number of arguments) &#123; numbers.push(number * number); &#125; return numbers; &#125;; return example();&#125;square(2, 4, 7.5, 8, 11.5, 21); // returns: [4, 16, 56.25, 64, 132.25, 441] 箭头函数和它的父函数共享一个arguments变量。 参考文章：Learn ES2015","tags":[{"name":"温故而知新","slug":"温故而知新","permalink":"http://yvshuo.github.io/tags/温故而知新/"},{"name":"ES6","slug":"ES6","permalink":"http://yvshuo.github.io/tags/ES6/"}]},{"title":"阿里巴巴java开发手册解读9-其他编程规约","date":"2017-02-23T14:23:22.000Z","path":"2017/02/23/2017-02-23-javarule-9/","text":"1. 【强制】在使用正则表达式时,利用好其预编译功能,可以有效加快正则匹配速度。说明:不要在方法体内定义:Pattern pattern = Pattern.compile(规则); 2. 【强制】velocity 调用 POJO 类的属性时,建议直接使用属性名取值即可,模板引擎会自动按规范调用 POJO 的 getXxx(),如果是 boolean 基本数据类型变量(boolean 命名不需要加 is 前缀),会自动调用 isXxx()方法。说明:注意如果是 Boolean 包装类对象,优先调用 getXxx()的方法。 3. 【强制】后台输送给页面的变量必须加$!{var}——中间的感叹号。说明:如果 var=null 或者不存在,那么${var}会直接显示在页面上。 4. 【强制】注意 Math.random() 这个方法返回是 double 类型,注意取值的范围 0≤x&lt;1(能够取到零值,注意除零异常),如果想获取整数类型的随机数,不要将 x 放大 10 的若干倍然后取整,直接使用 Random 对象的 nextInt 或者 nextLong 方法。5. 【强制】获取当前毫秒数 System.currentTimeMillis(); 而不是 new Date().getTime();说明:如果想获取更加精确的纳秒级时间值,用 System.nanoTime()。在 JDK8 中,针对统计 时间等场景,推荐使用 Instant 类。 6. 【推荐】尽量不要在 vm 中加入变量声明、逻辑运算符,更不要在 vm 模板中加入任何复杂的逻辑。7. 【推荐】任何数据结构的构造或初始化,都应指定大小,避免数据结构无限增长吃光内存。8. 【推荐】对于“明确停止使用的代码和配置”,如方法、变量、类、配置文件、动态配置属性等要坚决从程序中清理出去,避免造成过多垃圾。 后记：仔细的读了这个java手册好几遍，对于规范java编程确实有很好的指导意义。作为一名只是略懂java的前端狗，还有很多地方不懂。除了编程规约外的其他几个规约待后续学习后再填坑。这个系列解读也会随着自己java学习的不断深入持续更新。干巴得","tags":[{"name":"java","slug":"java","permalink":"http://yvshuo.github.io/tags/java/"},{"name":"java文档","slug":"java文档","permalink":"http://yvshuo.github.io/tags/java文档/"}]},{"title":"阿里巴巴java开发手册解读8-注释规约","date":"2017-02-23T13:13:50.000Z","path":"2017/02/23/2017-02-23-javarule-8/","text":"1. 【强制】类、类属性、类方法的注释必须使用 Javadoc 规范,使用/*内容/格式,不得使用 //xxx 方式。说明:在 IDE 编辑窗口中,Javadoc 方式会提示相关注释,生成 Javadoc 可以正确输出相应注释;在 IDE 中,工程调用方法时,不进入方法即可悬浮提示方法、参数、返回值的意义,提高阅读效率。 2. 【强制】所有的抽象方法(包括接口中的方法)必须要用 Javadoc 注释、除了返回值、参数、异常说明外,还必须指出该方法做什么事情,实现什么功能。说明:对子类的实现要求,或者调用注意事项,请一并说明。 3. 【强制】所有的类都必须添加创建者信息。4. 【强制】方法内部单行注释,在被注释语句上方另起一行,使用//注释。方法内部多行注释使用/ /注释,注意与代码对齐。5. 【强制】所有的枚举类型字段必须要有注释,说明每个数据项的用途。6. 【推荐】与其“半吊子”英文来注释,不如用中文注释把问题说清楚。专有名词与关键字保持英文原文即可。反例:“TCP 连接超时”解释成“传输控制协议连接超时”,理解反而费脑筋。 7. 【推荐】代码修改的同时,注释也要进行相应的修改,尤其是参数、返回值、异常、核心逻辑 等的修改。说明:代码与注释更新不同步,就像路网与导航软件更新不同步一样,如果导航软件严重滞后, 就失去了导航的意义。 8. 【参考】注释掉的代码尽量要配合说明,而不是简单的注释掉。说明:代码被注释掉有两种可能性:1)后续会恢复此段代码逻辑。2)永久不用。前者如果没有备注信息,难以知晓注释动机。后者建议直接删掉(代码仓库保存了历史代码)。 9. 【参考】对于注释的要求:1)能够准确反应设计思想和代码逻辑;2)能够描述业务含义,使别的程序员能够迅速了解到代码背后的信息。完全没有注释的大段代码对于阅读者形同天书,注释是给自己看的,即使隔很长时间,也能清晰理解当时的思路;注释也是给继任者看的,使其能够快速接替自己的工作。 10. 【参考】好的命名、代码结构是自解释的,注释力求精简准确、表达到位。避免出现注释的一个极端:过多过滥的注释,代码的逻辑一旦修改,修改注释是相当大的负担。反例:// put elephant into fridgeput(elephant, fridge); 方法名 put,加上两个有意义的变量名 elephant 和 fridge,已经说明了这是在干什么,语义清晰的代码不需要额外的注释。 11. 【参考】特殊注释标记,请注明标记人与标记时间。注意及时处理这些标记,通过标记扫描, 经常清理此类标记。线上故障有时候就是来源于这些标记处的代码。1) 待办事宜(TODO):( 标记人,标记时间,[预计处理时间]) 表示需要实现,但目前还未实现的功能。这实际上是一个 Javadoc 的标签,目前的 Javadoc 还没有实现,但已经被广泛使用。只能应用于类,接口和方法(因为它是一个 Javadoc 标签)。2) 错误,不能工作(FIXME):(标记人,标记时间,[预计处理时间])在注释中用 FIXME 标记某代码是错误的,而且不能工作,需要及时纠正的情况。","tags":[{"name":"java","slug":"java","permalink":"http://yvshuo.github.io/tags/java/"},{"name":"java文档","slug":"java文档","permalink":"http://yvshuo.github.io/tags/java文档/"}]},{"title":"阿里巴巴java开发手册解读7-控制语句","date":"2017-02-22T11:53:20.000Z","path":"2017/02/22/2017-02-22-javarule-7/","text":"1. 【强制】在一个 switch 块内,每个 case 要么通过 break/return 等来终止,要么注释说明程序将继续执行到哪一个 case 为止;在一个 switch 块内,都必须包含一个 default 语句并且放在最后,即使它什么代码也没有。 2. 【强制】在 if/else/for/while/do 语句中必须使用大括号,即使只有一行代码,避免使用下面的形式:if (condition) statements; 3. 【推荐】推荐尽量少用 elseif-else 的方式可以改写成:if(condition)&#123; ... return obj; &#125;// 接着写 else 的业务逻辑代码; 说明:如果非得使用if()…else if()…else…方式表达逻辑,【强制】请勿超过3层,超过请使用状态设计模式。正例:逻辑上超过 3 层的 if-else 代码可以使用卫语句,或者状态模式来实现。 4. 【推荐】除常用方法(如 getXxx/isXxx)等外,不要在条件判断中执行其它复杂的语句,将复杂逻辑判断的结果赋值给一个有意义的布尔变量名,以提高可读性。说明:很多 if 语句内的逻辑相当复杂,阅读者需要分析条件表达式的最终结果,才能明确什么样的条件执行什么样的语句,那么,如果阅读者分析逻辑表达式错误呢?正例://伪代码如下boolean existed = (file.open(fileName, \"w\") != null) &amp;&amp; (...) || (...); if (existed) &#123; ... &#125; 反例:if ((file.open(fileName, \"w\") != null) &amp;&amp; (...) || (...)) &#123; ...&#125; 5. 【推荐】循环体中的语句要考量性能以下操作尽量移至循环体外处理,如定义对象、变量、获取数据库连接,进行不必要的 try-catch 操作(这个 try-catch 是否可以移至循环体外)。 6. 【推荐】接口入参保护,这种场景常见的是用于做批量操作的接口。7. 【参考】方法中需要进行参数校验的场景:1) 调用频次低的方法。2) 执行时间开销很大的方法,参数校验时间几乎可以忽略不计,但如果因为参数错误导致中间执行回退,或者错误,那得不偿失。3) 需要极高稳定性和可用性的方法。4) 对外提供的开放接口,不管是RPC/API/HTTP接口。5) 敏感权限入口。 8. 【参考】方法中不需要参数校验的场景:1) 极有可能被循环调用的方法,不建议对参数进行校验。但在方法说明里必须注明外部参数检查。2) 底层的方法调用频度都比较高,一般不校验。毕竟是像纯净水过滤的最后一道,参数错误不太可能到底层才会暴露问题。一般 DAO 层与 Service 层都在同一个应用中,部署在同一台服务器中,所以 DAO 的参数校验,可以省略。3) 被声明成private只会被自己代码所调用的方法,如果能够确定调用方法的代码传入参数已经做过检查或者肯定不会有问题,此时可以不校验参数。","tags":[{"name":"java","slug":"java","permalink":"http://yvshuo.github.io/tags/java/"},{"name":"java文档","slug":"java文档","permalink":"http://yvshuo.github.io/tags/java文档/"}]},{"title":"阿里巴巴java开发手册解读6-并发处理","date":"2017-02-18T08:33:10.000Z","path":"2017/02/18/2017-02-18-javarule-6/","text":"1. 【强制】获取单例对象需要保证线程安全,其中的方法也要保证线程安全。说明:资源驱动类、工具类、单例工厂类都需要注意。 2. 【强制】创建线程或线程池时请指定有意义的线程名称,方便出错时回溯。正例:public class TimerTaskThread extends Thread &#123; public TimerTaskThread()&#123; super.setName(\"TimerTaskThread\"); ... &#125; 3. 【强制】线程资源必须通过线程池提供,不允许在应用中自行显式创建线程。说明:使用线程池的好处是减少在创建和销毁线程上所花的时间以及系统资源的开销,解决资源不足的问题。如果不使用线程池,有可能造成系统创建大量同类线程而导致消耗完内存或者 “过度切换”的问题。 4. 【强制】线程池不允许使用 Executors 去创建,而是通过 ThreadPoolExecutor 的方式,这样 的处理方式让写的同学更加明确线程池的运行规则,规避资源耗尽的风险。说明:Executors 返回的线程池对象的弊端如下:1)FixedThreadPool 和 SingleThreadPool:允许的请求队列长度为 Integer.MAX_VALUE,可能会堆积大量的请求,从而导致 OOM。2)CachedThreadPool 和 ScheduledThreadPool:允许的创建线程数量为 Integer.MAX_VALUE,可能会创建大量的线程,从而导致 OOM。 5.【强制】SimpleDateFormat 是线程不安全的类,一般不要定义为static变量,如果定义为static,必须加锁,或者使用 DateUtils 工具类。正例:注意线程安全,使用 DateUtils。亦推荐如下处理:private static final ThreadLocal&lt;DateFormat&gt; df = new ThreadLocal&lt;DateFormat&gt;() &#123; @Override protected DateFormat initialValue() &#123; return new SimpleDateFormat(\"yyyy-MM-dd\"); &#125;&#125;; 说明:如果是 JDK8 的应用,可以使用 Instant 代替 Date,LocalDateTime 代替 Calendar, DateTimeFormatter 代替 Simpledateformatter,官方给出的解释:simple beautiful strong immutable thread-safe。 6. 【强制】高并发时,同步调用应该去考量锁的性能损耗。能用无锁数据结构,就不要用锁;能锁区块,就不要锁整个方法体;能用对象锁,就不要用类锁。 7. 【强制】对多个资源、数据库表、对象同时加锁时,需要保持一致的加锁顺序,否则可能会造成死锁。说明:线程一需要对表 A、B、C 依次全部加锁后才可以进行更新操作,那么线程二的加锁顺序也必须是 A、B、C,否则可能出现死锁。 8. 【强制】并发修改同一记录时,避免更新丢失,要么在应用层加锁,要么在缓存加锁,要么在数据库层使用乐观锁,使用 version 作为更新依据。说明:如果每次访问冲突概率小于 20%,推荐使用乐观锁,否则使用悲观锁。乐观锁的重试次数不得小于 3 次。 9. 【强制】多线程并行处理定时任务时,Timer 运行多个 TimeTask 时,只要其中之一没有捕获抛出的异常,其它任务便会自动终止运行,使用 ScheduledExecutorService 则没有这个问题。10. 【推荐】使用 CountDownLatch 进行异步转同步操作,每个线程退出前必须调用 countDown方法,线程执行代码注意 catch 异常,确保 countDown 方法可以执行,避免主线程无法执行 至 countDown 方法,直到超时才返回结果。 说明:注意,子线程抛出异常堆栈,不能在主线程 try-catch 到。11. 【推荐】避免 Random 实例被多线程使用,虽然共享该实例是线程安全的,但会因竞争同一 seed 导致的性能下降。说明:Random 实例包括 java.util.Random 的实例或者 Math.random()实例。正例:在 JDK7 之后,可以直接使用 API ThreadLocalRandom,在 JDK7 之前,可以做到每个 线程一个实例。 12.【推荐】通过双重检查锁(double-checked locking)(在并发场景)实现延迟初始化的优化问题隐患(可参考 The “Double-Checked Locking is Broken” Declaration),推荐问题解决方案中较为简单一种(适用于 JDK5 及以上版本),将目标属性声明为 volatile 型。反例:class Foo &#123; private Helper helper = null; public Helper getHelper() &#123; if (helper == null) synchronized (this) &#123; if (helper == null) helper = new Helper(); &#125; return helper; &#125; // other functions and members...&#125; 13. 【参考】volatile 解决多线程内存不可见问题。对于一写多读,是可以解决变量同步问题, 但是如果多写,同样无法解决线程安全问题。如果是 count++操作,使用如下类实现:AtomicInteger count = new AtomicInteger(); count.addAndGet(1); 如果是 JDK8,推 荐使用 LongAdder 对象,比 AtomicLong 性能更好(减少乐观锁的重试次数)。 14. 【参考】HashMap 在容量不够进行 resize 时由于高并发可能出现死链,导致 CPU 飙升,在开发过程中注意规避此风险。15. 【参考】ThreadLocal 无法解决共享对象的更新问题,ThreadLocal 对象建议使用 static 修饰。这个变量是针对一个线程内所有操作共有的,所以设置为静态变量,所有此类实例共享此静态变量 ,也就是说在类第一次被使用时装载,只分配一块存储空间,所有此类的对象(只要是这个线程内定义的)都可以操控这个变量。","tags":[{"name":"java","slug":"java","permalink":"http://yvshuo.github.io/tags/java/"},{"name":"java文档","slug":"java文档","permalink":"http://yvshuo.github.io/tags/java文档/"}]},{"title":"阿里巴巴java开发手册解读5-集合处理","date":"2017-02-17T11:43:16.000Z","path":"2017/02/17/2017-02-17-javarule-5/","text":"1. 【强制】关于 hashCode 和 equals 的处理,遵循如下规则:1) 只要重写equals,就必须重写hashCode。2) 因为Set存储的是不重复的对象,依据hashCode和equals进行判断,所以Set存储的对象必须重写这两个方法。3) 如果自定义对象做为Map的键,那么必须重写hashCode和equals。正例:String 重写了 hashCode 和 equals 方法,所以我们可以非常愉快地使用 String 对象 作为 key 来使用。 2. 【强制】ArrayList的subList结果不可强转成ArrayList否则会抛出ClassCastException 异常:java.util.RandomAccessSubList cannot be cast to java.util.ArrayList ;说明:subList 返回的是 ArrayList 的内部类 SubList,并不是 ArrayList ,而是 ArrayList 的一个视图,对于SubList子列表的所有操作最终会反映到原列表上。 3. 【强制】在 subList 场景中,高度注意对原集合元素个数的修改该修改会导致子列表的遍历、增 加、删除均产生ConcurrentModificationException 异常。 4. 【强制】使用集合转数组的方法,必须使用集合的toArray(T[] array),传入的是类型完全一样的数组,大小就是 list.size()。反例:直接使用 toArray 无参方法存在问题,此方法返回值只能是 Object[]类,若强转其它 类型数组将出现 ClassCastException 错误。正例:List&lt;String&gt; list = new ArrayList&lt;String&gt;(2);list.add(\"guan\");list.add(\"bao\");String[] array = new String[list.size()];array = list.toArray(array); 说明:使用 toArray 带参方法,入参分配的数组空间不够大时,toArray 方法内部将重新分配内存空间,并返回新数组地址;如果数组元素大于实际所需,下标为[ list.size() ]的数组元素将被置为 null,其它数组元素保持原值,因此最好将方法入参数组大小定义与集合元素个数一致。 5. 【强制】使用工具类 Arrays.asList()把数组转换成集合时,不能使用其修改集合相关的方法,它的 add/remove/clear 方法会抛出 UnsupportedOperationException 异常。说明:asList 的返回对象是一个 Arrays 内部类,并没有实现集合的修改方法。Arrays.asList 体现的是适配器模式,只是转换接口,后台的数据仍是数组。String[] str = new String[] &#123; \"a\", \"b\" &#125;;List list = Arrays.asList(str); 第一种情况:list.add(\"c\"); //运行时异常。 第二种情况:str[0]= \"gujin\"; //list.get(0)也会随之修改。 6. 【强制】泛型通配符&lt;? extends T&gt;来接收返回的数据,此写法的泛型集合不能使用add方法。说明:苹果装箱后返回一个&lt;? extends Fruits&gt;对象,此对象就不能往里加任何水果,包括苹果。 7. 【强制】不要在 foreach 循环里进行元素的 remove/add 操作。remove 元素请使用 Iterator方式,如果并发操作,需要对 Iterator 对象加锁。反例:List&lt;String&gt; a = new ArrayList&lt;String&gt;();a.add(\"1\");a.add(\"2\");for (String temp : a) &#123; if (\"1\".equals(temp)) &#123; a.remove(temp); &#125;&#125; 说明:以上代码的执行结果肯定会出乎大家的意料,那么试一下把“1”换成“2”,会是同样的结果吗?正例:Iterator&lt;String&gt; it = a.iterator();while (it.hasNext()) &#123; String temp = it.next(); if (删除元素的条件) &#123; it.remove(); &#125;&#125; 8. 【强制】在 JDK7 版本以上,Comparator 要满足自反性,传递性,对称性,不然 Arrays.sort, Collections.sort 会报 IllegalArgumentException 异常。说明:1) 自反性:x,y的比较结果和y,x的比较结果相反。2) 传递性:x&gt;y,y&gt;z,则x&gt;z。3) 对称性:x=y,则x,z比较结果和y,z比较结果相同。反例:下例中没有处理相等的情况,实际使用中可能会出现异常:new Comparator&lt;Student&gt;() &#123; @Override public int compare(Student o1, Student o2) &#123; return o1.getId() &gt; o2.getId() ? 1 : -1; &#125;&#125; 9. 【推荐】集合初始化时,尽量指定集合初始值大小。说明:ArrayList尽量使用ArrayList(int initialCapacity) 初始化。 10. 【推荐】使用 entrySet 遍历 Map 类集合 KV,而不是 keySet 方式进行遍历。说明:keySet 其实是遍历了 2 次,一次是转为 Iterator 对象,另一次是从 hashMap 中取出 key 所对应的 value。而 entrySet 只是遍历了一次就把 key 和 value 都放到了 entry 中,效 率更高。如果是 JDK8,使用 Map.foreach 方法。正例:values()返回的是 V 值集合,是一个 list 集合对象;keySet()返回的是 K 值集合,是 一个 Set 集合对象;entrySet()返回的是 K-V 值组合集合。 11. 【推荐】高度注意 Map 类集合 K/V 能不能存储 null 值的情况,如下表格: 集合类 Key Value Super 说明 Hashtable 不允许为 null 不允许为 null Dictionary 线程安全 ConcurrentHashMap 不允许为 null 不允许为 null AbstractMap 分段锁技术 TreeMap 不允许为 null 允许为 null AbstractMap 线程不安全 HashMap 允许为 null 允许为 null AbstractMap 线程不安全 反例: 由于 HashMap 的干扰,很多人认为 ConcurrentHashMap 是可以置入 null 值,注意存储 null 值时会抛出 NPE 异常。 12. 【参考】合理利用好集合的有序性(sort)和稳定性(order),避免集合的无序性(unsort)和 不稳定性(unorder)带来的负面影响。说明:稳定性指集合每次遍历的元素次序是一定的。有序性是指遍历的结果是按某种比较规则 依次排列的。如:ArrayList 是 order/unsort;HashMap 是 unorder/unsort;TreeSet 是 order/sort。 13. 【参考】利用 Set 元素唯一的特性,可以快速对一个集合进行去重操作,避免使用 List 的 contains 方法进行遍历、对比、去重操作。","tags":[{"name":"java","slug":"java","permalink":"http://yvshuo.github.io/tags/java/"},{"name":"java文档","slug":"java文档","permalink":"http://yvshuo.github.io/tags/java文档/"}]},{"title":"阿里巴巴java开发手册解读4-OOP 规约","date":"2017-02-13T10:43:16.000Z","path":"2017/02/13/2017-02-10-javarule-4/","text":"1. 【强制】避免通过一个类的对象引用访问此类的静态变量或静态方法,无谓增加编译器解析成本,直接用类名来访问即可 批注:正例:Integer.parseInt(\"1\"); 反例:Integer i = new Integer(0);i.parseInt(\"1\"); 2. 【强制】所有的覆写方法,必须加@Override注解反例:getObject()与 get0bject()的问题。一个是字母的 O,一个是数字的 0,加@Override 可以准确判断是否覆盖成功。另外,如果在抽象类中对方法签名进行修改,其实现类会马上编译报错。 批注:@Override会去检查是否和覆写类的名字相同 3. 【强制】相同参数类型,相同业务含义,才可以使用 Java 的可变参数,避免使用 Object说明:可变参数必须放置在参数列表的最后。(提倡同学们尽量不用可变参数编程)正例:public User getUsers(String type, Integer… ids) 4. 【强制】对外暴露的接口签名,原则上不允许修改方法签名,避免对接口调用方产生影响接口过时必须加@Deprecated 注解,并清晰地说明采用的新接口或者新服务是什么。 批注:接口重构中的一项基本原则 5. 【强制】不能使用过时的类或方法说明:java.net.URLDecoder 中的方法 decode(String encodeStr) 这个方法已经过时,应该使用双参数 decode(String source, String encode)。接口提供方既然明确是过时接口, 那么有义务同时提供新的接口;作为调用方来说,有义务去考证过时方法的新实现是什么。 6. 【强制】Object 的 equals 方法容易抛空指针异常,应使用常量或确定有值的对象来调用equals。正例: “test”.equals(object);反例: object.equals(“test”);说明:推荐使用java.util.Objects#equals (JDK7引入的工具类) 批注:想起自己每次都是判断一下object是否实例化然后再使用反例- -捂脸 7. 【强制】所有的相同类型的包装类对象之间值的比较,全部使用 equals 方法比较说明:对于Integer var=?在-128至127之间的赋值,Integer对象是在 IntegerCache.cache 产生,会复用已有对象,这个区间内的 Integer 值可以直接使用==进行 判断,但是这个区间之外的所有数据,都会在堆上产生,并不会复用已有对象,这是一个大坑, 推荐使用 equals 方法进行判断。 8. 【强制】关于基本数据类型与包装数据类型的使用标准如下:1) 所有的POJO类属性必须使用包装数据类型。2) RPC方法的返回值和参数必须使用包装数据类型。3) 所有的局部变量【推荐】使用基本数据类型。说明:POJO 类属性没有初值是提醒使用者在需要使用时,必须自己显式地进行赋值,任何NPE问题,或者入库检查,都由使用者来保证。正例:数据库的查询结果可能是 null,因为自动拆箱,用基本数据类型接收有 NPE 风险。反例:比如显示成交总额涨跌情况,即正负 x%,x 为基本数据类型,调用的 RPC 服务,调用不成功时,返回的是默认值,页面显示:0%,这是不合理的,应该显示成中划线-。所以包装 数据类型的 null 值,能够表示额外的信息,如:远程调用失败,异常退出。 批注:NPE是指空指针异常。在单位的java项目中经常遇到复杂的POJO类。这条准则就是将处理NPE的职责进行明确划分，将POJO类的检查交给使用者。 9. 【强制】定义 DO/DTO/VO 等 POJO 类时,不要设定任何属性默认值反例:POJO类的gmtCreate默认值为new Date();但是这个属性在数据提取时并没有置入具体值,在更新其它字段时又附带更新了此字段,导致创建时间被修改成当前时间。 批注:不给POJO类设置属性默认值，避免出现奇奇怪怪的问题 10. 【强制】序列化类新增属性时,请不要修改 serialVersionUID 字段,避免反序列失败如果完全不兼容升级,避免反序列化混乱,那么请修改 serialVersionUID 值。说明:注意 serialVersionUID 不一致会抛出序列化运行时异常。 11. 【强制】构造方法里面禁止加入任何业务逻辑,如果有初始化逻辑,请放在 init 方法中12. 【强制】POJO 类必须写 toString 方法。使用 IDE 的中工具:source&gt; generate toString 时,如果继承了另一个 POJO 类,注意在前面加一下 super.toString。说明:在方法执行抛出异常时,可以直接调用 POJO 的 toString()方法打印其属性值,便于排查问题。 批注:这项应该是阿里巴巴的经验，这种方法更便于日志调错。重写toString方法后就不需要再断点看值了。 13. 【推荐】使用索引访问用 String 的 split 方法得到的数组时,需做最后一个分隔符后有无内容的检查,否则会有抛 IndexOutOfBoundsException 的风险。说明:String str = \"a,b,c,,\";String[] ary = str.split(\",\"); //预期大于 3,结果是 3 System.out.println(ary.length); 批注:String str = \"a,b,,c,,\";String[] ary = str.split(\",\"); //返回结果为4，只有最后一个分隔符需要做检查 在使用索引的时候，一般还是要判断一下length再访问 14. 【推荐】当一个类有多个构造方法,或者多个同名方法,这些方法应该按顺序放置在一起, 便于阅读15.【推荐】 类内方法定义顺序依次是:公有方法或保护方法 &gt; 私有方法 &gt; getter/setter方法说明:公有方法是类的调用者和维护者最关心的方法,首屏展示最好;保护方法虽然只是子类 关心,也可能是“模板设计模式”下的核心方法;而私有方法外部一般不需要特别关心,是一个 黑盒实现;因为方法信息价值较低,所有 Service 和 DAO 的 getter/setter 方法放在类体最 后。 16. 【推荐】setter 方法中,参数名称与类成员变量名称一致,this.成员名=参数名。在getter/setter 方法中,尽量不要增加业务逻辑,增加排查问题的难度。反例:public Integer getData()&#123; if(true) &#123; return data + 100; &#125;else &#123; return data - 100; &#125;&#125; 批注:有些框架会默认去用get+set属性名去操作属性值，所以直接用eclipse的source-&gt;generate getter/setter吧 17. 【推荐】循环体内,字符串的联接方式,使用 StringBuilder 的 append 方法进行扩展。反例:String str = \"start\"; for(int i=0; i&lt;100; i++)&#123; str = str + \"hello\"; &#125; 说明:反编译出的字节码文件显示每次循环都会 new 出一个 StringBuilder 对象,然后进行 append 操作,最后通过 toString 方法返回 String 对象,造成内存资源浪费。 批注:使用下面的测试代码就可以只管看出两者的区别：StringBuffer sb = new StringBuffer();String str = new String();long startTime1=System.currentTimeMillis();for (int i = 0; i &lt; 10000; i++) &#123; sb.append(\"hello\");&#125;sb.toString();long endTime1=System.currentTimeMillis();long startTime2=System.currentTimeMillis();for (int i = 0; i &lt; 10000; i++) &#123; str = str + \"hello\";&#125;long endTime2=System.currentTimeMillis();System.out.println(\"StringBuffer耗时:\"+(endTime1-startTime1)+\"ms\");System.out.println(\"加号连接耗时:\"+(endTime2-startTime2)+\"ms\"); 测试结果:StringBuffer耗时:4ms加号连接耗时:205ms 18. 【推荐】final 可提高程序响应效率,声明成 final 的情况:1) 不需要重新赋值的变量,包括类属性、局部变量。2) 对象参数前加final,表示不允许修改引用的指向。3) 类方法确定不允许被重写。 19. 【推荐】慎用 Object 的 clone 方法来拷贝对象说明:对象的 clone 方法默认是浅拷贝,若想实现深拷贝需要重写 clone 方法实现属性对象的拷贝。 批注:浅拷贝是指拷贝对象时仅仅拷贝对象本身（包括对象中的基本变量），而不拷贝对象包含的引用指向的对象。深拷贝不仅拷贝对象本身，而且拷贝对象包含的引用指向的所有对象。举例来说更加清楚：对象A1中包含对B1的引用，B1中包含对C1的引用。浅拷贝A1得到A2，A2 中依然包含对B1的引用，B1中依然包含对C1的引用。深拷贝则是对浅拷贝的递归，深拷贝A1得到A2，A2中包含对B2（B1的copy）的引用，B2 中包含对C2（C1的copy）的引用。 20. 【推荐】类成员与方法访问控制从严:1) 如果不允许外部直接通过new来创建对象,那么构造方法必须是private。2) 工具类不允许有public或default构造方法。3) 类非static成员变量并且与子类共享,必须是protected。4) 类非static成员变量并且仅在本类使用,必须是private。5) 类static成员变量如果仅在本类使用,必须是private。6) 若是static成员变量,必须考虑是否为final。7) 类成员方法只供类内部调用,必须是private。8) 类成员方法只对继承类公开,那么限制为protected。说明:任何类、方法、参数、变量,严控访问范围。过宽泛的访问范围,不利于模块解耦。思考:如果是一个 private 的方法,想删除就删除,可是一个 public 的 Service 方法,或者一 个 public 的成员变量,删除一下,不得手心冒点汗吗?变量像自己的小孩,尽量在自己的视 线内,变量作用域太大,如果无限制的到处跑,那么你会担心的。","tags":[{"name":"java","slug":"java","permalink":"http://yvshuo.github.io/tags/java/"},{"name":"java文档","slug":"java文档","permalink":"http://yvshuo.github.io/tags/java文档/"}]},{"title":"阿里巴巴java开发手册解读3-格式规约","date":"2017-02-10T01:35:25.000Z","path":"2017/02/10/2017-02-10-javarule-3/","text":"1. 【强制】大括号的使用约定如果是大括号内为空,则简洁地写成{}即可,不需要换行;如果 是非空代码块则:1) 左大括号前不换行2) 左大括号后换行 批注:if (a &lt; 0) &#123; // do something 1&#125;if (a &gt; 0) &#123; // do something 2&#125; 3) 右大括号前换行4) 右大括号后还有else等代码则不换行;表示终止右大括号后必须换行 批注:if (a &lt; 0) &#123; // do something 1&#125; else &#123; // do something 2&#125; 2. 【强制】 左括号和后一个字符之间不出现空格;同样,右括号和前一个字符之间也不出现空格详见第 5 条下方正例提示 3. 【强制】if/for/while/switch/do 等保留字与左右括号之间都必须加空格4. 【强制】任何运算符左右必须加一个空格说明:运算符包括赋值运算符=、逻辑运算符&amp;&amp;、加减乘除符号、三目运行符等。 5. 【强制】缩进采用 4 个空格,禁止使用 tab 字符说明:如果使用 tab 缩进,必须设置 1 个 tab 为 4 个空格。IDEA 设置 tab 为 4 个空格时, 请勿勾选Use tab character;而在 eclipse 中,必须勾选insert spaces for tabs。正例: (涉及1-5点)public static void main(String args[]) &#123; // 缩进 4 个空格 String say = \"hello\"; // 运算符的左右必须有一个空格 int flag = 0; // 关键词 if 与括号之间必须有一个空格,括号内的 f 与左括号,0 与右括号不需要空格 if (flag == 0) &#123; System.out.println(say); &#125; // 左大括号前加空格且不换行;左大括号后换行 if (flag == 1) &#123; System.out.println(\"world\"); // 右大括号前换行,右大括号后有 else,不用换行 &#125; else &#123; System.out.println(\"ok\"); // 在右大括号后直接结束,则必须换行 &#125;&#125; 批注:下图为eclipse中缩进的设置 6. 【强制】单行字符数限制不超过 120 个,超出需要换行,换行时遵循如下原则:1) 第二行相对第一行缩进 4 个空格,从第三行开始,不再继续缩进,参考示例2) 运算符与下文一起换行3) 方法调用的点符号与下文一起换行4) 在多个参数超长,逗号后进行换行5) 在括号前不要换行,见反例正例:StringBuffer sb = new StringBuffer();//超过 120 个字符的情况下,换行缩进 4 个空格,并且方法前的点符号一起换行 sb.append(\"zi\").append(\"xin\")... .append(\"huang\")... .append(\"huang\")... .append(\"huang\"); 反例:StringBuffer sb = new StringBuffer();//超过 120 个字符的情况下,不要在括号前换行sb.append(\"zi\").append(\"xin\")...append (\"huang\");//参数很多的方法调用可能超过 120 个字符,不要在逗号前换行method(args1, args2, args3, ... , argsX); 7. 【强制】方法参数在定义和传入时,多个参数逗号后边必须加空格正例:下例中实参的”a”,后边必须要有一个空格。method(“a”, “b”, “c”); 8. 【强制】IDE的text file encoding设置为UTF-8; IDE中文件的换行符使用Unix格式, 不要使用 windows 格式9. 【推荐】没有必要增加若干空格来使某一行的字符与上一行的相应字符对齐正例:int a = 3;long b = 4L;float c = 5F;StringBuffer sb = new StringBuffer(); 说明:增加 sb 这个变量,如果需要对齐,则给 a、b、c 都要增加几个空格,在变量比较多的 情况下,是一种累赘的事情。 10. 【推荐】方法体内的执行语句组、变量的定义语句组、不同的业务逻辑之间或者不同的语义之间插入一个空行。相同业务逻辑和语义之间不需要插入空行。说明:没有必要插入多行空格进行隔开。","tags":[{"name":"java","slug":"java","permalink":"http://yvshuo.github.io/tags/java/"},{"name":"java文档","slug":"java文档","permalink":"http://yvshuo.github.io/tags/java文档/"}]},{"title":"阿里巴巴java开发手册解读2-常量定义","date":"2017-02-10T01:13:20.000Z","path":"2017/02/10/2017-02-10-javarule-2/","text":"1. 【强制】不允许出现任何魔法值(即未经定义的常量)直接出现在代码中反例: String key=”Id#taobao_”+tradeId;cache.put(key, value); 批注:正确的做法应该是维护一个常量表或者在类起始位置定义常量正解：public static final String PREFIX_TRADEID = \"Id#taobao_\";String key=PREFIX_TRADEID+tradeId;cache.put(key, value); 2. 【强制】long 或者 Long 初始赋值时,必须使用大写的 L,不能是小写的 l,小写容易跟数字 1 混淆,造成误解。说明:Long a = 2l; 写的是数字的21,还是Long型的2? 批注:0O0~你能看出我打的是什么嘛→_→ 3. 【推荐】不要使用一个常量类维护所有常量,应该按常量功能进行归类,分开维护如:缓存 相关的常量放在类:CacheConsts 下;系统配置相关的常量放在类:ConfigConsts 下。 说明:大而全的常量类,非得使用查找功能才能定位到修改的常量,不利于理解和维护。 批注:好的系统架构是自注释的，一眼就能看出哪里是干什么。 4. 【推荐】常量的复用层次有五层:跨应用共享常量、应用内共享常量、子工程内共享常量、包内共享常量、类内共享常量1) 跨应用共享常量:放置在二方库中,通常是client.jar中的constant目录下。2) 应用内共享常量:放置在一方库的modules中的constant目录下。反例:易懂变量也要统一定义成应用内共享常量,两位攻城师在两个类中分别定义 了 表示“是”的变量:类A中:public static final String YES = “yes”;类B中:public static final String YES = “y”; A.YES.equals(B.YES),预期是 true,但实际返回为 false,导致产生线上问题。3) 子工程内部共享常量:即在当前子工程的constant目录下。4) 包内共享常量:即在当前包下单独的constant目录下。5) 类内共享常量:直接在类内部private static final定义。 5. 【推荐】如果变量值仅在一个范围内变化用 Enum 类如果还带有名称之外的延伸属性,必须 使用 Enum 类,下面正例中的数字就是延伸信息,表示星期几。正例:public Enum{ MONDAY(1), TUESDAY(2), WEDNESDAY(3), THURSDAY(4), FRIDAY(5), SATURDAY(6), SUNDAY(7);}","tags":[{"name":"java","slug":"java","permalink":"http://yvshuo.github.io/tags/java/"},{"name":"java文档","slug":"java文档","permalink":"http://yvshuo.github.io/tags/java文档/"}]},{"title":"阿里巴巴java开发手册解读1-命名规约","date":"2017-02-09T14:43:47.000Z","path":"2017/02/09/2017-02-09-javarule-1/","text":"今天拜读了阿里巴巴刚发布的java开发手册，之前做项目时在一些细节的处理上总是不知道如何下手，看完这个手册，收获颇多。附手册全文。 阿里巴巴java开发手册 下面是摘录加批注。注：引用标签内为批注，字面规则不附批注。 1. 【强制】 代码中的命名均不能以下划线或美元符号开始，也不能以下划线或美元符号结束反例:name / __name / $Object / name / name$ / Object$ 批注:javascript表示不服！ 2. 【强制】 代码中的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式说明：正确的英文拼写和语法可以让阅读者易于理解，避免歧义。注意，即使纯拼音命名方式也要避免采用反例：DaZhePromotion [打折] / getPingfenByName() [评分] / int 某变量 = 3正例：alibaba / taobao / youku / hangzhou 等国际通用的名称，可视同英文。 批注:用拼音命名的同学请举起手！你不是一个人！ 3. 【强制】类名使用 UpperCamelCase 风格，必须遵从驼峰形式以下情形例外：（领域模型的相关命名）DO / BO / DTO / VO 等正例：MarcoPolo / UserDO / XmlService / TcpUdpDeal / TaPromotion反例：macroPolo / UserDo / XMLService / TCPUDPDeal / TAPromotion 批注:1） DO(data object) 数据对象2） DAO(data access object) 数据访问对象3） DTO(Data Transfer Object) 数据传输对象4） VO(value object) 值对象5） BO(business object) 业务对象6） POJO 是 DO/DTO/BO/VO 的统称 4. 【强制】方法名、参数名、成员变量、局部变量都统一使用 lowerCamelCase 风格，必须遵从驼峰形式正例： localValue / getHttpMessage() / inputUserId 5. 【强制】常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长正例： MAX_STOCK_COUNT反例： MAX_COUNT 6. 【强制】抽象类命名使用 Abstract 或 Base 开头；异常类命名使用 Exception 结尾；测试类命名以它要测试的类的名称开始，以 Test 结尾7. 【强制】中括号是数组类型的一部分数组定义如下：String[] args反例：请勿使用 String args[]的方式来定义 批注:务必注意 8. 【强制】POJO 类中布尔类型的变量，都不要加 is否则部分框架解析会引起序列化错误反例：定义为基本数据类型 boolean isSuccess；的属性，它的方法也是 isSuccess()，RPC框架在反向解析的时候，“以为”对应的属性名称是 success，导致属性获取不到，进而抛出异常。 9. 【强制】包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用单数形式，但是类名如果有复数含义，类名可以使用复数形式正例： 应用工具类包名为 com.alibaba.open.util、类名为 MessageUtils（此规则参考spring 的框架结构） 10. 【强制】杜绝完全不规范的缩写，避免望文不知义反例： AbstractClass“缩写”命名成 AbsClass；condition“缩写”命名成 condi，此类随意缩写严重降低了代码的可阅读性。 批注:一个优秀程序员的自我修养！以后还是少用btn，写全button！ 11. 【推荐】如果使用到了设计模式，建议在类名中体现出具体模式说明：将设计模式体现在名字中，有利于阅读者快速理解架构设计思想。正例：public class OrderFactory;public class LoginProxy;public class ResourceObserver; 12. 【推荐】接口类中的方法和属性不要加任何修饰符号（public 也不要加），保持代码的简洁性，并加上有效的 Javadoc 注释。尽量不要在接口里定义变量，如果一定要定义变量，肯定是与接口方法相关，并且是整个应用的基础常量正例：接口方法签名：void f(); 接口基础常量表示：String COMPANY = “alibaba”;反例：接口方法定义：public abstract void f();说明：JDK8 中接口允许有默认实现，那么这个 default 方法，是对所有实现类都有价值的默认实现。 批注:个人还是习惯加上修饰符号。不过接口本身就是public的，要改掉这个坏习惯 13. 接口和实现类的命名有两套规则： 1）【强制】对于 Service 和 DAO 类，基于 SOA 的理念，暴露出来的服务一定是接口，内部的实现类用 Impl 的后缀与接口区别。正例：CacheServiceImpl 实现 CacheService 接口。 2）【推荐】如果是形容能力的接口名称，取对应的形容词做接口名（通常是–able 的形式）。正例：AbstractTranslator 实现 Translatable。 14. 【参考】枚举类名建议带上 Enum 后缀，枚举成员名称需要全大写，单词间用下划线隔开。说明：枚举其实就是特殊的常量类，且构造方法被默认强制是私有正例：枚举名字：DealStatusEnum，成员名称：SUCCESS / UNKOWN_REASON。 15. 【参考】各层命名规约： A) Service/DAO 层方法命名规约 1） 获取单个对象的方法用 get 做前缀。2） 获取多个对象的方法用 list 做前缀。3） 获取统计值的方法用 count 做前缀。4） 插入的方法用 save（推荐）或 insert 做前缀。5） 删除的方法用 remove（推荐）或 delete 做前缀。6） 修改的方法用 update 做前缀。 B) 领域模型命名规约 1） 数据对象：xxxDO，xxx 即为数据表名。2） 数据传输对象：xxxDTO，xxx 为业务领域相关的名称。3） 展示对象：xxxVO，xxx 一般为网页名称。4） POJO 是 DO/DTO/BO/VO 的统称，禁止命名成 xxxPOJO。","tags":[{"name":"java","slug":"java","permalink":"http://yvshuo.github.io/tags/java/"},{"name":"java文档","slug":"java文档","permalink":"http://yvshuo.github.io/tags/java文档/"}]},{"title":"重构—重新组织函数","date":"2017-01-16T03:03:47.000Z","path":"2017/01/16/2017-01-16-refactor/","text":"上次单位人力让挑书，然后选了这本《重构-改善既有代码的设计》这本书，作者Martin Fowler是ThoughtWorks公司的首席科学家。虽然书写于很多年前，但是很多思想在编程中依然非常实用。书里主要是讲的各种重构的手法，但是我觉得看完之后，个人感觉更重要的是告诉自己在写代码的过程中如何从源头上注意一些问题，让自己的代码更合理，更优美。最初选这本书也是因为觉得需要超脱语言的层面去理解一些编程的宏观的一些东西，不然总是觉得自己像个机器一样，写着代码，却不懂怎么写更好，为什么别人都那样分层。书已经看了一遍，似乎明白了一些哪些代码好一些、哪些代码差一点。最近再一边读一边记下这个系列的读书笔记，算是记录吧~ 1. 代码的坏味道 重复代码：如果在两个不相关的类中出现了重复的相同功能的函数，就应该考虑新建一个独立的类将这个重复的函数提炼出去。 过长函数：写代码的过程中，有一个原则。代码块越小，代码的功能就越容易管理，代码的处理和移动也就越轻松。 过大的类：一个类的代码太多的话，最后就会变成一坨，嗯。尽量将特别大的类进行分解。 过长的参数列:拆成bean。 switch泛滥：作者的建议是少用switch，在使用switch的地方考虑使用多态来解决。 数据泥团：数据成群的绑在一起。正确的做法是将总是绑定在一起的数据放到一个对象里。 发散式变化：多种变化都对应同一个类的修改。这种情况下需要考虑将这个类拆开，尽量每种变化只对应一个类的修改。 霰弹式修改：这个类一旦变化，会引发多个类的修改。这种情况下应该尽量将所有需要修改的方法放到一个类里。 2. 重新组织函数2.1 extract method（提炼函数）1) 没有局部变量，直接提炼。2) 有局部变量，把这个局部变量作为参数传入被提炼函数3) 如果需要对局部变量赋值，得需要使用remove Assignments to parameters.如果被赋值的局部变量只在被提炼的函数中被赋值，则把这个局部变量声明到被提炼函数中。如果被赋值的局部变量需要在被提炼的函数其它的地方使用，则需要被提炼函数返回一个被修改后的值。如果遇到返回的不止一个值，则最好的方法是再重新提炼一个新的方法，每次只返回一个值最佳。 before:void printOwing(double amount)&#123; printBanner(); //print details System.out.println(\"amount:\"+amount);&#125; after:void printOwing(double amount)&#123; printBanner(); printDetails(amount);&#125;void printDetails(double amount)&#123; System.out.println(\"amount:\"+amount);&#125; 2.2 inline method(内联函数)before:int getRating()&#123; return (moreThanFiveLateDeliveries()) ? 2:1;&#125;boolean moreThanFiveLateDeliveries()&#123; return _numberOfLateDeliveries &gt; 5;&#125; after:int getRating()&#123; return (_numberOfLateDeliveries &gt; 5) ? 2:1;&#125; 2.3 inline temp(内联临时变量)before:double basePrice = anOrder.basePrice();return (basePrice&gt;1000); after:return (anOrder.basePrice()&gt;1000); 2.4 replace temp with query(以查询取代临时变量)临时变量的问题在于：他们是暂时的，而且只能在所属函数内使用。由于临时变量只在所属函数内可见，所以更好的方法是将其替换为一个查询，这样，同一个类中的所有函数都将可以获得这份信息。before:double basePrice = _quantity * _itemPrice;if(basePrice &gt; 1000) return basePrice * 0.95;else return basePrice * 0.98; after:if(basePrice() &gt; 1000) return basePrice() * 0.95;else return basePrice() * 0.98;double basePrice()&#123; return _quantity * _itemPrice;&#125; 在进行这项重构的时候有个需要注意的就是得确保这个临时变量是否只被赋值了一次，有个技巧是在这个临时变量前加final修饰符，如果不只被赋值一次，编译器就会报错。这时候就不能使用这个方法。 2.5 introduce explaining variable（引入解释型变量）将复杂表达式放进一个临时变量里，以此变量名称来解释表达式的用途。before:if((platform.toUpperCase().indexOf(\"MAC\") &gt; -1) &amp;&amp; (browser.toUpperCase().indexOf(\"IE\") &gt; -1) &amp;&amp; resize&gt;0 )&#123; //do something&#125; after:final boolean isMacOs = platform.toUpperCase().indexOf(\"MAC\") &gt; -1;final boolean isIE = browser.toUpperCase().indexOf(\"IE\") &gt; -1;final boolean wasResized = resize&gt;0;if(isMacOs &amp;&amp; isIE &amp;&amp; wasResized)&#123; //do something&#125; 2.6 split temporary variable（分解临时变量）程序中有某个临时变量被赋值超过一次，它既不是循环变量，也不被用于收集计算结果。针对每次赋值，创造一个独立、对应的临时变量。before:double temp = 2 * (_height + _width);System.out.println(temp);temp = _height + _width;System.out.println(temp); after:final double perimeter = 2 * (_height + _width);System.out.println(perimeter);final double area = _height + _width;System.out.println(area); 个人理解就是这种做法可以保证在重构过程中不出错，不会影响其他抽取函数等操作。而且也可以使代码变得清晰明了。 2.7 remove assignments to parameters（移除对参数的赋值）before:int discount(int inputVal,int quantity,int yearToDate)&#123; if(inputVal &gt; 50) inputVal -= 2; after:int discount(int inputVal,int quantity,int yearToDate)&#123; int result = inputVal; if(inputVal &gt; 50) result -= 2; 这么做主要是为了避免在某些按引用传递参数的语言中对调用端造成影响。而且这么做的话，代码会清晰很多，而且这种在任何语言中都会表现出相同的语义。譬如下面的例子中，在参数是对象的情况下，对参数赋值就会造成一些让人糊涂的影响：public static void main(String[] args) &#123; Date d1 = new Date(); nextDateUpdate(d1); System.out.println(\"d1 after nextday:\"+d1); Date d2 = new Date(); nextDateReplace(d2); System.out.println(\"d2 after nextday:\"+d2);&#125;private static void nextDateUpdate(Date arg)&#123; arg.setDate(arg.getDate()+1);//改变了调用端 System.out.println(\"arg in nextDay update:\"+arg);&#125;private static void nextDateReplace(Date arg)&#123; arg=new Date(arg.getYear(),arg.getMonth(),arg.getDate()+1);//没有改变调用端 System.out.println(\"arg in nextDay replace:\"+arg);&#125; 打印出来的结果是：arg in nextDay update:Wed Jan 18 10:51:18 CST 2017d1 after nextday:Wed Jan 18 10:51:18 CST 2017arg in nextDay replace:Wed Jan 18 00:00:00 CST 2017d2 after nextday:Tue Jan 17 10:51:18 CST 2017 如果代码的语义是按引用传递的，请在调用端检查调用后是否还使用了这个参数。也要检查有多少个按引用传递的参数被赋值后又被使用。请尽量只以return方式返回一个值。如果需要返回的值不止一个，看看可否把需返回的大堆数据变成单一对象，或干脆为每个返回值设计对应的一个独立函数。 2.8 replace method with method object（以函数对象取代函数） 只要将相对独立的代码从大型函数中提炼出来，就可以大大提高代码的可读性。但是，局部变量的存在会增加函数分解难度。如果一个函数中局部变量泛滥，分解函数就会变得困难。这时候就要以函数对象取代函数，将所有局部变量都变成函数对象的字段，从而将大型函数拆解变短。这个就不举例子了~很容易理解。 2.9 substitute algorithm（替换算法）before:String foundPerson(String[] people)&#123; for(int i=0;i&lt;people.length;i++)&#123; if(people[i].equals(\"Don\"))&#123; return \"Don\"; &#125; if(people[i].equals(\"John\"))&#123; return \"John\"; &#125; if(people[i].equals(\"Kent\"))&#123; return \"Kent\"; &#125; &#125; return \"\";&#125; after:String foundPerson(String[] people)&#123; List constants = Arrays.asList(new String[]&#123;\"Don\",\"John\",\"Kent\"&#125;); for(int i=0;i&lt;people.length;i++)&#123; if(constants.contains(people[i]))&#123; return people[i]; &#125; &#125; return \"\";&#125; 进行算法重构的步骤：1)准备好另一个（替换用）的算法，让它通过编译。2)针对现有测试，执行上述的新算法。如果结果与原本结果相同，重构结束。3)如果测试结果不同于原先，在测试和调试过程中，以旧算法为比较参照标准。 对于每个测试用例，分别以新旧两种算法执行，并观察两者结果是否相同。 3. 小结这篇主要是对函数中的代码进行整理~都是些基本的重构手法，真正写代码过程中还是要根据实际情况来有针对性的使用。文中有些是我个人的理解，不一定正确。还是要多读书才能深入理解~","tags":[{"name":"重构","slug":"重构","permalink":"http://yvshuo.github.io/tags/重构/"}]},{"title":"git知识备忘","date":"2017-01-11T12:23:51.000Z","path":"2017/01/11/2017-01-11-review-git/","text":"单位用的svn，一个多月不用git，发现有些命令就忘了- -所以这是一篇git操作备忘。主要内容转载自常用 Git 命令清单。 1. git基本示意 Workspace：工作区 Index / Stage：暂存区 Repository：仓库区（或本地仓库） Remote：远程仓库 2. 常用操作命令2.1 新建代码库# 在当前目录新建一个Git代码库$ git init# 新建一个目录，将其初始化为Git代码库$ git init [project-name]# 下载一个项目和它的整个代码历史$ git clone [url] 2.2 配置Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。# 显示当前的Git配置$ git config --list# 编辑Git配置文件$ git config -e [--global]# 设置提交代码时的用户信息$ git config [--global] user.name \"[name]\"$ git config [--global] user.email \"[email address]\" 2.3 增加/删除文件# 添加指定文件到暂存区$ git add [file1] [file2] ...# 添加指定目录到暂存区，包括子目录$ git add [dir]# 添加当前目录的所有文件到暂存区$ git add .# 添加每个变化前，都会要求确认# 对于同一个文件的多处变化，可以实现分次提交$ git add -p# 删除工作区文件，并且将这次删除放入暂存区$ git rm [file1] [file2] ...# 停止追踪指定文件，但该文件会保留在工作区$ git rm --cached [file]# 改名文件，并且将这个改名放入暂存区$ git mv [file-original] [file-renamed] 2.4 代码提交# 提交暂存区到仓库区$ git commit -m [message]# 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message]# 提交工作区自上次commit之后的变化，直接到仓库区$ git commit -a# 提交时显示所有diff信息$ git commit -v# 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息$ git commit --amend -m [message]# 重做上一次commit，并包括指定文件的新变化$ git commit --amend [file1] [file2] ... 2.5 分支# 列出所有本地分支$ git branch# 列出所有远程分支$ git branch -r# 列出所有本地分支和远程分支$ git branch -a# 新建一个分支，但依然停留在当前分支$ git branch [branch-name]# 新建一个分支，并切换到该分支$ git checkout -b [branch]# 新建一个分支，指向指定commit$ git branch [branch] [commit]# 新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区$ git checkout [branch-name]# 切换到上一个分支$ git checkout -# 建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream [branch] [remote-branch]# 合并指定分支到当前分支$ git merge [branch]# 选择一个commit，合并进当前分支$ git cherry-pick [commit]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch] 2.6 标签# 列出所有tag$ git tag# 新建一个tag在当前commit$ git tag [tag]# 新建一个tag在指定commit$ git tag [tag] [commit]# 删除本地tag$ git tag -d [tag]# 删除远程tag$ git push origin :refs/tags/[tagName]# 查看tag信息$ git show [tag]# 提交指定tag$ git push [remote] [tag]# 提交所有tag$ git push [remote] --tags# 新建一个分支，指向某个tag$ git checkout -b [branch] [tag] 2.7 查看信息# 显示有变更的文件$ git status# 显示当前分支的版本历史$ git log# 显示commit历史，以及每次commit发生变更的文件$ git log --stat# 搜索提交历史，根据关键词$ git log -S [keyword]# 显示某个commit之后的所有变动，每个commit占据一行$ git log [tag] HEAD --pretty=format:%s# 显示某个commit之后的所有变动，其\"提交说明\"必须符合搜索条件$ git log [tag] HEAD --grep feature# 显示某个文件的版本历史，包括文件改名$ git log --follow [file]$ git whatchanged [file]# 显示指定文件相关的每一次diff$ git log -p [file]# 显示过去5次提交$ git log -5 --pretty --oneline# 显示所有提交过的用户，按提交次数排序$ git shortlog -sn# 显示指定文件是什么人在什么时间修改过$ git blame [file]# 显示暂存区和工作区的差异$ git diff# 显示暂存区和上一个commit的差异$ git diff --cached [file]# 显示工作区与当前分支最新commit之间的差异$ git diff HEAD# 显示两次提交之间的差异$ git diff [first-branch]...[second-branch]# 显示今天你写了多少行代码$ git diff --shortstat \"@&#123;0 day ago&#125;\"# 显示某次提交的元数据和内容变化$ git show [commit]# 显示某次提交发生变化的文件$ git show --name-only [commit]# 显示某次提交时，某个文件的内容$ git show [commit]:[filename]# 显示当前分支的最近几次提交$ git reflog 2.8 远程同步# 下载远程仓库的所有变动$ git fetch [remote]# 显示所有远程仓库$ git remote -v# 显示某个远程仓库的信息$ git remote show [remote]# 增加一个新的远程仓库，并命名$ git remote add [shortname] [url]# 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch]# 上传本地指定分支到远程仓库$ git push [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force# 推送所有分支到远程仓库$ git push [remote] --all 2.9 撤销# 恢复暂存区的指定文件到工作区$ git checkout [file]# 恢复某个commit的指定文件到暂存区和工作区$ git checkout [commit] [file]# 恢复暂存区的所有文件到工作区$ git checkout .# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file]# 重置暂存区与工作区，与上一次commit保持一致$ git reset --hard# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit]# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset --hard [commit]# 重置当前HEAD为指定commit，但保持暂存区和工作区不变$ git reset --keep [commit]# 新建一个commit，用来撤销指定commit# 后者的所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit]# 暂时将未提交的变化移除，稍后再移入$ git stash$ git stash pop 2.10 其他# 生成一个可供发布的压缩包$ git archive 3 总结嗯，看来我是有一段时间没有抽时间好好学习了~最近在读一本讲java重构的书~回头写个读书笔记→_→","tags":[{"name":"git","slug":"git","permalink":"http://yvshuo.github.io/tags/git/"}]},{"title":"微信小程序初体验","date":"2016-11-27T03:03:47.000Z","path":"2016/11/27/2016-11-27-wxapp/","text":"p.s. 这篇文章是一个月之前写的，因为最近忙于其他项目，所以一直没来维护这个博客~微信小程序貌似也有了新的更新。先把这篇贴上，后续填坑23333 利用周末时间基于cnode社区的api撸了一发微信小程序，记录一下。 1、开发环境微信mac版开发工具0.11.112301下载地址：使劲戳我其他版本下载地址：继续戳我 2、项目创建扫码登录后按下图输入创建项目 创建项目后界面的样子和默认的文件目录结构 分析下目录结构pages目录下有两个页面，index和logs。.js文件是负责处理该页面的逻辑，.wxml负责视图以及绑定一些交互事件，.wxss来写css样式，.json用来配置一些配置参数或者定义一些静态常量。utils目录下是一个工具类。根目录下的app.js是小程序的入口文件，用来注册app。app.json可以用来配置全局常量，app.wxss用来配置项目的公用样式。 初始程序提供了一个从index页面到logs页面的跳转index.wxml中绑定的bindViewTab函数就是前面在index.js中标出的那个函数。函数中调用微信小程序的api定义了一个跳转bindViewTap: function() &#123; wx.navigateTo(&#123; url: '../logs/logs' &#125;)&#125; 另外，在logs.js中调用了一下微信的apiwx.getStorageSync(KEY)从本地缓存中同步获取指定key对应的内容。//app.jsonLaunch: function () &#123; //调用API从本地缓存中获取数据 var logs = wx.getStorageSync('logs') || [] logs.unshift(Date.now()) wx.setStorageSync('logs', logs)&#125; 在小程序启动的时候就会在本地存储的logs中记录下当前时间，添加到数组的最前面。所以每次重新启动小程序后在logs页面就会加一条数据。重新启动前：重新启动后: 3、组件介绍组件就是视图层的基本组成单元，简单的理解就是微信小程序提供的一些标签库，通过使用这些组件，可以快速搭建自带一些微信基本风格的视图。官方说明文档：请大力戳我&lt;!--logs.wxml--&gt;&lt;view class=\"container log-list\"&gt; &lt;block wx:for=\"&#123;&#123;logs&#125;&#125;\" wx:for-item=\"log\" wx:key=\"*this\"&gt; &lt;text class=\"log-item\"&gt;&#123;&#123;index + 1&#125;&#125;. &#123;&#123;log&#125;&#125;&lt;/text&gt; &lt;/block&gt;&lt;/view&gt; 上面代码中的view标签和text标签就是组件，view是一个视图容器，支持嵌套。text就是一个文本组件。&lt;!--index.wxml--&gt;&lt;view class=\"container\"&gt; &lt;view bindtap=\"bindViewTap\" class=\"userinfo\"&gt; &lt;image class=\"userinfo-avatar\" src=\"&#123;&#123;userInfo.avatarUrl&#125;&#125;\" background-size=\"cover\"&gt;&lt;/image&gt; &lt;text class=\"userinfo-nickname\"&gt;&#123;&#123;userInfo.nickName&#125;&#125;&lt;/text&gt; &lt;/view&gt; &lt;view class=\"usermotto\"&gt; &lt;text class=\"user-motto\"&gt;&#123;&#123;motto&#125;&#125;&lt;/text&gt; &lt;/view&gt;&lt;/view&gt; 这个就是在一个父view中嵌套了两个子view。在logs.wxml中还有一个地方，就是block标签，这个是小程序框架中提供的一个包装元素，它不是一个组件，不会在页面中做任何渲染，只会接受基本的控制属性。 4、API介绍小程序的框架提供了很多微信原生的API，可以方便的调起微信提供的能力，如获取用户信息，本地存储，支付功能等。官方文档：不要停，继续戳截止到目前，微信小程序提供了7大类API，网络、媒体、数据、位置、设备、界面、开放接口。个人比较感兴趣的就是媒体类的API，提供了大量基于微信原生的丰富功能。看到了一个打开文档的接口wx.openDocument(OBJECT)，感觉可以基于这个接口开发一个管理微信聊天中发布的文档的小应用，然后需要的时候拿出来读~以后就再也不需要翻聊天记录翻来翻去了~因吹思婷！另外界面API也很喜欢，一直以来都非常喜欢微信的UI设计，读了小程序的设计指南之后更是觉得微信的设计团队好厉害。小程序的设计指南：戳吧至于开放接口的API，个人感觉这块文档还很乱，另外个人开发者好像不能用。学习的时候感觉非常的蛋疼。希望能提供一个供学习的沙盒接口，同时完善下教程。 5、开始撸代码首先放上cnode社区的API文档：感谢cnode社区，请戳我这里有个微信开发者工具的BUG，开发过程中发现我修改的代码始终处于一种缓存状态，修改的代码没法更新上去。选择了清除文件缓存和数据缓存，包括重启等方法均不行。嗯。。最后发现默认的这个代码热更新有BUG，导致了以上问题。如果还是发现代码不能更新的话，切换下这个选项框的选择状态就可以刷新项目了。 5.1 配置使用根目录下的app.json来进行全局配置。&#123; \"pages\": [ \"pages/index/index\", \"pages/logs/index\" ], \"window\": &#123; \"navigationBarTitleText\": \"Demo\" &#125;, \"tabBar\": &#123; \"list\": [&#123; \"pagePath\": \"pages/index/index\", \"text\": \"首页\" &#125;, &#123; \"pagePath\": \"pages/logs/logs\", \"text\": \"日志\" &#125;] &#125;, \"networkTimeout\": &#123; \"request\": 10000, \"downloadFile\": 10000 &#125;, \"debug\": true&#125; 下面给出各个配置项的说明： 属性 类型 必填 描述 pages String Array 是 设置页面路径 window Object 否 设置默认页面的窗口表现 tabBar Object 否 设置底部 tab 的表现 networkTimeout Object 否 设置网络超时时间 debug Boolean 否 设置是否开启 debug 模式 除了pages外其他几个属性都不是必须的。tabBar可以页面上方或者下方添加tab选项卡，最少2个选项卡，最多5个选项卡。每个选项的配置项都可以在 这里 查到，不再赘述。 5.2 注册APP微信小程序是在根目录的app.js里通过App()函数来注册小程序的。这个函数可以接收一个object参数，指定小程序的生命周期函数等。 属性 类型 描述 触发时机 onLaunch Function 监听小程序初始化 当小程序初始化完成时，会触发 onLaunch（全局只触发一次） onShow Function 监听小程序显示 当小程序启动，或从后台进入前台显示，会触发 onShow onHide Function 监听小程序隐藏 当小程序从前台进入后台，会触发 onHide 其他 Any 开发者可以添加任意的函数或数据到 Object 参数中，用 this 可以访问 - 所以可以在这里配一些全局的静态参数什么的~","tags":[{"name":"微信小程序","slug":"微信小程序","permalink":"http://yvshuo.github.io/tags/微信小程序/"}]},{"title":"使用ESLint检查语法和代码风格","date":"2016-11-15T13:37:39.000Z","path":"2016/11/15/2016-11-15-eslint/","text":"在学习ECMAScript6的过程中发现了一个代码风格和语法的检查工具，ESLint，记录一下。 安装这里记录的安装方法是通过npm的安装，所以前提条件是已经安装了npm。如果没有安装的话，建议直接安装nvm，可以方便的切换node的版本。npm i -g eslint 通过以上命令即可完成eslint CLI的安装。 使用ESLint的运行格式如下：eslint [options] [file|dir|glob]* 以下的几种方式都是可行的：eslint file1.js file2.jseslint lib/**eslint \"lib/**\" 选项以下的内容可以通过eslint -h来查阅eslint [options] file.js [file.js] [dir]Basic configuration: -c, --config path::String Use configuration from this file or shareable config --no-eslintrc Disable use of configuration from .eslintrc --env [String] Specify environments --ext [String] Specify JavaScript file extensions - default: .js --global [String] Define global variables --parser String Specify the parser to be used --parser-options Object Specify parser optionsCaching: --cache Only check changed files - default: false --cache-file path::String Path to the cache file. Deprecated: use --cache-location - default: .eslintcache --cache-location path::String Path to the cache file or directorySpecifying rules and plugins: --rulesdir [path::String] Use additional rules from this directory --plugin [String] Specify plugins --rule Object Specify rulesIgnoring files: --ignore-path path::String Specify path of ignore file --no-ignore Disable use of ignore files and patterns --ignore-pattern [String] Pattern of files to ignore (in addition to those in .eslintignore)Using stdin: --stdin Lint code provided on &lt;STDIN&gt; - default: false --stdin-filename String Specify filename to process STDIN asHandling warnings: --quiet Report errors only - default: false --max-warnings Int Number of warnings to trigger nonzero exit code - default: -1Output: -o, --output-file path::String Specify file to write report to -f, --format String Use a specific output format - default: stylish --color, --no-color Force enabling/disabling of colorMiscellaneous: --init Run config initialization wizard - default: false --fix Automatically fix problems --debug Output debugging information -h, --help Show help -v, --version Output the version number --no-inline-config Prevent comments from changing config or rules --print-config path::String Print the configuration for the given file 例子：eslint --ext .jsx --ext .js file.jseslint --ext .jsx,.js file.js 基本配置 -c,–config这个选项能给ESLint指定一个附加的配置文件。例子：eslint -c ~/my-eslint.json file.js 这个例子使用~/my-eslint.json这个配置文件。还有一种是使用共享的配置。例子：eslint -c airbnb file.js 这个例子使用的是eslint-config-airbnb的配置，使用之前需要安装。$ npm i -g eslint-config-airbnb –no-eslintrc禁用.eslintrc和package.json中的配置例子： eslint --no-eslintrc file.js –env指定特定的环境例子： eslint --env browser,node file.jseslint --env browser --env node file.js –ext配置ESLint对哪些文件类型起作用例子： # 只对 .js2 后缀的文件类型起作用eslint . --ext .js2# 对 .js 和 .js2 后缀的文件类型都起作用eslint . --ext .js --ext .js2# 对 .js 和 .js2 后缀的文件类型都起作用eslint . --ext .js,.js2 –ext配置ESLint对哪些文件类型起作用例子： # 只对 .js2 后缀的文件类型起作用eslint . --ext .js2# 对 .js 和 .js2 后缀的文件类型都起作用eslint . --ext .js --ext .js2# 对 .js 和 .js2 后缀的文件类型都起作用eslint . --ext .js,.js2 –global设置全局参数例子： eslint --global require,exports:true file.jseslint --global require --global exports:true –global设置全局参数例子： eslint --global require,exports:true file.jseslint --global require --global exports:true –plugin设置需要载入的插件。设置前需要通过npm安装要载入的插件。例子： eslint --plugin jquery file.jseslint --plugin eslint-plugin-mocha file.js –rule直接设置要使用的规则。例子： eslint --rule 'quotes: [2, double]'eslint --rule 'guard-for-in: 2' --rule 'brace-style: [2, 1tbs]'eslint --rule 'jquery/dollar-sign: 2' –ignore-path设置一个文件来代替.eslintignore的功能，如果不设置的话，eslint默认会使用当前工作空间的.eslintignore例子： eslint --ignore-path tmp/.eslintignore file.jseslint --ignore-path .gitignore file.js –no-ignore禁用.eslintignore, --ignore-path和--ignore-pattern中的例外情况例子： eslint --no-ignore file.js –ignore-pattern设置忽略匹配指定正则类型的文件例子： eslint --ignore-pattern '/lib/' --ignore-pattern '/src/vendor/*' . –quiet禁用reporting和warning，ESlint将只通知error例子： eslint --quiet file.js –max-warnings设置eslint警告的临界值，在错误过多时强制eslint退出例子： eslint --max-warnings 10 file.js -o, –output-file将report写进指定文件例子： eslint -o ./test/test.html -f, –format指定report输出的格式，可选格式为checkstyle，codeframe，compact，html，jslint-xml，json，junit，stylish (the default)，table，tap，unix，visualstudio。例子： eslint -f compact file.js –color, –no-color指定report的颜色例子： eslint --color file.js | cateslint --no-color file.js init初始化一些基本的配置。可以帮助新用户快速配置。 -h, –help获得帮助菜单 -v, –version显示当前的eslint版本 –print-config打印当前eslint的配置信息 在.eslintignore中设置忽略的文件 node_modules/***/vendor/*.js 实际例子在这个例子中使用Airbnb的语法规则。安装Airbnb的语法规则：$ npm i -g eslint-config-airbnb 在项目的根目录下新建一个.eslintrc文件，配置ESLint。&#123; \"extends\": \"eslint-config-airbnb\"&#125; 待检查的index.js的代码如下：var unusued = 'I have no purpose!';function greet() &#123; var message = 'Hello, World!'; alert(message);&#125;greet(); 使用ESLint检查这个文件$ eslint index.js 控制台输出：index.js 1:5 error unusued is defined but never used no-unused-vars 4:5 error Expected indentation of 2 characters but found 4 indent 5:5 error Expected indentation of 2 characters but found 4 indent✖ 3 problems (3 errors, 0 warnings) 上面代码说明，原文件有三个错误，一个是定义了变量，却没有使用，另外两个是行首缩进为4个空格，而不是规定的2个空格。 参考文章 1、ESLint Command Line Interface2、ECMAScript 6 入门-编程风格-ESLint的使用","tags":[{"name":"js","slug":"js","permalink":"http://yvshuo.github.io/tags/js/"}]},{"title":"webpack简介","date":"2016-10-26T15:21:48.000Z","path":"2016/10/26/2016-10-26-webpacknote/","text":"最近一直在研究vue，顺带着研究了一下webpack。本文只是一篇简短的记录，后续会继续更新一些webpack深入的学习笔记。 webpack概述简单的说，webpack是一个前端的打包工具。它做的事情就是将你项目中使用的各种前端模块打包到一起，转换为合适的格式发布。通过使用webpack，可以将各种其他格式，如scss、typescript等拓展类型的语言转换为可运行的javascript。配合webpack的核心loaders和plugins，可以灵活的实现各种需求，非常的强力！下面是一个典型的webpack的配置文件： var webpack = require('webpack');var HtmlWebpackPlugin = require('html-webpack-plugin');var ExtractTextPlugin = require('extract-text-webpack-plugin');module.exports = &#123; entry: __dirname + \"/app/main.js\", output: &#123; path: __dirname + \"/build\", filename: \"[name]-[hash].js\" &#125;, module: &#123; loaders: [ &#123; test: /\\.json$/, loader: \"json\" &#125;, &#123; test: /\\.js$/, exclude: /node_modules/, loader: 'babel' &#125;, &#123; test: /\\.css$/, loader: ExtractTextPlugin.extract('style', 'css?modules!postcss') &#125; ] &#125;, postcss: [ require('autoprefixer') ], plugins: [ new HtmlWebpackPlugin(&#123; template: __dirname + \"/app/index.tmpl.html\" &#125;), new webpack.optimize.OccurenceOrderPlugin(), new webpack.optimize.UglifyJsPlugin(), new ExtractTextPlugin(\"[name]-[hash].css\") ]&#125; 下面就来具体解释下webpack的使用方法以及配置文件的意思。 基于webpack项目的基本结构通常会包含一些子模块文件目录以及一个package.json和webpack.config.js的文件。因为webpack是运行在nodejs环境下的，所以package.json中配置项目依赖，然后在webpack.config.js中配置打包的一些信息。在package.json中通常会在script配置项下配置webpack的不同的运行信息。//package.json&#123; \"name\": \"webpack-sample-project\", \"version\": \"1.0.0\", \"description\": \"Sample webpack project\", \"scripts\": &#123; \"start\": \"webpack-dev-server --progress\", \"build\": \"NODE_ENV=production webpack --config ./webpack.production.config.js --progress\" &#125;, \"author\": \"Cássio Zen\", \"license\": \"ISC\", \"devDependencies\": &#123;...&#125;, \"dependencies\": &#123;...&#125;&#125; 然后通过npm start就可以运行webpack开发状态下的打包命令，通过npm build就可以运行webpack生产环境下的打包命令了～轻松愉快 loadersLoaders是webpack中最让人激动人心的功能之一了。通过使用不同的loader，webpack通过调用外部的脚本或工具可以对各种各样的格式的文件进行处理，比如说分析JSON文件并把它转换为JavaScript文件，或者说把下一代的JS文件（ES6，ES7)转换为现代浏览器可以识别的JS文件。或者说对React的开发而言，合适的Loaders可以把React的JSX文件转换为JS文件。 Loaders需要单独安装并且需要在webpack.config.js下的modules关键字下进行配置，Loaders的配置选项包括以下几方面： test：一个匹配loaders所处理的文件的拓展名的正则表达式（必须） loader：loader的名称（必须） include/exclude:手动添加必须处理的文件（文件夹）或屏蔽不需要处理的文件（文件夹）（可选）； query：为loaders提供额外的设置选项（可选） 在前面的代码中有以下一段：&#123; test: /\\.js$/, exclude: /node_modules/, loader: 'babel'&#125; 这句的意思就是对除掉node_modules文件夹中js文件外的所有js文件使用npm安装的babel-loader来进行处理。loaders为webpack提供了极其灵活的特性，可以使用丰富的第三方loaders来实现自己特定的需求。 plugins插件（Plugins）是用来拓展Webpack功能的，它们会在整个构建过程中生效，执行相关的任务。Loaders和Plugins常常被弄混，但是他们其实是完全不同的东西，可以这么来说，loaders是在打包构建过程中用来处理源文件的（JSX，Scss，Less..），一次处理一个，插件并不直接操作单个文件，它直接对整个构建过程其作用。Webpack有很多内置插件，同时也有很多第三方插件，可以让我们完成更加丰富的功能。 我们以HtmlWebpackPlugin插件为例来说明webpack中使用plugins的方法。这个插件的作用是依据一个简单的模板，帮你生成最终的Html5文件，这个文件中自动引用了你打包后的JS文件。每次编译都在文件名中插入一个不同的哈希值。 1.安装npm install --save-dev html-webpack-plugin 2.在项目的app目录下创建一个html模版，我们将其命名为index.tmpl.html&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;Webpack Sample Project&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id='root'&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 3.更新webpack的配置文件，新建一个build文件夹用来存放最终的输出文件var webpack = require('webpack'); var HtmlWebpackPlugin = require('html-webpack-plugin'); module.exports = &#123; devtool: 'eval-source-map', entry: __dirname + \"/app/main.js\", output: &#123; path: __dirname + \"/build\", filename: \"bundle.js\" &#125;, module: &#123; loaders: [ &#123; test: /\\.json$/, loader: \"json\" &#125;, &#123; test: /\\.js$/, exclude: /node_modules/, loader: 'babel' &#125;, &#123; test: /\\.css$/, loader: 'style!css?modules!postcss' &#125; ] &#125;, postcss: [ require('autoprefixer') ], plugins: [ new HtmlWebpackPlugin(&#123; template: __dirname + \"/app/index.tmpl.html\"//new 一个这个插件的实例，并传入相关的参数 &#125;) ], devServer: &#123; colors: true, historyApiFallback: true, inline: true &#125; &#125; 4.在编译过程中，本插件就会依据此模板生成最终的html页面，会自动添加所依赖的 css, js，favicon等文件 小结本文仅仅是对webpack的主要功能做一个很简单的介绍，它丰富的特性需要在使用中逐渐体会，后续还会继续更新相关内容。 参考资料 1、 Webpack for React2、 入门Webpack，看这篇就够了3、 一小时包教会 —— webpack 入门指南","tags":[{"name":"webpack","slug":"webpack","permalink":"http://yvshuo.github.io/tags/webpack/"}]},{"title":"一篇关于javascript闭包的笔记","date":"2016-10-11T15:21:48.000Z","path":"2016/10/11/2016-10-11-closure/","text":"今天读到了一篇讲闭包的文章，是我目前看到的最透彻的一篇闭包的讲解。趁热记一下笔记。 在我以前的认识中，一直觉得闭包就是在js中提供了一种类似于java中get方法的功能，使我们可以通过闭包来访问到函数体内的局部变量。然鹅，我的理解也就顶多意会了闭包的一点皮毛。下面就直接通过代码来记录一下这篇文章中写到的知识点。 静态作用域的理解var x = 10;function foo() &#123; var y = x + 5; return y; &#125; function bar() &#123; var x = 2; return foo(); &#125; function main() &#123; foo(); // Static scope: 15; Dynamic scope: 15 bar(); // Static scope: 15; Dynamic scope: 7 return 0; &#125; 现在大部分的程序语言都是使用的静态作用域的规则，基本就是内嵌套作用域规则。 内嵌套作用域规则：由一个声明引进的标识符在这个声明所在的作用域里可见，而且在其内部嵌套的每个作用域里也可见，除非它被嵌套于内部的对同名标识符的另一个声明所掩盖。为了找到某个给定的标识符所引用的对象，应该在当前最内层作用域里查找。如果找到了一个声明，也就可以找到该标识符所引用的对象。否则我们就到直接的外层作用域里去查找，并继续向外顺序地检查外层作用域，直到到达程序的最外嵌套层次，也就是全局对象声明所在的作用域。如果在所有层次上都没有找到有关声明，那么这个程序就有错误。 所以这个程序main()中的foo()和bar()在js中的返回值都是15。 var result = []; for (var i = 0; i &lt; 5; i++) &#123; result[i] = function () &#123; console.log(i); &#125;; &#125; result[0](); // 5, expected 0 result[1](); // 5, expected 1 result[2](); // 5, expected 2 result[3](); // 5, expected 3 result[4](); // 5, expected 4 上面这个程序中日志输出的就都是5。 保留外部作用域对一个变量的私有引用这个就是我之前对闭包的理解。function secretPassword() &#123; var password = 'xh38sk'; return &#123; guessPassword: function(guess) &#123; if (guess === password) &#123; return true; &#125; else &#123; return false; &#125; &#125; &#125; &#125; var passwordGame = secretPassword();passwordGame.guessPassword('heyisthisit?'); // false passwordGame.guessPassword('xh38sk'); // true 通过闭包，我们可以在secretPassword()函数的外部访问到它的私有变量password。 每调用一次函数就会创建一个单独的闭包function iCantThinkOfAName(num, obj) &#123; // This array variable, along with the 2 parameters passed in, // are 'captured' by the nested function 'doSomething' var array = [1, 2, 3]; function doSomething(i) &#123; num += i; array.push(num); console.log('num: ' + num); console.log('array: ' + array); console.log('obj.value: ' + obj.value); &#125; return doSomething; &#125; var referenceObject = &#123; value: 10 &#125;; var foo = iCantThinkOfAName(2, referenceObject); // closure #1 var bar = iCantThinkOfAName(6, referenceObject); // closure #2foo(2);/* num: 4 array: 1,2,3,4 obj.value: 10 */ bar(2); /* num: 8 array: 1,2,3,8 obj.value: 10 */ referenceObject.value++; foo(4); /* num: 8 array: 1,2,3,4,8 obj.value: 11 */ bar(4); /* num: 12 array: 1,2,3,8,12 obj.value: 11 */ 先得赞一下作者起的这个函数名，iCantThinkOfAName2333333,很喜欢这种画风。顺带提一下今天在github上看到一个开原协议，叫WTFPL,感兴趣的话可以戳一下这个协议的WIKI链接。全名叫做Do What the Fuck You Want To Public License。哈哈哈哈哈，简直笑尿。 呐，回到上面的程序。这里就用了闭包的一个很重要的特性，var foo = iCantThinkOfAName(2, referenceObject); // closure #1 var bar = iCantThinkOfAName(6, referenceObject); // closure #2 上面这两句创建了两个独立的闭包，每个闭包对iCantThinkOfAName函数中array这个私有变量都创建了一个自己独立的引用（这个概念大概不准确，但是大概可以这么类比吧→_→），而且还能保存住自己作用域中的变量，很有点新建一个对象的感觉- -用作者翻译的话来说就是： 每个函数都有一个执行上下文，它包括一个在函数中赋予变量含义的词法环境和对其父环境的引用。因为函数对环境的引用，使它看起来就像是函数“记住了”这个环境（作用域）一样。这就是一个闭包 仿佛明白了一些了不起的道理！厉害！","tags":[{"name":"js","slug":"js","permalink":"http://yvshuo.github.io/tags/js/"}]},{"title":"配置hexo的一键打包部署","date":"2016-10-07T04:31:27.000Z","path":"2016/10/07/2016-10-07-githubssh/","text":"今天研究了一下hexo的自动打包部署，记录一下。 配置github的ssh本地生成公钥运行 git Bash 客户端，检查是否已经配置过SSH key。$ cd ~/.ssh$ ls 如果没有 id_rsa 和 id_rsa.pub，则需要创建一个SSH key。 $ ssh-keygen -t rsa -C \"XXX@XXX.com\" -t 制定密钥类型，默认rsa，可以省略 -C 设置注释文字，通常设置自己的邮箱 -f 制定密钥文件存储文件名 然后就会生成 id_rsa 和 id_rsa.pub 两个文件，其中 id_rsa.pub就是我们要配在github里的公钥。 在github中配置ssh key在github中找到配置项的SSH and GPG keys，然后按下图所示配置。 配置完成后，测试一下是否配置成功。$ ssh -T git@github.com 如果显示以下警告：The authenticity of host 'github.com (207.97.227.239)' can't be established.# RSA key fingerprint is &lt;your fingerprint&gt;.# Are you sure you want to continue connecting (yes/no)? 则说明已经配置成功了，输入yes即可。 配置hexo的自动打包部署安装hexo-deployer-git还是通过npm来安装，输入下面的命令，稍等片刻即可安装成功。$ npm install hexo-deployer-git --save 修改配置在根目录的_config.yml中找到以下代码段。deploy: type: git repo: &lt;repository url&gt; branch: [branch] message: [message] repo 里配置git仓库的信息，这里我的就是git@github.com:yvshuo/yvshuo.github.io branch 里配置分支名称，我的是主分支，就配置的master message 是自定义提交的信息，默认为Site updated: {{ now('YYYY-MM-DD HH:mm:ss') }}，可以空着 自动部署提交配置完成后，剩下的就是一条命令了。$ hexo generate --deploy 缩写的命令也是可以的。$ hexo g --d 开开心心。。。。 最后唠叨几句 记得关掉vpn代理啥的，不然ssh可能会有问题 发现一篇很好的介绍hexo的文章，戳Hexo在github上构建免费的Web应用 明天又要上班了，终于又可以开心的建设社会主义了。。。。。。（逃","tags":[{"name":"hexo","slug":"hexo","permalink":"http://yvshuo.github.io/tags/hexo/"}]},{"title":"使用hexo在github上搭建博客的记录","date":"2016-10-05T16:40:58.000Z","path":"2016/10/06/2016-10-06-create/","text":"工作已经一年了，想着该稍微停下来总结一下了。恰巧印象笔记开始限终端限流量。于是就有了写博客记录一下日常感想，同时将之前的一些笔记迁移到博客的想法。 在github闲逛的时候看到了Litten的博客，很是喜欢。于是发现了hexo,各种特性都让我甚是喜欢，就这么对Hexo一见钟情了。在知乎上搜到了一篇介绍hexo主题的回答,一圈看下来，还是比较喜欢Yilia这个主题，也就是我最早看到的Litten开发的~缘分啊，（逃 于是果断决定使用这个主题，计划着先直接用着，后续有时间的话自己也试着DIY一下自己的主题。 废话不多说了，简单的记录一下第一次搭建Hexo博客的过程。 概述Hexo是在nodejs环境下搭建的，在npm的帮助下几行命令就轻松搞定，简直是轻松愉快。当然了，前提是已经安装好了git和nodejs。 $ npm install hexo-cli -g$ hexo init blog$ cd blog$ npm install$ hexo server 切换主题同样很方便，到博客的根目录下，将主题git下来。 $ git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 然后修改根目录下_config.yml中的配置项theme: yilia。如果server是在运行状态下，甚至都不需要重启。只需要刷新下页面，新的主题就已经换上去了。开开心心- - 新建文章$ hexo new \"我的文章\" 这样就会生成一篇叫“我的文章”的文章了。默认会在_posts文件夹下新建一个对应的markdown文件“我的文章.md”，编辑这个md文件就可以写文章并发布了。格式遵循md的语法。 生成静态文件$ hexo generate 生成的静态文件在public文件夹中，这些文件就可以提交到github来搭建自己的个人博客了~简直炫酷。 发布到github上每个github账号下都默认有一个自己的XXX.github.io的子域名，可以部署静态代码来生成自己的网站。 譬如我的github账号是yvshuo,于是我要新建一个名字叫做yvshuo.github.io的项目。然后到刚才生成的public文件下将代码提交到github仓库里。如果不熟悉git操作，可以参看git-简明指南快速入手。 $ cd public/$ git init$ git add --all$ git commit -m \"create\"$ git remote add origin https://github.com/yvshuo/yvshuo.github.io.git$ git push -u origin master 然后就是享受成果的时候了~~yvshuo 一点点小补充 除了上面说的最基本的一些东西外，还有很多配置和可以自己来diy的东西。具体可参考hexo的中文文档。再次表达对hexo的爱~ md编辑器可以自己在sublime text里配，也可以用专门的编辑器，如MarkdownPad。当然，我觉得最爽的还是在本地开着hexo server然后监听文件变动自动部署，再直接在浏览器里F5~ 今天第一次接触hexo，还有待后续进一步发掘这个工具的强大之处 立FLAG 要把这个博客经营下去。谢老师监督我→_→","tags":[{"name":"hexo","slug":"hexo","permalink":"http://yvshuo.github.io/tags/hexo/"}]}]